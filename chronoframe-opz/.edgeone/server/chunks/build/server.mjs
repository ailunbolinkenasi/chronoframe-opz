import process from 'node:process';globalThis._importMeta_=globalThis._importMeta_||{url:"file:///_entry.js",env:process.env};import * as vue from 'vue';
import { defineComponent, useSlots, ref, inject, computed, mergeProps, unref, withCtx, renderSlot, createBlock, createCommentVNode, openBlock, toDisplayString as toDisplayString$1, createVNode, toRef as toRef$2, isRef, toValue, getCurrentInstance as getCurrentInstance$1, onServerPrefetch, shallowRef, watchEffect, resolveDynamicComponent, h, camelize as camelize$1, watch, resolveComponent, getCurrentScope, nextTick, provide, reactive, createTextVNode, Fragment, renderList, readonly, toHandlerKey, toRefs, Teleport, markRaw, mergeModels, useModel, effectScope, Suspense, hasInjectionContext, Transition, TransitionGroup, customRef, onScopeDispose, cloneVNode, createElementBlock, Comment, toRaw, shallowReactive, useTemplateRef, useAttrs, defineAsyncComponent, useSSRContext, createApp, Text, useId, withDirectives, vShow, withModifiers, withAsyncContext, onErrorCaptured, isReadonly, isShallow, isReactive, normalizeProps, guardReactiveProps, normalizeStyle, normalizeClass, createElementVNode } from 'vue';
import { ar as defu, as as klona, at as defuFn, a2 as destr, al as hash, c as createError$1, au as headSymbol, av as useHead$1, aw as appendResponseHeader, ax as parse$1, ay as getRequestHeader, az as isEqual$2, aA as getContext, aB as setCookie, aC as getCookie, aD as deleteCookie, aE as sanitizeStatusCode, aF as decompressUint8Array, aG as $fetch$1, aH as baseURL, aI as resolveUnrefHeadInput, aJ as isMapboxMap, aK as createHooks, aL as executeAsync, aM as toRouteMatcher, aN as createRouter$1, aO as getRequestURL, aP as createDefu } from '../nitro/nitro.mjs';
import { defineStore, storeToRefs, setActivePinia, createPinia, shouldHydrate } from 'pinia';
import { RouterView, useRoute as useRoute$1, createMemoryHistory, createRouter, START_LOCATION } from 'vue-router';
import { stringify, parse as parse$2 } from 'devalue';
import dayjs from 'dayjs';
import updateLocale from 'dayjs/plugin/updateLocale.js';
import dayjsLocale_zhCN from 'dayjs/locale/zh-cn.js';
import dayjsLocale_zhHK from 'dayjs/locale/zh-hk.js';
import relativeTime from 'dayjs/plugin/relativeTime.js';
import utc from 'dayjs/plugin/utc.js';
import timezone from 'dayjs/plugin/timezone.js';
import duration from 'dayjs/plugin/duration.js';
import localizedFormat from 'dayjs/plugin/localizedFormat.js';
import isBetween from 'dayjs/plugin/isBetween.js';
import colors from 'tailwindcss/colors';
import MasonryWall from '@yeger/vue-masonry-wall';
import { ssrRenderComponent, ssrRenderSlot, ssrRenderClass, ssrInterpolate, ssrRenderVNode, ssrRenderStyle, ssrRenderList, ssrRenderAttrs, ssrRenderAttr, ssrRenderTeleport, ssrRenderSuspense } from 'vue/server-renderer';
import { twMerge, extendTailwindMerge } from 'tailwind-merge';
import { debounce } from 'perfect-debounce';
import { thumbHashToDataURL } from 'thumbhash';
import { Swiper, SwiperSlide } from 'swiper/vue';
import { Navigation, Keyboard, Virtual } from 'swiper/modules';
import { fileTypeFromBlob } from 'file-type';
import dayjsLocale_zhTW from 'dayjs/locale/zh-tw.js';
import 'zod';
import '@adonisjs/hash';
import '@adonisjs/hash/drivers/scrypt';
import 'lru-cache';
import '@unocss/core';
import '@unocss/preset-wind3';
import 'consola';
import 'unhead';
import 'node:http';
import 'node:https';
import 'node:crypto';
import 'stream';
import 'events';
import 'http';
import 'crypto';
import 'buffer';
import 'zlib';
import 'https';
import 'net';
import 'tls';
import 'url';
import 'node:events';
import 'node:buffer';
import 'node:fs';
import 'node:path';
import '@intlify/h3';
import '@intlify/utils/h3';
import '@intlify/utils';
import 'fs';
import 'path';
import 'drizzle-orm/better-sqlite3';
import 'better-sqlite3';
import 'drizzle-orm';
import 'drizzle-orm/sqlite-core';
import '@aws-sdk/client-s3';
import '@aws-sdk/s3-request-presigner';
import '@vingle/bmp-js';
import 'heic-convert';
import 'sharp';
import 'node:fs/promises';
import 'exiftool-vendored';
import 'es-toolkit';
import 'node:url';
import 'unhead/server';
import 'unhead/utils';
import 'vue-bundle-renderer/runtime';
import '@iconify/utils';
import 'ipx';

if (!globalThis.$fetch) {
  globalThis.$fetch = $fetch$1.create({
    baseURL: baseURL()
  });
}
if (!("global" in globalThis)) {
  globalThis.global = globalThis;
}
const appLayoutTransition = false;
const nuxtLinkDefaults = { "componentName": "NuxtLink" };
const asyncDataDefaults = { "deep": false };
const fetchDefaults = {};
const appId = "nuxt-app";
function getNuxtAppCtx(id2 = appId) {
  return getContext(id2, {
    asyncContext: false
  });
}
const NuxtPluginIndicator = "__nuxt_plugin";
function createNuxtApp(options) {
  let hydratingCount = 0;
  const nuxtApp = {
    _id: options.id || appId || "nuxt-app",
    _scope: effectScope(),
    provide: void 0,
    versions: {
      get nuxt() {
        return "4.2.2";
      },
      get vue() {
        return nuxtApp.vueApp.version;
      }
    },
    payload: shallowReactive({
      ...options.ssrContext?.payload || {},
      data: shallowReactive({}),
      state: reactive({}),
      once: /* @__PURE__ */ new Set(),
      _errors: shallowReactive({})
    }),
    static: {
      data: {}
    },
    runWithContext(fn) {
      if (nuxtApp._scope.active && !getCurrentScope()) {
        return nuxtApp._scope.run(() => callWithNuxt(nuxtApp, fn));
      }
      return callWithNuxt(nuxtApp, fn);
    },
    isHydrating: false,
    deferHydration() {
      if (!nuxtApp.isHydrating) {
        return () => {
        };
      }
      hydratingCount++;
      let called = false;
      return () => {
        if (called) {
          return;
        }
        called = true;
        hydratingCount--;
        if (hydratingCount === 0) {
          nuxtApp.isHydrating = false;
          return nuxtApp.callHook("app:suspense:resolve");
        }
      };
    },
    _asyncDataPromises: {},
    _asyncData: shallowReactive({}),
    _payloadRevivers: {},
    ...options
  };
  {
    nuxtApp.payload.serverRendered = true;
  }
  if (nuxtApp.ssrContext) {
    nuxtApp.payload.path = nuxtApp.ssrContext.url;
    nuxtApp.ssrContext.nuxt = nuxtApp;
    nuxtApp.ssrContext.payload = nuxtApp.payload;
    nuxtApp.ssrContext.config = {
      public: nuxtApp.ssrContext.runtimeConfig.public,
      app: nuxtApp.ssrContext.runtimeConfig.app
    };
  }
  nuxtApp.hooks = createHooks();
  nuxtApp.hook = nuxtApp.hooks.hook;
  {
    const contextCaller = async function(hooks, args) {
      for (const hook of hooks) {
        await nuxtApp.runWithContext(() => hook(...args));
      }
    };
    nuxtApp.hooks.callHook = (name2, ...args) => nuxtApp.hooks.callHookWith(contextCaller, name2, ...args);
  }
  nuxtApp.callHook = nuxtApp.hooks.callHook;
  nuxtApp.provide = (name2, value) => {
    const $name = "$" + name2;
    defineGetter(nuxtApp, $name, value);
    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value);
  };
  defineGetter(nuxtApp.vueApp, "$nuxt", nuxtApp);
  defineGetter(nuxtApp.vueApp.config.globalProperties, "$nuxt", nuxtApp);
  const runtimeConfig = options.ssrContext.runtimeConfig;
  nuxtApp.provide("config", runtimeConfig);
  return nuxtApp;
}
function registerPluginHooks(nuxtApp, plugin2) {
  if (plugin2.hooks) {
    nuxtApp.hooks.addHooks(plugin2.hooks);
  }
}
async function applyPlugin(nuxtApp, plugin2) {
  if (typeof plugin2 === "function") {
    const { provide: provide2 } = await nuxtApp.runWithContext(() => plugin2(nuxtApp)) || {};
    if (provide2 && typeof provide2 === "object") {
      for (const key in provide2) {
        nuxtApp.provide(key, provide2[key]);
      }
    }
  }
}
async function applyPlugins(nuxtApp, plugins2) {
  const resolvedPlugins = /* @__PURE__ */ new Set();
  const unresolvedPlugins = [];
  const parallels = [];
  let error = void 0;
  let promiseDepth = 0;
  async function executePlugin(plugin2) {
    const unresolvedPluginsForThisPlugin = plugin2.dependsOn?.filter((name2) => plugins2.some((p) => p._name === name2) && !resolvedPlugins.has(name2)) ?? [];
    if (unresolvedPluginsForThisPlugin.length > 0) {
      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin2]);
    } else {
      const promise = applyPlugin(nuxtApp, plugin2).then(async () => {
        if (plugin2._name) {
          resolvedPlugins.add(plugin2._name);
          await Promise.all(unresolvedPlugins.map(async ([dependsOn, unexecutedPlugin]) => {
            if (dependsOn.has(plugin2._name)) {
              dependsOn.delete(plugin2._name);
              if (dependsOn.size === 0) {
                promiseDepth++;
                await executePlugin(unexecutedPlugin);
              }
            }
          }));
        }
      }).catch((e) => {
        if (!plugin2.parallel && !nuxtApp.payload.error) {
          throw e;
        }
        error ||= e;
      });
      if (plugin2.parallel) {
        parallels.push(promise);
      } else {
        await promise;
      }
    }
  }
  for (const plugin2 of plugins2) {
    if (nuxtApp.ssrContext?.islandContext && plugin2.env?.islands === false) {
      continue;
    }
    registerPluginHooks(nuxtApp, plugin2);
  }
  for (const plugin2 of plugins2) {
    if (nuxtApp.ssrContext?.islandContext && plugin2.env?.islands === false) {
      continue;
    }
    await executePlugin(plugin2);
  }
  await Promise.all(parallels);
  if (promiseDepth) {
    for (let i = 0; i < promiseDepth; i++) {
      await Promise.all(parallels);
    }
  }
  if (error) {
    throw nuxtApp.payload.error || error;
  }
}
// @__NO_SIDE_EFFECTS__
function defineNuxtPlugin(plugin2) {
  if (typeof plugin2 === "function") {
    return plugin2;
  }
  const _name = plugin2._name || plugin2.name;
  delete plugin2.name;
  return Object.assign(plugin2.setup || (() => {
  }), plugin2, { [NuxtPluginIndicator]: true, _name });
}
const definePayloadPlugin = defineNuxtPlugin;
function callWithNuxt(nuxt, setup, args) {
  const fn = () => setup();
  const nuxtAppCtx = getNuxtAppCtx(nuxt._id);
  {
    return nuxt.vueApp.runWithContext(() => nuxtAppCtx.callAsync(nuxt, fn));
  }
}
function tryUseNuxtApp(id2) {
  let nuxtAppInstance;
  if (hasInjectionContext()) {
    nuxtAppInstance = getCurrentInstance$1()?.appContext.app.$nuxt;
  }
  nuxtAppInstance ||= getNuxtAppCtx(id2).tryUse();
  return nuxtAppInstance || null;
}
function useNuxtApp(id2) {
  const nuxtAppInstance = tryUseNuxtApp(id2);
  if (!nuxtAppInstance) {
    {
      throw new Error("[nuxt] instance unavailable");
    }
  }
  return nuxtAppInstance;
}
// @__NO_SIDE_EFFECTS__
function useRuntimeConfig(_event) {
  return useNuxtApp().$config;
}
function defineGetter(obj, key, val) {
  Object.defineProperty(obj, key, { get: () => val });
}
function defineAppConfig(config) {
  return config;
}
const HASH_RE = /#/g;
const AMPERSAND_RE = /&/g;
const SLASH_RE = /\//g;
const EQUAL_RE = /=/g;
const IM_RE = /\?/g;
const PLUS_RE = /\+/g;
const ENC_CARET_RE = /%5e/gi;
const ENC_BACKTICK_RE = /%60/gi;
const ENC_PIPE_RE = /%7c/gi;
const ENC_SPACE_RE = /%20/gi;
const ENC_ENC_SLASH_RE = /%252f/gi;
function encode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|");
}
function encodeQueryValue(input) {
  return encode(typeof input === "string" ? input : JSON.stringify(input)).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CARET_RE, "^").replace(SLASH_RE, "%2F");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodePath(text) {
  return encode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F").replace(ENC_ENC_SLASH_RE, "%2F").replace(AMPERSAND_RE, "%26").replace(PLUS_RE, "%2B");
}
function encodeParam(text) {
  return encodePath(text).replace(SLASH_RE, "%2F");
}
function decode(text = "") {
  try {
    return decodeURIComponent("" + text);
  } catch {
    return "" + text;
  }
}
function decodeQueryKey(text) {
  return decode(text.replace(PLUS_RE, " "));
}
function decodeQueryValue(text) {
  return decode(text.replace(PLUS_RE, " "));
}
function parseQuery(parametersString = "") {
  const object = /* @__PURE__ */ Object.create(null);
  if (parametersString[0] === "?") {
    parametersString = parametersString.slice(1);
  }
  for (const parameter of parametersString.split("&")) {
    const s = parameter.match(/([^=]+)=?(.*)/) || [];
    if (s.length < 2) {
      continue;
    }
    const key = decodeQueryKey(s[1]);
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = decodeQueryValue(s[2] || "");
    if (object[key] === void 0) {
      object[key] = value;
    } else if (Array.isArray(object[key])) {
      object[key].push(value);
    } else {
      object[key] = [object[key], value];
    }
  }
  return object;
}
function encodeQueryItem(key, value) {
  if (typeof value === "number" || typeof value === "boolean") {
    value = String(value);
  }
  if (!value) {
    return encodeQueryKey(key);
  }
  if (Array.isArray(value)) {
    return value.map(
      (_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`
    ).join("&");
  }
  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;
}
function stringifyQuery(query) {
  return Object.keys(query).filter((k2) => query[k2] !== void 0).map((k2) => encodeQueryItem(k2, query[k2])).filter(Boolean).join("&");
}
const PROTOCOL_STRICT_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{1,2})/;
const PROTOCOL_REGEX = /^[\s\w\0+.-]{2,}:([/\\]{2})?/;
const PROTOCOL_RELATIVE_REGEX = /^([/\\]\s*){2,}[^/\\]/;
const PROTOCOL_SCRIPT_RE = /^[\s\0]*(blob|data|javascript|vbscript):$/i;
const TRAILING_SLASH_RE = /\/$|\/\?|\/#/;
const JOIN_LEADING_SLASH_RE = /^\.?\//;
function hasProtocol(inputString, opts = {}) {
  if (typeof opts === "boolean") {
    opts = { acceptRelative: opts };
  }
  if (opts.strict) {
    return PROTOCOL_STRICT_REGEX.test(inputString);
  }
  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);
}
function isScriptProtocol(protocol) {
  return !!protocol && PROTOCOL_SCRIPT_RE.test(protocol);
}
function hasTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/");
  }
  return TRAILING_SLASH_RE.test(input);
}
function withoutTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || "/";
  }
  if (!hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex !== -1) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
  }
  const [s0, ...s] = path.split("?");
  const cleanPath = s0.endsWith("/") ? s0.slice(0, -1) : s0;
  return (cleanPath || "/") + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function withTrailingSlash(input = "", respectQueryAndFragment) {
  if (!respectQueryAndFragment) {
    return input.endsWith("/") ? input : input + "/";
  }
  if (hasTrailingSlash(input, true)) {
    return input || "/";
  }
  let path = input;
  let fragment = "";
  const fragmentIndex = input.indexOf("#");
  if (fragmentIndex !== -1) {
    path = input.slice(0, fragmentIndex);
    fragment = input.slice(fragmentIndex);
    if (!path) {
      return fragment;
    }
  }
  const [s0, ...s] = path.split("?");
  return s0 + "/" + (s.length > 0 ? `?${s.join("?")}` : "") + fragment;
}
function hasLeadingSlash(input = "") {
  return input.startsWith("/");
}
function withLeadingSlash(input = "") {
  return hasLeadingSlash(input) ? input : "/" + input;
}
function withBase(input, base) {
  if (isEmptyURL(base) || hasProtocol(input)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (input.startsWith(_base)) {
    return input;
  }
  return joinURL(_base, input);
}
function withoutBase(input, base) {
  if (isEmptyURL(base)) {
    return input;
  }
  const _base = withoutTrailingSlash(base);
  if (!input.startsWith(_base)) {
    return input;
  }
  const trimmed = input.slice(_base.length);
  return trimmed[0] === "/" ? trimmed : "/" + trimmed;
}
function withQuery(input, query) {
  const parsed = parseURL(input);
  const mergedQuery = { ...parseQuery(parsed.search), ...query };
  parsed.search = stringifyQuery(mergedQuery);
  return stringifyParsedURL(parsed);
}
function isEmptyURL(url) {
  return !url || url === "/";
}
function isNonEmptyURL(url) {
  return url && url !== "/";
}
function joinURL(base, ...input) {
  let url = base || "";
  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {
    if (url) {
      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, "");
      url = withTrailingSlash(url) + _segment;
    } else {
      url = segment;
    }
  }
  return url;
}
const protocolRelative = /* @__PURE__ */ Symbol.for("ufo:protocolRelative");
function parseURL(input = "", defaultProto) {
  const _specialProtoMatch = input.match(
    /^[\s\0]*(blob:|data:|javascript:|vbscript:)(.*)/i
  );
  if (_specialProtoMatch) {
    const [, _proto, _pathname = ""] = _specialProtoMatch;
    return {
      protocol: _proto.toLowerCase(),
      pathname: _pathname,
      href: _proto + _pathname,
      auth: "",
      host: "",
      search: "",
      hash: ""
    };
  }
  if (!hasProtocol(input, { acceptRelative: true })) {
    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);
  }
  const [, protocol = "", auth, hostAndPath = ""] = input.replace(/\\/g, "/").match(/^[\s\0]*([\w+.-]{2,}:)?\/\/([^/@]+@)?(.*)/) || [];
  let [, host = "", path = ""] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];
  if (protocol === "file:") {
    path = path.replace(/\/(?=[A-Za-z]:)/, "");
  }
  const { pathname, search, hash: hash2 } = parsePath(path);
  return {
    protocol: protocol.toLowerCase(),
    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : "",
    host,
    pathname,
    search,
    hash: hash2,
    [protocolRelative]: !protocol
  };
}
function parsePath(input = "") {
  const [pathname = "", search = "", hash2 = ""] = (input.match(/([^#?]*)(\?[^#]*)?(#.*)?/) || []).splice(1);
  return {
    pathname,
    search,
    hash: hash2
  };
}
function stringifyParsedURL(parsed) {
  const pathname = parsed.pathname || "";
  const search = parsed.search ? (parsed.search.startsWith("?") ? "" : "?") + parsed.search : "";
  const hash2 = parsed.hash || "";
  const auth = parsed.auth ? parsed.auth + "@" : "";
  const host = parsed.host || "";
  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || "") + "//" : "";
  return proto + auth + host + pathname + search + hash2;
}
const LayoutMetaSymbol = /* @__PURE__ */ Symbol("layout-meta");
const PageRouteSymbol = /* @__PURE__ */ Symbol("route");
globalThis._importMeta_.url.replace(/\/app\/.*$/, "/");
const useRouter = () => {
  return useNuxtApp()?.$router;
};
const useRoute = () => {
  if (hasInjectionContext()) {
    return inject(PageRouteSymbol, useNuxtApp()._route);
  }
  return useNuxtApp()._route;
};
// @__NO_SIDE_EFFECTS__
function defineNuxtRouteMiddleware(middleware) {
  return middleware;
}
const isProcessingMiddleware = () => {
  try {
    if (useNuxtApp()._processingMiddleware) {
      return true;
    }
  } catch {
    return false;
  }
  return false;
};
const URL_QUOTE_RE = /"/g;
const navigateTo = (to, options) => {
  to ||= "/";
  const toPath = typeof to === "string" ? to : "path" in to ? resolveRouteObject(to) : useRouter().resolve(to).href;
  const isExternalHost = hasProtocol(toPath, { acceptRelative: true });
  const isExternal = options?.external || isExternalHost;
  if (isExternal) {
    if (!options?.external) {
      throw new Error("Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.");
    }
    const { protocol } = new URL(toPath, "http://localhost");
    if (protocol && isScriptProtocol(protocol)) {
      throw new Error(`Cannot navigate to a URL with '${protocol}' protocol.`);
    }
  }
  const inMiddleware = isProcessingMiddleware();
  const router = useRouter();
  const nuxtApp = useNuxtApp();
  {
    if (nuxtApp.ssrContext) {
      const fullPath = typeof to === "string" || isExternal ? toPath : router.resolve(to).fullPath || "/";
      const location2 = isExternal ? toPath : joinURL((/* @__PURE__ */ useRuntimeConfig()).app.baseURL, fullPath);
      const redirect = async function(response) {
        await nuxtApp.callHook("app:redirected");
        const encodedLoc = location2.replace(URL_QUOTE_RE, "%22");
        const encodedHeader = encodeURL(location2, isExternalHost);
        nuxtApp.ssrContext._renderResponse = {
          statusCode: sanitizeStatusCode(options?.redirectCode || 302, 302),
          body: `<!DOCTYPE html><html><head><meta http-equiv="refresh" content="0; url=${encodedLoc}"></head></html>`,
          headers: { location: encodedHeader }
        };
        return response;
      };
      if (!isExternal && inMiddleware) {
        router.afterEach((final) => final.fullPath === fullPath ? redirect(false) : void 0);
        return to;
      }
      return redirect(!inMiddleware ? void 0 : (
        /* abort route navigation */
        false
      ));
    }
  }
  if (isExternal) {
    nuxtApp._scope.stop();
    if (options?.replace) {
      (void 0).replace(toPath);
    } else {
      (void 0).href = toPath;
    }
    if (inMiddleware) {
      if (!nuxtApp.isHydrating) {
        return false;
      }
      return new Promise(() => {
      });
    }
    return Promise.resolve();
  }
  return options?.replace ? router.replace(to) : router.push(to);
};
function resolveRouteObject(to) {
  return withQuery(to.path || "", to.query || {}) + (to.hash || "");
}
function encodeURL(location2, isExternalHost = false) {
  const url = new URL(location2, "http://localhost");
  if (!isExternalHost) {
    return url.pathname + url.search + url.hash;
  }
  if (location2.startsWith("//")) {
    return url.toString().replace(url.protocol, "");
  }
  return url.toString();
}
const NUXT_ERROR_SIGNATURE = "__nuxt_error";
const useError = /* @__NO_SIDE_EFFECTS__ */ () => toRef$2(useNuxtApp().payload, "error");
const showError = (error) => {
  const nuxtError = createError(error);
  try {
    const error2 = /* @__PURE__ */ useError();
    if (false) ;
    error2.value ||= nuxtError;
  } catch {
    throw nuxtError;
  }
  return nuxtError;
};
const isNuxtError = (error) => !!error && typeof error === "object" && NUXT_ERROR_SIGNATURE in error;
const createError = (error) => {
  const nuxtError = createError$1(error);
  Object.defineProperty(nuxtError, NUXT_ERROR_SIGNATURE, {
    value: true,
    configurable: false,
    writable: false
  });
  return nuxtError;
};
function injectHead(nuxtApp) {
  const nuxt = nuxtApp || useNuxtApp();
  return nuxt.ssrContext?.head || nuxt.runWithContext(() => {
    if (hasInjectionContext()) {
      const head = inject(headSymbol);
      if (!head) {
        throw new Error("[nuxt] [unhead] Missing Unhead instance.");
      }
      return head;
    }
  });
}
function useHead(input, options = {}) {
  const head = options.head || injectHead(options.nuxt);
  return useHead$1(input, { head, ...options });
}
async function getRouteRules(arg) {
  const path = typeof arg === "string" ? arg : arg.path;
  {
    useNuxtApp().ssrContext._preloadManifest = true;
    const _routeRulesMatcher = toRouteMatcher(
      createRouter$1({ routes: (/* @__PURE__ */ useRuntimeConfig()).nitro.routeRules })
    );
    return defu({}, ..._routeRulesMatcher.matchAll(path).reverse());
  }
}
function definePayloadReducer(name2, reduce) {
  {
    useNuxtApp().ssrContext._payloadReducers[name2] = reduce;
  }
}
const payloadPlugin = definePayloadPlugin(() => {
  definePayloadReducer(
    "skipHydrate",
    // We need to return something truthy to be treated as a match
    (data) => !shouldHydrate(data) && 1
  );
});
function defineHeadPlugin(plugin2) {
  return plugin2;
}
const SepSub = "%separator";
function sub(p, token, isJson = false) {
  let val;
  if (token === "s" || token === "pageTitle") {
    val = p.pageTitle;
  } else if (token.includes(".")) {
    const dotIndex = token.indexOf(".");
    val = p[token.substring(0, dotIndex)]?.[token.substring(dotIndex + 1)];
  } else {
    val = p[token];
  }
  if (val !== void 0) {
    return isJson ? (val || "").replace(/\\/g, "\\\\").replace(/</g, "\\u003C").replace(/"/g, '\\"') : val || "";
  }
  return void 0;
}
function processTemplateParams(s, p, sep, isJson = false) {
  if (typeof s !== "string" || !s.includes("%"))
    return s;
  let decoded = s;
  try {
    decoded = decodeURI(s);
  } catch {
  }
  const tokens = decoded.match(/%\w+(?:\.\w+)?/g);
  if (!tokens) {
    return s;
  }
  const hasSepSub = s.includes(SepSub);
  s = s.replace(/%\w+(?:\.\w+)?/g, (token) => {
    if (token === SepSub || !tokens.includes(token)) {
      return token;
    }
    const re = sub(p, token.slice(1), isJson);
    return re !== void 0 ? re : token;
  }).trim();
  if (hasSepSub) {
    s = s.split(SepSub).map((part) => part.trim()).filter((part) => part !== "").join(sep ? ` ${sep} ` : " ");
  }
  return s;
}
const SupportedAttrs = {
  meta: "content",
  link: "href",
  htmlAttrs: "lang"
};
const contentAttrs = ["innerHTML", "textContent"];
const TemplateParamsPlugin = /* @__PURE__ */ defineHeadPlugin((head) => {
  return {
    key: "template-params",
    hooks: {
      "entries:normalize": (ctx) => {
        const params = ctx.tags.filter((t) => t.tag === "templateParams" && t.mode === "server")?.[0]?.props || {};
        if (Object.keys(params).length) {
          head._ssrPayload = {
            templateParams: {
              ...head._ssrPayload?.templateParams || {},
              ...params
            }
          };
        }
      },
      "tags:resolve": ({ tagMap, tags }) => {
        const params = tagMap.get("templateParams")?.props || {};
        const sep = params.separator || "|";
        delete params.separator;
        params.pageTitle = processTemplateParams(
          // find templateParams
          params.pageTitle || head._title || "",
          params,
          sep
        );
        for (const tag of tags) {
          if (tag.processTemplateParams === false) {
            continue;
          }
          const v = SupportedAttrs[tag.tag];
          if (v && typeof tag.props[v] === "string") {
            tag.props[v] = processTemplateParams(tag.props[v], params, sep);
          } else if (tag.processTemplateParams || tag.tag === "titleTemplate" || tag.tag === "title") {
            for (const p of contentAttrs) {
              if (typeof tag[p] === "string")
                tag[p] = processTemplateParams(tag[p], params, sep, tag.tag === "script" && tag.props.type.endsWith("json"));
            }
          }
        }
        head._templateParams = params;
        head._separator = sep;
      },
      "tags:afterResolve": ({ tagMap }) => {
        const title = tagMap.get("title");
        if (title?.textContent && title.processTemplateParams !== false) {
          title.textContent = processTemplateParams(title.textContent, head._templateParams, head._separator);
        }
      }
    }
  };
});
const unhead_sebKWs0qLgaCoVBpeFlwbClqUS4Q6vQHhZO_zjRanO0 = /* @__PURE__ */ defineNuxtPlugin({
  name: "nuxt:head",
  enforce: "pre",
  setup(nuxtApp) {
    const head = nuxtApp.ssrContext.head;
    nuxtApp.vueApp.use(head);
  }
});
function toArray$4(value) {
  return Array.isArray(value) ? value : [value];
}
const __nuxt_page_meta$e = {
  layout: "masonry",
  // 固定 key 防止路径参数变化时创建新的实例
  key: "photo-viewer-route"
};
const __nuxt_page_meta$d = {
  layout: "dashboard"
};
const __nuxt_page_meta$c = {
  layout: "onboarding"
};
const __nuxt_page_meta$b = {
  layout: "dashboard"
};
const __nuxt_page_meta$a = {
  layout: "dashboard"
};
const __nuxt_page_meta$9 = {
  layout: "onboarding"
};
const __nuxt_page_meta$8 = {
  layout: "dashboard"
};
const __nuxt_page_meta$7 = {
  layout: "dashboard"
};
const __nuxt_page_meta$6 = {
  layout: "onboarding"
};
const __nuxt_page_meta$5 = {
  layout: "onboarding"
};
const __nuxt_page_meta$4 = {
  layout: "onboarding"
};
const __nuxt_page_meta$3 = {
  layout: "onboarding"
};
const __nuxt_page_meta$2 = {
  layout: "dashboard"
};
const __nuxt_page_meta$1 = {
  layout: "dashboard"
};
const __nuxt_page_meta = {
  layout: "dashboard"
};
const _routes = [
  {
    name: "globe",
    path: "/globe",
    component: () => import('./globe-CCwHdHGC.mjs')
  },
  {
    name: "signin",
    path: "/signin",
    component: () => import('./signin-vSSjsEuJ.mjs')
  },
  {
    name: "slug",
    path: "/:slug(.*)*",
    meta: __nuxt_page_meta$e || {},
    component: () => import('./_...slug_-CyUn50zM.mjs')
  },
  {
    name: "albums",
    path: "/albums",
    component: () => import('./index-Dslw84iR.mjs')
  },
  {
    name: "dashboard-logs",
    path: "/dashboard/logs",
    meta: __nuxt_page_meta$d || {},
    component: () => import('./logs-BLyGjb7I.mjs')
  },
  {
    name: "onboarding-map",
    path: "/onboarding/map",
    meta: __nuxt_page_meta$c || {},
    component: () => import('./map-B6IVQ55M.mjs')
  },
  {
    name: "dashboard",
    path: "/dashboard",
    meta: __nuxt_page_meta$b || {},
    component: () => import('./index-CglvhmiX.mjs')
  },
  {
    name: "dashboard-queue",
    path: "/dashboard/queue",
    meta: __nuxt_page_meta$a || {},
    component: () => import('./queue-W1f7HAAw.mjs')
  },
  {
    name: "onboarding-site",
    path: "/onboarding/site",
    meta: __nuxt_page_meta$9 || {},
    component: () => import('./site-y7iaj5FI.mjs')
  },
  {
    name: "albums-albumId",
    path: "/albums/:albumId()",
    component: () => import('./_albumId_-DkUJQY97.mjs')
  },
  {
    name: "dashboard-albums",
    path: "/dashboard/albums",
    meta: __nuxt_page_meta$8 || {},
    component: () => import('./albums-CII0wWec.mjs')
  },
  {
    name: "dashboard-photos",
    path: "/dashboard/photos",
    meta: __nuxt_page_meta$7 || {},
    component: () => import('./photos-BoWWtr_a.mjs')
  },
  {
    name: "onboarding-admin",
    path: "/onboarding/admin",
    meta: __nuxt_page_meta$6 || {},
    component: () => import('./admin-CR9W4wCE.mjs')
  },
  {
    name: "onboarding",
    path: "/onboarding",
    meta: __nuxt_page_meta$5 || {},
    component: () => import('./index-kuChOV7m.mjs')
  },
  {
    name: "onboarding-storage",
    path: "/onboarding/storage",
    meta: __nuxt_page_meta$4 || {},
    component: () => import('./storage-fPuLRGDB.mjs')
  },
  {
    name: "onboarding-complete",
    path: "/onboarding/complete",
    meta: __nuxt_page_meta$3 || {},
    component: () => import('./complete-7tZYwNeF.mjs')
  },
  {
    name: "dashboard-settings-map",
    path: "/dashboard/settings/map",
    meta: __nuxt_page_meta$2 || {},
    component: () => import('./map-DUu_8GCy.mjs')
  },
  {
    name: "dashboard-settings-general",
    path: "/dashboard/settings/general",
    meta: __nuxt_page_meta$1 || {},
    component: () => import('./general-BaMAO6W-.mjs')
  },
  {
    name: "dashboard-settings-storage",
    path: "/dashboard/settings/storage",
    meta: __nuxt_page_meta || {},
    component: () => import('./storage-YMWkNchD.mjs')
  }
];
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var shared_cjs_prod = {};
var hasRequiredShared_cjs_prod;
function requireShared_cjs_prod() {
  if (hasRequiredShared_cjs_prod) return shared_cjs_prod;
  hasRequiredShared_cjs_prod = 1;
  Object.defineProperty(shared_cjs_prod, "__esModule", { value: true });
  // @__NO_SIDE_EFFECTS__
  function makeMap(str) {
    const map = /* @__PURE__ */ Object.create(null);
    for (const key of str.split(",")) map[key] = 1;
    return (val) => val in map;
  }
  const EMPTY_OBJ = {};
  const EMPTY_ARR = [];
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const isModelListener = (key) => key.startsWith("onUpdate:");
  const extend = Object.assign;
  const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  const hasOwnProperty2 = Object.prototype.hasOwnProperty;
  const hasOwn2 = (val, key) => hasOwnProperty2.call(val, key);
  const isArray2 = Array.isArray;
  const isMap = (val) => toTypeString2(val) === "[object Map]";
  const isSet = (val) => toTypeString2(val) === "[object Set]";
  const isDate2 = (val) => toTypeString2(val) === "[object Date]";
  const isRegExp2 = (val) => toTypeString2(val) === "[object RegExp]";
  const isFunction2 = (val) => typeof val === "function";
  const isString2 = (val) => typeof val === "string";
  const isSymbol = (val) => typeof val === "symbol";
  const isObject2 = (val) => val !== null && typeof val === "object";
  const isPromise2 = (val) => {
    return (isObject2(val) || isFunction2(val)) && isFunction2(val.then) && isFunction2(val.catch);
  };
  const objectToString2 = Object.prototype.toString;
  const toTypeString2 = (value) => objectToString2.call(value);
  const toRawType = (value) => {
    return toTypeString2(value).slice(8, -1);
  };
  const isPlainObject2 = (val) => toTypeString2(val) === "[object Object]";
  const isIntegerKey = (key) => isString2(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  const isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const isBuiltInDirective = /* @__PURE__ */ makeMap(
    "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
  );
  const cacheStringFunction2 = (fn) => {
    const cache2 = /* @__PURE__ */ Object.create(null);
    return ((str) => {
      const hit = cache2[str];
      return hit || (cache2[str] = fn(str));
    });
  };
  const camelizeRE2 = /-\w/g;
  const camelize2 = cacheStringFunction2(
    (str) => {
      return str.replace(camelizeRE2, (c2) => c2.slice(1).toUpperCase());
    }
  );
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction2(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );
  const capitalize2 = cacheStringFunction2((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  const toHandlerKey2 = cacheStringFunction2(
    (str) => {
      const s = str ? `on${capitalize2(str)}` : ``;
      return s;
    }
  );
  const hasChanged2 = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, ...arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](...arg);
    }
  };
  const def = (obj, key, value, writable = false) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      writable,
      value
    });
  };
  const looseToNumber2 = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  const toNumber = (val) => {
    const n = isString2(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
  };
  let _globalThis2;
  const getGlobalThis2 = () => {
    return _globalThis2 || (_globalThis2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : {});
  };
  const identRE = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
  function genPropsAccessExp(name2) {
    return identRE.test(name2) ? `__props.${name2}` : `__props[${JSON.stringify(name2)}]`;
  }
  function genCacheKey(source, options) {
    return source + JSON.stringify(
      options,
      (_2, val) => typeof val === "function" ? val.toString() : val
    );
  }
  const PatchFlags = {
    "TEXT": 1,
    "1": "TEXT",
    "CLASS": 2,
    "2": "CLASS",
    "STYLE": 4,
    "4": "STYLE",
    "PROPS": 8,
    "8": "PROPS",
    "FULL_PROPS": 16,
    "16": "FULL_PROPS",
    "NEED_HYDRATION": 32,
    "32": "NEED_HYDRATION",
    "STABLE_FRAGMENT": 64,
    "64": "STABLE_FRAGMENT",
    "KEYED_FRAGMENT": 128,
    "128": "KEYED_FRAGMENT",
    "UNKEYED_FRAGMENT": 256,
    "256": "UNKEYED_FRAGMENT",
    "NEED_PATCH": 512,
    "512": "NEED_PATCH",
    "DYNAMIC_SLOTS": 1024,
    "1024": "DYNAMIC_SLOTS",
    "DEV_ROOT_FRAGMENT": 2048,
    "2048": "DEV_ROOT_FRAGMENT",
    "CACHED": -1,
    "-1": "CACHED",
    "BAIL": -2,
    "-2": "BAIL"
  };
  const PatchFlagNames = {
    [1]: `TEXT`,
    [2]: `CLASS`,
    [4]: `STYLE`,
    [8]: `PROPS`,
    [16]: `FULL_PROPS`,
    [32]: `NEED_HYDRATION`,
    [64]: `STABLE_FRAGMENT`,
    [128]: `KEYED_FRAGMENT`,
    [256]: `UNKEYED_FRAGMENT`,
    [512]: `NEED_PATCH`,
    [1024]: `DYNAMIC_SLOTS`,
    [2048]: `DEV_ROOT_FRAGMENT`,
    [-1]: `CACHED`,
    [-2]: `BAIL`
  };
  const ShapeFlags = {
    "ELEMENT": 1,
    "1": "ELEMENT",
    "FUNCTIONAL_COMPONENT": 2,
    "2": "FUNCTIONAL_COMPONENT",
    "STATEFUL_COMPONENT": 4,
    "4": "STATEFUL_COMPONENT",
    "TEXT_CHILDREN": 8,
    "8": "TEXT_CHILDREN",
    "ARRAY_CHILDREN": 16,
    "16": "ARRAY_CHILDREN",
    "SLOTS_CHILDREN": 32,
    "32": "SLOTS_CHILDREN",
    "TELEPORT": 64,
    "64": "TELEPORT",
    "SUSPENSE": 128,
    "128": "SUSPENSE",
    "COMPONENT_SHOULD_KEEP_ALIVE": 256,
    "256": "COMPONENT_SHOULD_KEEP_ALIVE",
    "COMPONENT_KEPT_ALIVE": 512,
    "512": "COMPONENT_KEPT_ALIVE",
    "COMPONENT": 6,
    "6": "COMPONENT"
  };
  const SlotFlags = {
    "STABLE": 1,
    "1": "STABLE",
    "DYNAMIC": 2,
    "2": "DYNAMIC",
    "FORWARDED": 3,
    "3": "FORWARDED"
  };
  const slotFlagsText = {
    [1]: "STABLE",
    [2]: "DYNAMIC",
    [3]: "FORWARDED"
  };
  const GLOBALS_ALLOWED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol";
  const isGloballyAllowed = /* @__PURE__ */ makeMap(GLOBALS_ALLOWED);
  const isGloballyWhitelisted = isGloballyAllowed;
  const range = 2;
  function generateCodeFrame2(source, start = 0, end = source.length) {
    start = Math.max(0, Math.min(start, source.length));
    end = Math.max(0, Math.min(end, source.length));
    if (start > end) return "";
    let lines = source.split(/(\r?\n)/);
    const newlineSequences = lines.filter((_2, idx) => idx % 2 === 1);
    lines = lines.filter((_2, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
      count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
      if (count >= start) {
        for (let j2 = i - range; j2 <= i + range || end > count; j2++) {
          if (j2 < 0 || j2 >= lines.length) continue;
          const line = j2 + 1;
          res.push(
            `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j2]}`
          );
          const lineLength = lines[j2].length;
          const newLineSeqLength = newlineSequences[j2] && newlineSequences[j2].length || 0;
          if (j2 === i) {
            const pad = start - (count - (lineLength + newLineSeqLength));
            const length = Math.max(
              1,
              end > count ? lineLength - pad : end - start
            );
            res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
          } else if (j2 > i) {
            if (end > count) {
              const length = Math.max(Math.min(end - count, lineLength), 1);
              res.push(`   |  ` + "^".repeat(length));
            }
            count += lineLength + newLineSeqLength;
          }
        }
        break;
      }
    }
    return res.join("\n");
  }
  function normalizeStyle2(value) {
    if (isArray2(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString2(item) ? parseStringStyle(item) : normalizeStyle2(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString2(value) || isObject2(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function stringifyStyle(styles) {
    if (!styles) return "";
    if (isString2(styles)) return styles;
    let ret = "";
    for (const key in styles) {
      const value = styles[key];
      if (isString2(value) || typeof value === "number") {
        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);
        ret += `${normalizedKey}:${value};`;
      }
    }
    return ret;
  }
  function normalizeClass2(value) {
    let res = "";
    if (isString2(value)) {
      res = value;
    } else if (isArray2(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass2(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject2(value)) {
      for (const name2 in value) {
        if (value[name2]) {
          res += name2 + " ";
        }
      }
    }
    return res.trim();
  }
  function normalizeProps2(props) {
    if (!props) return null;
    let { class: klass, style: style2 } = props;
    if (klass && !isString2(klass)) {
      props.class = normalizeClass2(klass);
    }
    if (style2) {
      props.style = normalizeStyle2(style2);
    }
    return props;
  }
  const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
  const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
  const MATH_TAGS = "annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics";
  const VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
  const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
  const isSVGTag2 = /* @__PURE__ */ makeMap(SVG_TAGS);
  const isMathMLTag = /* @__PURE__ */ makeMap(MATH_TAGS);
  const isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  const isBooleanAttr = /* @__PURE__ */ makeMap(
    specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`
  );
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }
  const unsafeAttrCharRE = /[>/="'\u0009\u000a\u000c\u0020]/;
  const attrValidationCache = {};
  function isSSRSafeAttrName(name2) {
    if (attrValidationCache.hasOwnProperty(name2)) {
      return attrValidationCache[name2];
    }
    const isUnsafe = unsafeAttrCharRE.test(name2);
    if (isUnsafe) {
      console.error(`unsafe attribute name: ${name2}`);
    }
    return attrValidationCache[name2] = !isUnsafe;
  }
  const propsToAttrMap = {
    acceptCharset: "accept-charset",
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv"
  };
  const isKnownHtmlAttr = /* @__PURE__ */ makeMap(
    `accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap`
  );
  const isKnownSvgAttr = /* @__PURE__ */ makeMap(
    `xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`
  );
  const isKnownMathMLAttr = /* @__PURE__ */ makeMap(
    `accent,accentunder,actiontype,align,alignmentscope,altimg,altimg-height,altimg-valign,altimg-width,alttext,bevelled,close,columnsalign,columnlines,columnspan,denomalign,depth,dir,display,displaystyle,encoding,equalcolumns,equalrows,fence,fontstyle,fontweight,form,frame,framespacing,groupalign,height,href,id,indentalign,indentalignfirst,indentalignlast,indentshift,indentshiftfirst,indentshiftlast,indextype,justify,largetop,largeop,lquote,lspace,mathbackground,mathcolor,mathsize,mathvariant,maxsize,minlabelspacing,mode,other,overflow,position,rowalign,rowlines,rowspan,rquote,rspace,scriptlevel,scriptminsize,scriptsizemultiplier,selection,separator,separators,shift,side,src,stackalign,stretchy,subscriptshift,superscriptshift,symmetric,voffset,width,widths,xlink:href,xlink:show,xlink:type,xmlns`
  );
  function isRenderableAttrValue(value) {
    if (value == null) {
      return false;
    }
    const type = typeof value;
    return type === "string" || type === "number" || type === "boolean";
  }
  const escapeRE = /["'&<>]/;
  function escapeHtml2(string) {
    const str = "" + string;
    const match = escapeRE.exec(str);
    if (!match) {
      return str;
    }
    let html = "";
    let escaped;
    let index2;
    let lastIndex = 0;
    for (index2 = match.index; index2 < str.length; index2++) {
      switch (str.charCodeAt(index2)) {
        case 34:
          escaped = "&quot;";
          break;
        case 38:
          escaped = "&amp;";
          break;
        case 39:
          escaped = "&#39;";
          break;
        case 60:
          escaped = "&lt;";
          break;
        case 62:
          escaped = "&gt;";
          break;
        default:
          continue;
      }
      if (lastIndex !== index2) {
        html += str.slice(lastIndex, index2);
      }
      lastIndex = index2 + 1;
      html += escaped;
    }
    return lastIndex !== index2 ? html + str.slice(lastIndex, index2) : html;
  }
  const commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;
  function escapeHtmlComment(src) {
    return src.replace(commentStripRE, "");
  }
  const cssVarNameEscapeSymbolsRE = /[ !"#$%&'()*+,./:;<=>?@[\\\]^`{|}~]/g;
  function getEscapedCssVarName(key, doubleEscape) {
    return key.replace(
      cssVarNameEscapeSymbolsRE,
      (s) => doubleEscape ? s === '"' ? '\\\\\\"' : `\\\\${s}` : `\\${s}`
    );
  }
  function looseCompareArrays(a, b) {
    if (a.length !== b.length) return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
      equal = looseEqual(a[i], b[i]);
    }
    return equal;
  }
  function looseEqual(a, b) {
    if (a === b) return true;
    let aValidType = isDate2(a);
    let bValidType = isDate2(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isSymbol(a);
    bValidType = isSymbol(b);
    if (aValidType || bValidType) {
      return a === b;
    }
    aValidType = isArray2(a);
    bValidType = isArray2(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject2(a);
    bValidType = isObject2(b);
    if (aValidType || bValidType) {
      if (!aValidType || !bValidType) {
        return false;
      }
      const aKeysCount = Object.keys(a).length;
      const bKeysCount = Object.keys(b).length;
      if (aKeysCount !== bKeysCount) {
        return false;
      }
      for (const key in a) {
        const aHasKey = a.hasOwnProperty(key);
        const bHasKey = b.hasOwnProperty(key);
        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
          return false;
        }
      }
    }
    return String(a) === String(b);
  }
  function looseIndexOf(arr, val) {
    return arr.findIndex((item) => looseEqual(item, val));
  }
  const isRef2 = (val) => {
    return !!(val && val["__v_isRef"] === true);
  };
  const toDisplayString2 = (val) => {
    return isString2(val) ? val : val == null ? "" : isArray2(val) || isObject2(val) && (val.toString === objectToString2 || !isFunction2(val.toString)) ? isRef2(val) ? toDisplayString2(val.value) : JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (isRef2(val)) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key, val2], i) => {
            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
      };
    } else if (isSymbol(val)) {
      return stringifySymbol(val);
    } else if (isObject2(val) && !isArray2(val) && !isPlainObject2(val)) {
      return String(val);
    }
    return val;
  };
  const stringifySymbol = (v, i = "") => {
    var _a;
    return (
      // Symbol.description in es2019+ so we need to cast here to pass
      // the lib: es2016 check
      isSymbol(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v
    );
  };
  function normalizeCssVarValue(value) {
    if (value == null) {
      return "initial";
    }
    if (typeof value === "string") {
      return value === "" ? " " : value;
    }
    return String(value);
  }
  shared_cjs_prod.EMPTY_ARR = EMPTY_ARR;
  shared_cjs_prod.EMPTY_OBJ = EMPTY_OBJ;
  shared_cjs_prod.NO = NO;
  shared_cjs_prod.NOOP = NOOP;
  shared_cjs_prod.PatchFlagNames = PatchFlagNames;
  shared_cjs_prod.PatchFlags = PatchFlags;
  shared_cjs_prod.ShapeFlags = ShapeFlags;
  shared_cjs_prod.SlotFlags = SlotFlags;
  shared_cjs_prod.camelize = camelize2;
  shared_cjs_prod.capitalize = capitalize2;
  shared_cjs_prod.cssVarNameEscapeSymbolsRE = cssVarNameEscapeSymbolsRE;
  shared_cjs_prod.def = def;
  shared_cjs_prod.escapeHtml = escapeHtml2;
  shared_cjs_prod.escapeHtmlComment = escapeHtmlComment;
  shared_cjs_prod.extend = extend;
  shared_cjs_prod.genCacheKey = genCacheKey;
  shared_cjs_prod.genPropsAccessExp = genPropsAccessExp;
  shared_cjs_prod.generateCodeFrame = generateCodeFrame2;
  shared_cjs_prod.getEscapedCssVarName = getEscapedCssVarName;
  shared_cjs_prod.getGlobalThis = getGlobalThis2;
  shared_cjs_prod.hasChanged = hasChanged2;
  shared_cjs_prod.hasOwn = hasOwn2;
  shared_cjs_prod.hyphenate = hyphenate;
  shared_cjs_prod.includeBooleanAttr = includeBooleanAttr;
  shared_cjs_prod.invokeArrayFns = invokeArrayFns;
  shared_cjs_prod.isArray = isArray2;
  shared_cjs_prod.isBooleanAttr = isBooleanAttr;
  shared_cjs_prod.isBuiltInDirective = isBuiltInDirective;
  shared_cjs_prod.isDate = isDate2;
  shared_cjs_prod.isFunction = isFunction2;
  shared_cjs_prod.isGloballyAllowed = isGloballyAllowed;
  shared_cjs_prod.isGloballyWhitelisted = isGloballyWhitelisted;
  shared_cjs_prod.isHTMLTag = isHTMLTag;
  shared_cjs_prod.isIntegerKey = isIntegerKey;
  shared_cjs_prod.isKnownHtmlAttr = isKnownHtmlAttr;
  shared_cjs_prod.isKnownMathMLAttr = isKnownMathMLAttr;
  shared_cjs_prod.isKnownSvgAttr = isKnownSvgAttr;
  shared_cjs_prod.isMap = isMap;
  shared_cjs_prod.isMathMLTag = isMathMLTag;
  shared_cjs_prod.isModelListener = isModelListener;
  shared_cjs_prod.isObject = isObject2;
  shared_cjs_prod.isOn = isOn;
  shared_cjs_prod.isPlainObject = isPlainObject2;
  shared_cjs_prod.isPromise = isPromise2;
  shared_cjs_prod.isRegExp = isRegExp2;
  shared_cjs_prod.isRenderableAttrValue = isRenderableAttrValue;
  shared_cjs_prod.isReservedProp = isReservedProp;
  shared_cjs_prod.isSSRSafeAttrName = isSSRSafeAttrName;
  shared_cjs_prod.isSVGTag = isSVGTag2;
  shared_cjs_prod.isSet = isSet;
  shared_cjs_prod.isSpecialBooleanAttr = isSpecialBooleanAttr;
  shared_cjs_prod.isString = isString2;
  shared_cjs_prod.isSymbol = isSymbol;
  shared_cjs_prod.isVoidTag = isVoidTag;
  shared_cjs_prod.looseEqual = looseEqual;
  shared_cjs_prod.looseIndexOf = looseIndexOf;
  shared_cjs_prod.looseToNumber = looseToNumber2;
  shared_cjs_prod.makeMap = makeMap;
  shared_cjs_prod.normalizeClass = normalizeClass2;
  shared_cjs_prod.normalizeCssVarValue = normalizeCssVarValue;
  shared_cjs_prod.normalizeProps = normalizeProps2;
  shared_cjs_prod.normalizeStyle = normalizeStyle2;
  shared_cjs_prod.objectToString = objectToString2;
  shared_cjs_prod.parseStringStyle = parseStringStyle;
  shared_cjs_prod.propsToAttrMap = propsToAttrMap;
  shared_cjs_prod.remove = remove;
  shared_cjs_prod.slotFlagsText = slotFlagsText;
  shared_cjs_prod.stringifyStyle = stringifyStyle;
  shared_cjs_prod.toDisplayString = toDisplayString2;
  shared_cjs_prod.toHandlerKey = toHandlerKey2;
  shared_cjs_prod.toNumber = toNumber;
  shared_cjs_prod.toRawType = toRawType;
  shared_cjs_prod.toTypeString = toTypeString2;
  return shared_cjs_prod;
}
var shared_cjs_prodExports = /* @__PURE__ */ requireShared_cjs_prod();
const _wrapInTransition = (props, children) => {
  return { default: () => children.default?.() };
};
const ROUTE_KEY_PARENTHESES_RE = /(:\w+)\([^)]+\)/g;
const ROUTE_KEY_SYMBOLS_RE = /(:\w+)[?+*]/g;
const ROUTE_KEY_NORMAL_RE = /:\w+/g;
function generateRouteKey(route) {
  const source = route?.meta.key ?? route.path.replace(ROUTE_KEY_PARENTHESES_RE, "$1").replace(ROUTE_KEY_SYMBOLS_RE, "$1").replace(ROUTE_KEY_NORMAL_RE, (r) => route.params[r.slice(1)]?.toString() || "");
  return typeof source === "function" ? source(route) : source;
}
function isChangingPage(to, from) {
  if (to === from || from === START_LOCATION) {
    return false;
  }
  if (generateRouteKey(to) !== generateRouteKey(from)) {
    return true;
  }
  const areComponentsSame = to.matched.every(
    (comp, index2) => comp.components && comp.components.default === from.matched[index2]?.components?.default
  );
  if (areComponentsSame) {
    return false;
  }
  return true;
}
const routerOptions0 = {
  scrollBehavior(to, from, savedPosition) {
    const nuxtApp = useNuxtApp();
    const hashScrollBehaviour = useRouter().options?.scrollBehaviorType ?? "auto";
    if (to.path.replace(/\/$/, "") === from.path.replace(/\/$/, "")) {
      if (from.hash && !to.hash) {
        return { left: 0, top: 0 };
      }
      if (to.hash) {
        return { el: to.hash, top: _getHashElementScrollMarginTop(to.hash), behavior: hashScrollBehaviour };
      }
      return false;
    }
    const routeAllowsScrollToTop = typeof to.meta.scrollToTop === "function" ? to.meta.scrollToTop(to, from) : to.meta.scrollToTop;
    if (routeAllowsScrollToTop === false) {
      return false;
    }
    const hookToWait = nuxtApp._runningTransition ? "page:transition:finish" : "page:loading:end";
    return new Promise((resolve) => {
      if (from === START_LOCATION) {
        resolve(_calculatePosition(to, from, savedPosition, hashScrollBehaviour));
        return;
      }
      nuxtApp.hooks.hookOnce(hookToWait, () => {
        requestAnimationFrame(() => resolve(_calculatePosition(to, from, savedPosition, hashScrollBehaviour)));
      });
    });
  }
};
function _getHashElementScrollMarginTop(selector) {
  try {
    const elem = (void 0).querySelector(selector);
    if (elem) {
      return (Number.parseFloat(getComputedStyle(elem).scrollMarginTop) || 0) + (Number.parseFloat(getComputedStyle((void 0).documentElement).scrollPaddingTop) || 0);
    }
  } catch {
  }
  return 0;
}
function _calculatePosition(to, from, savedPosition, defaultHashScrollBehaviour) {
  if (savedPosition) {
    return savedPosition;
  }
  const isPageNavigation = isChangingPage(to, from);
  if (to.hash) {
    return {
      el: to.hash,
      top: _getHashElementScrollMarginTop(to.hash),
      behavior: isPageNavigation ? defaultHashScrollBehaviour : "instant"
    };
  }
  return {
    left: 0,
    top: 0
  };
}
const routerOptions1 = {
  scrollBehavior(to, from, savedPosition) {
    if (savedPosition) {
      return savedPosition;
    }
    if (from.path === "/" || to.name === "slug") {
      return false;
    }
    return { top: 0 };
  }
};
const configRouterOptions = {
  hashMode: false,
  scrollBehaviorType: "auto"
};
const hashMode = routerOptions1.hashMode ?? false;
const routerOptions = {
  ...configRouterOptions,
  ...routerOptions0,
  ...routerOptions1
};
const validate = /* @__PURE__ */ defineNuxtRouteMiddleware(async (to, from) => {
  let __temp, __restore;
  if (!to.meta?.validate) {
    return;
  }
  const result = ([__temp, __restore] = executeAsync(() => Promise.resolve(to.meta.validate(to))), __temp = await __temp, __restore(), __temp);
  if (result === true) {
    return;
  }
  const error = createError({
    fatal: false,
    statusCode: result && result.statusCode || 404,
    statusMessage: result && result.statusMessage || `Page Not Found: ${to.fullPath}`,
    data: {
      path: to.fullPath
    }
  });
  return error;
});
const useSettingsStore = defineStore("settings", {
  state: () => ({
    data: {},
    isInitialized: false,
    isLoading: false,
    error: null
  }),
  getters: {
    /**
     * 获取初始化状态
     */
    isReady: (state2) => state2.isInitialized && !state2.isLoading,
    /**
     * 获取错误状态
     */
    getError: (state2) => state2.error
  },
  actions: {
    /**
     * 从服务器一次性加载所有设置
     */
    async initSettings() {
      if (this.isInitialized) {
        return;
      }
      this.isLoading = true;
      this.error = null;
      try {
        const response = await $fetch("/api/system/settings/all");
        this.data = response.data;
        this.isInitialized = true;
      } catch (error) {
        this.error = error;
        console.error("[Settings] Failed to initialize settings:", error);
        throw error;
      } finally {
        this.isLoading = false;
      }
    },
    /**
     * 同步获取单个设置或整个命名空间
     * @param key - 'namespace:key' 格式获取单个值，或 'namespace' 格式获取整个命名空间
     * @returns 设置值，如果不存在返回 null
     */
    getSetting(key) {
      if (!this.isInitialized) {
        console.warn(
          "[Settings] Settings not initialized yet. Call await initSettings() first."
        );
        return null;
      }
      if (key.includes(":")) {
        const parts = key.split(":");
        const namespace = parts[0];
        const settingKey = parts[1];
        if (namespace && settingKey) {
          const namespaceObj = this.data[namespace];
          if (namespaceObj) {
            return namespaceObj[settingKey] ?? null;
          }
        }
        return null;
      }
      return this.data[key] ?? null;
    },
    /**
     * 刷新设置
     */
    async refreshSettings() {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await $fetch("/api/system/settings/all");
        this.data = response.data;
        this.isInitialized = true;
      } catch (error) {
        this.error = error;
        console.error("[Settings] Failed to refresh settings:", error);
        throw error;
      } finally {
        this.isLoading = false;
      }
    }
  }
});
function getSetting(key) {
  try {
    const store = useSettingsStore();
    return store.getSetting(key);
  } catch (error) {
    console.warn("[Settings] Failed to access settings store:", error);
    return null;
  }
}
function useSettingRef(key) {
  const store = useSettingsStore();
  return computed(() => store.getSetting(key));
}
const setup_45global = /* @__PURE__ */ defineNuxtRouteMiddleware(async (to, _from) => {
  let __temp, __restore;
  const settingsStore = useSettingsStore();
  if (!settingsStore.isReady) {
    try {
      ;
      [__temp, __restore] = executeAsync(() => settingsStore.initSettings()), await __temp, __restore();
      ;
    } catch (e) {
      console.error("Failed to load settings in middleware", e);
    }
  }
  const isFirstLaunch = settingsStore.getSetting("system:firstLaunch");
  const isOnboarding = to.path.startsWith("/onboarding");
  if (isFirstLaunch === true) {
    if (!isOnboarding) {
      return navigateTo("/onboarding");
    }
  }
});
const manifest_45route_45rule = /* @__PURE__ */ defineNuxtRouteMiddleware(async (to) => {
  {
    return;
  }
});
const globalMiddleware = [
  validate,
  setup_45global,
  manifest_45route_45rule
];
const namedMiddleware = {};
const plugin$1 = /* @__PURE__ */ defineNuxtPlugin({
  name: "nuxt:router",
  enforce: "pre",
  async setup(nuxtApp) {
    let __temp, __restore;
    let routerBase = (/* @__PURE__ */ useRuntimeConfig()).app.baseURL;
    if (hashMode && !routerBase.includes("#")) {
      routerBase += "#";
    }
    const history = routerOptions.history?.(routerBase) ?? createMemoryHistory(routerBase);
    const routes = routerOptions.routes ? ([__temp, __restore] = executeAsync(() => routerOptions.routes(_routes)), __temp = await __temp, __restore(), __temp) ?? _routes : _routes;
    let startPosition;
    const router = createRouter({
      ...routerOptions,
      scrollBehavior: (to, from, savedPosition) => {
        if (from === START_LOCATION) {
          startPosition = savedPosition;
          return;
        }
        if (routerOptions.scrollBehavior) {
          router.options.scrollBehavior = routerOptions.scrollBehavior;
          if ("scrollRestoration" in (void 0).history) {
            const unsub = router.beforeEach(() => {
              unsub();
              (void 0).history.scrollRestoration = "manual";
            });
          }
          return routerOptions.scrollBehavior(to, START_LOCATION, startPosition || savedPosition);
        }
      },
      history,
      routes
    });
    nuxtApp.vueApp.use(router);
    const previousRoute = shallowRef(router.currentRoute.value);
    router.afterEach((_to, from) => {
      previousRoute.value = from;
    });
    Object.defineProperty(nuxtApp.vueApp.config.globalProperties, "previousRoute", {
      get: () => previousRoute.value
    });
    const initialURL = nuxtApp.ssrContext.url;
    const _route = shallowRef(router.currentRoute.value);
    const syncCurrentRoute = () => {
      _route.value = router.currentRoute.value;
    };
    router.afterEach((to, from) => {
      if (to.matched.at(-1)?.components?.default === from.matched.at(-1)?.components?.default) {
        syncCurrentRoute();
      }
    });
    const route = { sync: syncCurrentRoute };
    for (const key in _route.value) {
      Object.defineProperty(route, key, {
        get: () => _route.value[key],
        enumerable: true
      });
    }
    nuxtApp._route = shallowReactive(route);
    nuxtApp._middleware ||= {
      global: [],
      named: {}
    };
    if (!nuxtApp.ssrContext?.islandContext) {
      router.afterEach(async (to, _from, failure) => {
        delete nuxtApp._processingMiddleware;
        if (failure) {
          await nuxtApp.callHook("page:loading:end");
        }
        if (failure?.type === 4) {
          return;
        }
        if (to.redirectedFrom && to.fullPath !== initialURL) {
          await nuxtApp.runWithContext(() => navigateTo(to.fullPath || "/"));
        }
      });
    }
    try {
      if (true) {
        ;
        [__temp, __restore] = executeAsync(() => router.push(initialURL)), await __temp, __restore();
        ;
      }
      ;
      [__temp, __restore] = executeAsync(() => router.isReady()), await __temp, __restore();
      ;
    } catch (error2) {
      [__temp, __restore] = executeAsync(() => nuxtApp.runWithContext(() => showError(error2))), await __temp, __restore();
    }
    const resolvedInitialRoute = router.currentRoute.value;
    syncCurrentRoute();
    if (nuxtApp.ssrContext?.islandContext) {
      return { provide: { router } };
    }
    const initialLayout = nuxtApp.payload.state._layout;
    router.beforeEach(async (to, from) => {
      await nuxtApp.callHook("page:loading:start");
      to.meta = reactive(to.meta);
      if (nuxtApp.isHydrating && initialLayout && !isReadonly(to.meta.layout)) {
        to.meta.layout = initialLayout;
      }
      nuxtApp._processingMiddleware = true;
      if (!nuxtApp.ssrContext?.islandContext) {
        const middlewareEntries = /* @__PURE__ */ new Set([...globalMiddleware, ...nuxtApp._middleware.global]);
        for (const component of to.matched) {
          const componentMiddleware = component.meta.middleware;
          if (!componentMiddleware) {
            continue;
          }
          for (const entry2 of toArray$4(componentMiddleware)) {
            middlewareEntries.add(entry2);
          }
        }
        {
          const routeRules = await nuxtApp.runWithContext(() => getRouteRules({ path: to.path }));
          if (routeRules.appMiddleware) {
            for (const key in routeRules.appMiddleware) {
              if (routeRules.appMiddleware[key]) {
                middlewareEntries.add(key);
              } else {
                middlewareEntries.delete(key);
              }
            }
          }
        }
        for (const entry2 of middlewareEntries) {
          const middleware = typeof entry2 === "string" ? nuxtApp._middleware.named[entry2] || await namedMiddleware[entry2]?.().then((r) => r.default || r) : entry2;
          if (!middleware) {
            throw new Error(`Unknown route middleware: '${entry2}'.`);
          }
          try {
            if (false) ;
            const result = await nuxtApp.runWithContext(() => middleware(to, from));
            if (true) {
              if (result === false || result instanceof Error) {
                const error2 = result || createError({
                  statusCode: 404,
                  statusMessage: `Page Not Found: ${initialURL}`
                });
                await nuxtApp.runWithContext(() => showError(error2));
                return false;
              }
            }
            if (result === true) {
              continue;
            }
            if (result === false) {
              return result;
            }
            if (result) {
              if (isNuxtError(result) && result.fatal) {
                await nuxtApp.runWithContext(() => showError(result));
              }
              return result;
            }
          } catch (err) {
            const error2 = createError(err);
            if (error2.fatal) {
              await nuxtApp.runWithContext(() => showError(error2));
            }
            return error2;
          }
        }
      }
    });
    router.onError(async () => {
      delete nuxtApp._processingMiddleware;
      await nuxtApp.callHook("page:loading:end");
    });
    router.afterEach((to) => {
      if (to.matched.length === 0) {
        return nuxtApp.runWithContext(() => showError(createError({
          statusCode: 404,
          fatal: false,
          statusMessage: `Page not found: ${to.fullPath}`,
          data: {
            path: to.fullPath
          }
        })));
      }
    });
    nuxtApp.hooks.hookOnce("app:created", async () => {
      try {
        if ("name" in resolvedInitialRoute) {
          resolvedInitialRoute.name = void 0;
        }
        await router.replace({
          ...resolvedInitialRoute,
          force: true
        });
        router.options.scrollBehavior = routerOptions.scrollBehavior;
      } catch (error2) {
        await nuxtApp.runWithContext(() => showError(error2));
      }
    });
    return { provide: { router } };
  }
});
defineComponent({
  name: "ServerPlaceholder",
  render() {
    return createElementBlock("div");
  }
});
const clientOnlySymbol = /* @__PURE__ */ Symbol.for("nuxt:client-only");
const __nuxt_component_0$6 = defineComponent({
  name: "ClientOnly",
  inheritAttrs: false,
  props: ["fallback", "placeholder", "placeholderTag", "fallbackTag"],
  ...false,
  setup(props, { slots, attrs }) {
    const mounted = shallowRef(false);
    const vm = getCurrentInstance$1();
    if (vm) {
      vm._nuxtClientOnly = true;
    }
    provide(clientOnlySymbol, true);
    return () => {
      if (mounted.value) {
        const vnodes = slots.default?.();
        if (vnodes && vnodes.length === 1) {
          return [cloneVNode(vnodes[0], attrs)];
        }
        return vnodes;
      }
      const slot = slots.fallback || slots.placeholder;
      if (slot) {
        return h(slot);
      }
      const fallbackStr = props.fallback || props.placeholder || "";
      const fallbackTag = props.fallbackTag || props.placeholderTag || "span";
      return createElementBlock(fallbackTag, attrs, fallbackStr);
    };
  }
});
function useAsyncData(...args) {
  const autoKey = typeof args[args.length - 1] === "string" ? args.pop() : void 0;
  if (_isAutoKeyNeeded(args[0], args[1])) {
    args.unshift(autoKey);
  }
  let [_key, _handler, options = {}] = args;
  const key = computed(() => toValue(_key));
  if (typeof key.value !== "string") {
    throw new TypeError("[nuxt] [useAsyncData] key must be a string.");
  }
  if (typeof _handler !== "function") {
    throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");
  }
  const nuxtApp = useNuxtApp();
  options.server ??= true;
  options.default ??= getDefault;
  options.getCachedData ??= getDefaultCachedData;
  options.lazy ??= false;
  options.immediate ??= true;
  options.deep ??= asyncDataDefaults.deep;
  options.dedupe ??= "cancel";
  options._functionName || "useAsyncData";
  nuxtApp._asyncData[key.value];
  function createInitialFetch() {
    const initialFetchOptions = { cause: "initial", dedupe: options.dedupe };
    if (!nuxtApp._asyncData[key.value]?._init) {
      initialFetchOptions.cachedData = options.getCachedData(key.value, nuxtApp, { cause: "initial" });
      nuxtApp._asyncData[key.value] = createAsyncData(nuxtApp, key.value, _handler, options, initialFetchOptions.cachedData);
    }
    return () => nuxtApp._asyncData[key.value].execute(initialFetchOptions);
  }
  const initialFetch = createInitialFetch();
  const asyncData = nuxtApp._asyncData[key.value];
  asyncData._deps++;
  const fetchOnServer = options.server !== false && nuxtApp.payload.serverRendered;
  if (fetchOnServer && options.immediate) {
    const promise = initialFetch();
    if (getCurrentInstance$1()) {
      onServerPrefetch(() => promise);
    } else {
      nuxtApp.hook("app:created", async () => {
        await promise;
      });
    }
  }
  const asyncReturn = {
    data: writableComputedRef(() => nuxtApp._asyncData[key.value]?.data),
    pending: writableComputedRef(() => nuxtApp._asyncData[key.value]?.pending),
    status: writableComputedRef(() => nuxtApp._asyncData[key.value]?.status),
    error: writableComputedRef(() => nuxtApp._asyncData[key.value]?.error),
    refresh: (...args2) => {
      if (!nuxtApp._asyncData[key.value]?._init) {
        const initialFetch2 = createInitialFetch();
        return initialFetch2();
      }
      return nuxtApp._asyncData[key.value].execute(...args2);
    },
    execute: (...args2) => asyncReturn.refresh(...args2),
    clear: () => {
      const entry2 = nuxtApp._asyncData[key.value];
      if (entry2?._abortController) {
        try {
          entry2._abortController.abort(new DOMException("AsyncData aborted by user.", "AbortError"));
        } finally {
          entry2._abortController = void 0;
        }
      }
      clearNuxtDataByKey(nuxtApp, key.value);
    }
  };
  const asyncDataPromise = Promise.resolve(nuxtApp._asyncDataPromises[key.value]).then(() => asyncReturn);
  Object.assign(asyncDataPromise, asyncReturn);
  return asyncDataPromise;
}
function writableComputedRef(getter) {
  return computed({
    get() {
      return getter()?.value;
    },
    set(value) {
      const ref2 = getter();
      if (ref2) {
        ref2.value = value;
      }
    }
  });
}
function _isAutoKeyNeeded(keyOrFetcher, fetcher) {
  if (typeof keyOrFetcher === "string") {
    return false;
  }
  if (typeof keyOrFetcher === "object" && keyOrFetcher !== null) {
    return false;
  }
  if (typeof keyOrFetcher === "function" && typeof fetcher === "function") {
    return false;
  }
  return true;
}
function clearNuxtDataByKey(nuxtApp, key) {
  if (key in nuxtApp.payload.data) {
    nuxtApp.payload.data[key] = void 0;
  }
  if (key in nuxtApp.payload._errors) {
    nuxtApp.payload._errors[key] = void 0;
  }
  if (nuxtApp._asyncData[key]) {
    nuxtApp._asyncData[key].data.value = unref(nuxtApp._asyncData[key]._default());
    nuxtApp._asyncData[key].error.value = void 0;
    nuxtApp._asyncData[key].status.value = "idle";
  }
  if (key in nuxtApp._asyncDataPromises) {
    nuxtApp._asyncDataPromises[key] = void 0;
  }
}
function pick(obj, keys) {
  const newObj = {};
  for (const key of keys) {
    newObj[key] = obj[key];
  }
  return newObj;
}
function createAsyncData(nuxtApp, key, _handler, options, initialCachedData) {
  nuxtApp.payload._errors[key] ??= void 0;
  const hasCustomGetCachedData = options.getCachedData !== getDefaultCachedData;
  const handler = _handler ;
  const _ref = options.deep ? ref : shallowRef;
  const hasCachedData = initialCachedData !== void 0;
  const unsubRefreshAsyncData = nuxtApp.hook("app:data:refresh", async (keys) => {
    if (!keys || keys.includes(key)) {
      await asyncData.execute({ cause: "refresh:hook" });
    }
  });
  const asyncData = {
    data: _ref(hasCachedData ? initialCachedData : options.default()),
    pending: computed(() => asyncData.status.value === "pending"),
    error: toRef$2(nuxtApp.payload._errors, key),
    status: shallowRef("idle"),
    execute: (...args) => {
      const [_opts, newValue = void 0] = args;
      const opts = _opts && newValue === void 0 && typeof _opts === "object" ? _opts : {};
      if (nuxtApp._asyncDataPromises[key]) {
        if ((opts.dedupe ?? options.dedupe) === "defer") {
          return nuxtApp._asyncDataPromises[key];
        }
      }
      {
        const cachedData = "cachedData" in opts ? opts.cachedData : options.getCachedData(key, nuxtApp, { cause: opts.cause ?? "refresh:manual" });
        if (cachedData !== void 0) {
          nuxtApp.payload.data[key] = asyncData.data.value = cachedData;
          asyncData.error.value = void 0;
          asyncData.status.value = "success";
          return Promise.resolve(cachedData);
        }
      }
      if (asyncData._abortController) {
        asyncData._abortController.abort(new DOMException("AsyncData request cancelled by deduplication", "AbortError"));
      }
      asyncData._abortController = new AbortController();
      asyncData.status.value = "pending";
      const cleanupController = new AbortController();
      const promise = new Promise(
        (resolve, reject) => {
          try {
            const timeout = opts.timeout ?? options.timeout;
            const mergedSignal = mergeAbortSignals([asyncData._abortController?.signal, opts?.signal], cleanupController.signal, timeout);
            if (mergedSignal.aborted) {
              const reason = mergedSignal.reason;
              reject(reason instanceof Error ? reason : new DOMException(String(reason ?? "Aborted"), "AbortError"));
              return;
            }
            mergedSignal.addEventListener("abort", () => {
              const reason = mergedSignal.reason;
              reject(reason instanceof Error ? reason : new DOMException(String(reason ?? "Aborted"), "AbortError"));
            }, { once: true, signal: cleanupController.signal });
            return Promise.resolve(handler(nuxtApp, { signal: mergedSignal })).then(resolve, reject);
          } catch (err) {
            reject(err);
          }
        }
      ).then(async (_result) => {
        let result = _result;
        if (options.transform) {
          result = await options.transform(_result);
        }
        if (options.pick) {
          result = pick(result, options.pick);
        }
        nuxtApp.payload.data[key] = result;
        asyncData.data.value = result;
        asyncData.error.value = void 0;
        asyncData.status.value = "success";
      }).catch((error) => {
        if (nuxtApp._asyncDataPromises[key] && nuxtApp._asyncDataPromises[key] !== promise) {
          return nuxtApp._asyncDataPromises[key];
        }
        if (asyncData._abortController?.signal.aborted) {
          return nuxtApp._asyncDataPromises[key];
        }
        if (typeof DOMException !== "undefined" && error instanceof DOMException && error.name === "AbortError") {
          asyncData.status.value = "idle";
          return nuxtApp._asyncDataPromises[key];
        }
        asyncData.error.value = createError(error);
        asyncData.data.value = unref(options.default());
        asyncData.status.value = "error";
      }).finally(() => {
        cleanupController.abort();
        delete nuxtApp._asyncDataPromises[key];
      });
      nuxtApp._asyncDataPromises[key] = promise;
      return nuxtApp._asyncDataPromises[key];
    },
    _execute: debounce((...args) => asyncData.execute(...args), 0, { leading: true }),
    _default: options.default,
    _deps: 0,
    _init: true,
    _hash: void 0,
    _off: () => {
      unsubRefreshAsyncData();
      if (nuxtApp._asyncData[key]?._init) {
        nuxtApp._asyncData[key]._init = false;
      }
      if (!hasCustomGetCachedData) {
        nextTick(() => {
          if (!nuxtApp._asyncData[key]?._init) {
            clearNuxtDataByKey(nuxtApp, key);
            asyncData.execute = () => Promise.resolve();
          }
        });
      }
    }
  };
  return asyncData;
}
const getDefault = () => void 0;
const getDefaultCachedData = (key, nuxtApp, ctx) => {
  if (nuxtApp.isHydrating) {
    return nuxtApp.payload.data[key];
  }
  if (ctx.cause !== "refresh:manual" && ctx.cause !== "refresh:hook") {
    return nuxtApp.static.data[key];
  }
};
function mergeAbortSignals(signals, cleanupSignal, timeout) {
  const list = signals.filter((s) => !!s);
  if (typeof timeout === "number" && timeout >= 0) {
    const timeoutSignal = AbortSignal.timeout?.(timeout);
    if (timeoutSignal) {
      list.push(timeoutSignal);
    }
  }
  if (AbortSignal.any) {
    return AbortSignal.any(list);
  }
  const controller = new AbortController();
  for (const sig of list) {
    if (sig.aborted) {
      const reason = sig.reason ?? new DOMException("Aborted", "AbortError");
      try {
        controller.abort(reason);
      } catch {
        controller.abort();
      }
      return controller.signal;
    }
  }
  const onAbort = () => {
    const abortedSignal = list.find((s) => s.aborted);
    const reason = abortedSignal?.reason ?? new DOMException("Aborted", "AbortError");
    try {
      controller.abort(reason);
    } catch {
      controller.abort();
    }
  };
  for (const sig of list) {
    sig.addEventListener?.("abort", onAbort, { once: true, signal: cleanupSignal });
  }
  return controller.signal;
}
const useStateKeyPrefix = "$s";
function useState(...args) {
  const autoKey = typeof args[args.length - 1] === "string" ? args.pop() : void 0;
  if (typeof args[0] !== "string") {
    args.unshift(autoKey);
  }
  const [_key, init2] = args;
  if (!_key || typeof _key !== "string") {
    throw new TypeError("[nuxt] [useState] key must be a string: " + _key);
  }
  if (init2 !== void 0 && typeof init2 !== "function") {
    throw new Error("[nuxt] [useState] init must be a function: " + init2);
  }
  const key = useStateKeyPrefix + _key;
  const nuxtApp = useNuxtApp();
  const state2 = toRef$2(nuxtApp.payload.state, key);
  if (state2.value === void 0 && init2) {
    const initialValue = init2();
    if (isRef(initialValue)) {
      nuxtApp.payload.state[key] = initialValue;
      return initialValue;
    }
    state2.value = initialValue;
  }
  return state2;
}
function useRequestEvent(nuxtApp) {
  nuxtApp ||= useNuxtApp();
  return nuxtApp.ssrContext?.event;
}
function useRequestFetch() {
  return useRequestEvent()?.$fetch || globalThis.$fetch;
}
function prerenderRoutes(path) {
  {
    return;
  }
}
function useFetch(request, arg1, arg2) {
  const [opts = {}, autoKey] = typeof arg1 === "string" ? [{}, arg1] : [arg1, arg2];
  const _request = computed(() => toValue(request));
  const key = computed(() => toValue(opts.key) || "$f" + hash([autoKey, typeof _request.value === "string" ? _request.value : "", ...generateOptionSegments(opts)]));
  if (!opts.baseURL && typeof _request.value === "string" && (_request.value[0] === "/" && _request.value[1] === "/")) {
    throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');
  }
  const {
    server,
    lazy,
    default: defaultFn,
    transform: transform2,
    pick: pick2,
    watch: watchSources,
    immediate,
    getCachedData,
    deep,
    dedupe,
    timeout,
    ...fetchOptions
  } = opts;
  const _fetchOptions = reactive({
    ...fetchDefaults,
    ...fetchOptions,
    cache: typeof opts.cache === "boolean" ? void 0 : opts.cache
  });
  const _asyncDataOptions = {
    server,
    lazy,
    default: defaultFn,
    transform: transform2,
    pick: pick2,
    immediate,
    getCachedData,
    deep,
    dedupe,
    timeout,
    watch: watchSources === false ? [] : [...watchSources || [], _fetchOptions]
  };
  const asyncData = useAsyncData(watchSources === false ? key.value : key, (_2, { signal }) => {
    let _$fetch = opts.$fetch || globalThis.$fetch;
    if (!opts.$fetch) {
      const isLocalFetch = typeof _request.value === "string" && _request.value[0] === "/" && (!toValue(opts.baseURL) || toValue(opts.baseURL)[0] === "/");
      if (isLocalFetch) {
        _$fetch = useRequestFetch();
      }
    }
    return _$fetch(_request.value, { signal, ..._fetchOptions });
  }, _asyncDataOptions);
  return asyncData;
}
function generateOptionSegments(opts) {
  const segments = [
    toValue(opts.method)?.toUpperCase() || "GET",
    toValue(opts.baseURL)
  ];
  for (const _obj of [opts.query || opts.params]) {
    const obj = toValue(_obj);
    if (!obj) {
      continue;
    }
    const unwrapped = {};
    for (const [key, value] of Object.entries(obj)) {
      unwrapped[toValue(key)] = toValue(value);
    }
    segments.push(unwrapped);
  }
  if (opts.body) {
    const value = toValue(opts.body);
    if (!value) {
      segments.push(hash(value));
    } else if (value instanceof ArrayBuffer) {
      segments.push(hash(Object.fromEntries([...new Uint8Array(value).entries()].map(([k2, v]) => [k2, v.toString()]))));
    } else if (value instanceof FormData) {
      const obj = {};
      for (const entry2 of value.entries()) {
        const [key, val] = entry2;
        obj[key] = val instanceof File ? val.name : val;
      }
      segments.push(hash(obj));
    } else if (shared_cjs_prodExports.isPlainObject(value)) {
      segments.push(hash(reactive(value)));
    } else {
      try {
        segments.push(hash(value));
      } catch {
        console.warn("[useFetch] Failed to hash body", value);
      }
    }
  }
  return segments;
}
const CookieDefaults = {
  path: "/",
  watch: true,
  decode: (val) => destr(decodeURIComponent(val)),
  encode: (val) => encodeURIComponent(typeof val === "string" ? val : JSON.stringify(val))
};
function useCookie(name2, _opts) {
  const opts = { ...CookieDefaults, ..._opts };
  opts.filter ??= (key) => key === name2;
  const cookies = readRawCookies(opts) || {};
  let delay2;
  if (opts.maxAge !== void 0) {
    delay2 = opts.maxAge * 1e3;
  } else if (opts.expires) {
    delay2 = opts.expires.getTime() - Date.now();
  }
  const hasExpired = delay2 !== void 0 && delay2 <= 0;
  const cookieValue = klona(hasExpired ? void 0 : cookies[name2] ?? opts.default?.());
  const cookie = ref(cookieValue);
  {
    const nuxtApp = useNuxtApp();
    const writeFinalCookieValue = () => {
      if (opts.readonly || isEqual$2(cookie.value, cookies[name2])) {
        return;
      }
      nuxtApp._cookies ||= {};
      if (name2 in nuxtApp._cookies) {
        if (isEqual$2(cookie.value, nuxtApp._cookies[name2])) {
          return;
        }
      }
      nuxtApp._cookies[name2] = cookie.value;
      writeServerCookie(useRequestEvent(nuxtApp), name2, cookie.value, opts);
    };
    const unhook = nuxtApp.hooks.hookOnce("app:rendered", writeFinalCookieValue);
    nuxtApp.hooks.hookOnce("app:error", () => {
      unhook();
      return writeFinalCookieValue();
    });
  }
  return cookie;
}
function readRawCookies(opts = {}) {
  {
    return parse$1(getRequestHeader(useRequestEvent(), "cookie") || "", opts);
  }
}
function writeServerCookie(event, name2, value, opts = {}) {
  if (event) {
    if (value !== null && value !== void 0) {
      return setCookie(event, name2, value, opts);
    }
    if (getCookie(event, name2) !== void 0) {
      return deleteCookie(event, name2, opts);
    }
  }
}
function useRequestURL(opts) {
  {
    return getRequestURL(useRequestEvent(), opts);
  }
}
const firstNonUndefined = (...args) => args.find((arg) => arg !== void 0);
// @__NO_SIDE_EFFECTS__
function defineNuxtLink(options) {
  const componentName = options.componentName || "NuxtLink";
  function isHashLinkWithoutHashMode(link) {
    return !hashMode && typeof link === "string" && link.startsWith("#");
  }
  function resolveTrailingSlashBehavior(to, resolve, trailingSlash) {
    const effectiveTrailingSlash = trailingSlash ?? options.trailingSlash;
    if (!to || effectiveTrailingSlash !== "append" && effectiveTrailingSlash !== "remove") {
      return to;
    }
    if (typeof to === "string") {
      return applyTrailingSlashBehavior(to, effectiveTrailingSlash);
    }
    const path = "path" in to && to.path !== void 0 ? to.path : resolve(to).path;
    const resolvedPath = {
      ...to,
      name: void 0,
      // named routes would otherwise always override trailing slash behavior
      path: applyTrailingSlashBehavior(path, effectiveTrailingSlash)
    };
    return resolvedPath;
  }
  function useNuxtLink(props) {
    const router = useRouter();
    const config = /* @__PURE__ */ useRuntimeConfig();
    const hasTarget = computed(() => !!props.target && props.target !== "_self");
    const isAbsoluteUrl = computed(() => {
      const path = props.to || props.href || "";
      return typeof path === "string" && hasProtocol(path, { acceptRelative: true });
    });
    const builtinRouterLink = resolveComponent("RouterLink");
    const useBuiltinLink = builtinRouterLink && typeof builtinRouterLink !== "string" ? builtinRouterLink.useLink : void 0;
    const isExternal = computed(() => {
      if (props.external) {
        return true;
      }
      const path = props.to || props.href || "";
      if (typeof path === "object") {
        return false;
      }
      return path === "" || isAbsoluteUrl.value;
    });
    const to = computed(() => {
      const path = props.to || props.href || "";
      if (isExternal.value) {
        return path;
      }
      return resolveTrailingSlashBehavior(path, router.resolve, props.trailingSlash);
    });
    const link = isExternal.value ? void 0 : useBuiltinLink?.({ ...props, to });
    const href = computed(() => {
      const effectiveTrailingSlash = props.trailingSlash ?? options.trailingSlash;
      if (!to.value || isAbsoluteUrl.value || isHashLinkWithoutHashMode(to.value)) {
        return to.value;
      }
      if (isExternal.value) {
        const path = typeof to.value === "object" && "path" in to.value ? resolveRouteObject(to.value) : to.value;
        const href2 = typeof path === "object" ? router.resolve(path).href : path;
        return applyTrailingSlashBehavior(href2, effectiveTrailingSlash);
      }
      if (typeof to.value === "object") {
        return router.resolve(to.value)?.href ?? null;
      }
      return applyTrailingSlashBehavior(joinURL(config.app.baseURL, to.value), effectiveTrailingSlash);
    });
    return {
      to,
      hasTarget,
      isAbsoluteUrl,
      isExternal,
      //
      href,
      isActive: link?.isActive ?? computed(() => to.value === router.currentRoute.value.path),
      isExactActive: link?.isExactActive ?? computed(() => to.value === router.currentRoute.value.path),
      route: link?.route ?? computed(() => router.resolve(to.value)),
      async navigate(_e) {
        await navigateTo(href.value, { replace: props.replace, external: isExternal.value || hasTarget.value });
      }
    };
  }
  return defineComponent({
    name: componentName,
    props: {
      // Routing
      to: {
        type: [String, Object],
        default: void 0,
        required: false
      },
      href: {
        type: [String, Object],
        default: void 0,
        required: false
      },
      // Attributes
      target: {
        type: String,
        default: void 0,
        required: false
      },
      rel: {
        type: String,
        default: void 0,
        required: false
      },
      noRel: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Prefetching
      prefetch: {
        type: Boolean,
        default: void 0,
        required: false
      },
      prefetchOn: {
        type: [String, Object],
        default: void 0,
        required: false
      },
      noPrefetch: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Styling
      activeClass: {
        type: String,
        default: void 0,
        required: false
      },
      exactActiveClass: {
        type: String,
        default: void 0,
        required: false
      },
      prefetchedClass: {
        type: String,
        default: void 0,
        required: false
      },
      // Vue Router's `<RouterLink>` additional props
      replace: {
        type: Boolean,
        default: void 0,
        required: false
      },
      ariaCurrentValue: {
        type: String,
        default: void 0,
        required: false
      },
      // Edge cases handling
      external: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Slot API
      custom: {
        type: Boolean,
        default: void 0,
        required: false
      },
      // Behavior
      trailingSlash: {
        type: String,
        default: void 0,
        required: false
      }
    },
    useLink: useNuxtLink,
    setup(props, { slots }) {
      const router = useRouter();
      const { to, href, navigate: navigate2, isExternal, hasTarget, isAbsoluteUrl } = useNuxtLink(props);
      shallowRef(false);
      const el = void 0;
      const elRef = void 0;
      async function prefetch(nuxtApp = useNuxtApp()) {
        {
          return;
        }
      }
      return () => {
        if (!isExternal.value && !hasTarget.value && !isHashLinkWithoutHashMode(to.value)) {
          const routerLinkProps = {
            ref: elRef,
            to: to.value,
            activeClass: props.activeClass || options.activeClass,
            exactActiveClass: props.exactActiveClass || options.exactActiveClass,
            replace: props.replace,
            ariaCurrentValue: props.ariaCurrentValue,
            custom: props.custom
          };
          if (!props.custom) {
            routerLinkProps.rel = props.rel || void 0;
          }
          return h(
            resolveComponent("RouterLink"),
            routerLinkProps,
            slots.default
          );
        }
        const target = props.target || null;
        const rel = firstNonUndefined(
          // converts `""` to `null` to prevent the attribute from being added as empty (`rel=""`)
          props.noRel ? "" : props.rel,
          options.externalRelAttribute,
          /*
          * A fallback rel of `noopener noreferrer` is applied for external links or links that open in a new tab.
          * This solves a reverse tabnapping security flaw in browsers pre-2021 as well as improving privacy.
          */
          isAbsoluteUrl.value || hasTarget.value ? "noopener noreferrer" : ""
        ) || null;
        if (props.custom) {
          if (!slots.default) {
            return null;
          }
          return slots.default({
            href: href.value,
            navigate: navigate2,
            prefetch,
            get route() {
              if (!href.value) {
                return void 0;
              }
              const url = new URL(href.value, "http://localhost");
              return {
                path: url.pathname,
                fullPath: url.pathname,
                get query() {
                  return parseQuery(url.search);
                },
                hash: url.hash,
                params: {},
                name: void 0,
                matched: [],
                redirectedFrom: void 0,
                meta: {},
                href: href.value
              };
            },
            rel,
            target,
            isExternal: isExternal.value || hasTarget.value,
            isActive: false,
            isExactActive: false
          });
        }
        return h("a", {
          ref: el,
          href: href.value || null,
          // converts `""` to `null` to prevent the attribute from being added as empty (`href=""`)
          rel,
          target,
          onClick: (event) => {
            if (isExternal.value || hasTarget.value) {
              return;
            }
            event.preventDefault();
            return props.replace ? router.replace(href.value) : router.push(href.value);
          }
        }, slots.default?.());
      };
    }
  });
}
const __nuxt_component_0$5 = /* @__PURE__ */ defineNuxtLink(nuxtLinkDefaults);
function applyTrailingSlashBehavior(to, trailingSlash) {
  const normalizeFn = trailingSlash === "append" ? withTrailingSlash : withoutTrailingSlash;
  const hasProtocolDifferentFromHttp = hasProtocol(to) && !to.startsWith("http");
  if (hasProtocolDifferentFromHttp) {
    return to;
  }
  return normalizeFn(to, true);
}
const cfg0 = defineAppConfig({
  ui: {
    colors: {
      primary: "pink",
      secondary: "purple",
      neutral: "neutral",
      info: "sky",
      success: "emerald",
      warning: "amber",
      danger: "rose"
    },
    button: {
      slots: {
        base: "cursor-pointer"
      }
    },
    popover: {
      slots: {
        content: "bg-white/70 dark:bg-neutral-900/50 backdrop-blur-3xl ring-0 shadow-lg border border-neutral-300/50 dark:border-neutral-500/50 rounded-lg"
      }
    },
    card: {
      slots: {
        header: "font-semibold"
      },
      variants: {
        variant: {
          glassmorphism: {
            root: "shadow-lg divide-y-0 divide-neutral-300/50 dark:divide-neutral-500/50",
            header: "p-2 sm:p-2 pb-0!",
            body: "p-2 sm:p-2",
            footer: "p-2 sm:p-2"
          }
        }
      }
    },
    formField: {
      slots: {
        label: "mb-1",
        help: "mt-0.5"
      }
    }
  }
});
const inlineConfig = {
  "nuxt": {},
  "ui": {
    "colors": {
      "primary": "green",
      "secondary": "blue",
      "success": "green",
      "info": "blue",
      "warning": "yellow",
      "error": "red",
      "neutral": "slate"
    },
    "icons": {
      "arrowDown": "i-lucide-arrow-down",
      "arrowLeft": "i-lucide-arrow-left",
      "arrowRight": "i-lucide-arrow-right",
      "arrowUp": "i-lucide-arrow-up",
      "caution": "i-lucide-circle-alert",
      "check": "i-lucide-check",
      "chevronDoubleLeft": "i-lucide-chevrons-left",
      "chevronDoubleRight": "i-lucide-chevrons-right",
      "chevronDown": "i-lucide-chevron-down",
      "chevronLeft": "i-lucide-chevron-left",
      "chevronRight": "i-lucide-chevron-right",
      "chevronUp": "i-lucide-chevron-up",
      "close": "i-lucide-x",
      "copy": "i-lucide-copy",
      "copyCheck": "i-lucide-copy-check",
      "dark": "i-lucide-moon",
      "drag": "i-lucide-grip-vertical",
      "ellipsis": "i-lucide-ellipsis",
      "error": "i-lucide-circle-x",
      "external": "i-lucide-arrow-up-right",
      "eye": "i-lucide-eye",
      "eyeOff": "i-lucide-eye-off",
      "file": "i-lucide-file",
      "folder": "i-lucide-folder",
      "folderOpen": "i-lucide-folder-open",
      "hash": "i-lucide-hash",
      "info": "i-lucide-info",
      "light": "i-lucide-sun",
      "loading": "i-lucide-loader-circle",
      "menu": "i-lucide-menu",
      "minus": "i-lucide-minus",
      "panelClose": "i-lucide-panel-left-close",
      "panelOpen": "i-lucide-panel-left-open",
      "plus": "i-lucide-plus",
      "reload": "i-lucide-rotate-ccw",
      "search": "i-lucide-search",
      "stop": "i-lucide-square",
      "success": "i-lucide-circle-check",
      "system": "i-lucide-monitor",
      "tip": "i-lucide-lightbulb",
      "upload": "i-lucide-upload",
      "warning": "i-lucide-triangle-alert"
    },
    "tv": {
      "twMergeConfig": {}
    }
  },
  "icon": {
    "provider": "server",
    "class": "",
    "aliases": {},
    "iconifyApiEndpoint": "https://api.iconify.design",
    "localApiEndpoint": "/api/_nuxt_icon",
    "fallbackToApi": true,
    "cssSelectorPrefix": "i-",
    "cssWherePseudo": true,
    "cssLayer": "components",
    "mode": "css",
    "attrs": {
      "aria-hidden": true
    },
    "collections": [
      "academicons",
      "akar-icons",
      "ant-design",
      "arcticons",
      "basil",
      "bi",
      "bitcoin-icons",
      "bpmn",
      "brandico",
      "bx",
      "bxl",
      "bxs",
      "bytesize",
      "carbon",
      "catppuccin",
      "cbi",
      "charm",
      "ci",
      "cib",
      "cif",
      "cil",
      "circle-flags",
      "circum",
      "clarity",
      "codicon",
      "covid",
      "cryptocurrency",
      "cryptocurrency-color",
      "dashicons",
      "devicon",
      "devicon-plain",
      "ei",
      "el",
      "emojione",
      "emojione-monotone",
      "emojione-v1",
      "entypo",
      "entypo-social",
      "eos-icons",
      "ep",
      "et",
      "eva",
      "f7",
      "fa",
      "fa-brands",
      "fa-regular",
      "fa-solid",
      "fa6-brands",
      "fa6-regular",
      "fa6-solid",
      "fad",
      "fe",
      "feather",
      "file-icons",
      "flag",
      "flagpack",
      "flat-color-icons",
      "flat-ui",
      "flowbite",
      "fluent",
      "fluent-emoji",
      "fluent-emoji-flat",
      "fluent-emoji-high-contrast",
      "fluent-mdl2",
      "fontelico",
      "fontisto",
      "formkit",
      "foundation",
      "fxemoji",
      "gala",
      "game-icons",
      "geo",
      "gg",
      "gis",
      "gravity-ui",
      "gridicons",
      "grommet-icons",
      "guidance",
      "healthicons",
      "heroicons",
      "heroicons-outline",
      "heroicons-solid",
      "hugeicons",
      "humbleicons",
      "ic",
      "icomoon-free",
      "icon-park",
      "icon-park-outline",
      "icon-park-solid",
      "icon-park-twotone",
      "iconamoon",
      "iconoir",
      "icons8",
      "il",
      "ion",
      "iwwa",
      "jam",
      "la",
      "lets-icons",
      "line-md",
      "logos",
      "ls",
      "lucide",
      "lucide-lab",
      "mage",
      "majesticons",
      "maki",
      "map",
      "marketeq",
      "material-symbols",
      "material-symbols-light",
      "mdi",
      "mdi-light",
      "medical-icon",
      "memory",
      "meteocons",
      "mi",
      "mingcute",
      "mono-icons",
      "mynaui",
      "nimbus",
      "nonicons",
      "noto",
      "noto-v1",
      "octicon",
      "oi",
      "ooui",
      "openmoji",
      "oui",
      "pajamas",
      "pepicons",
      "pepicons-pencil",
      "pepicons-pop",
      "pepicons-print",
      "ph",
      "pixelarticons",
      "prime",
      "ps",
      "quill",
      "radix-icons",
      "raphael",
      "ri",
      "rivet-icons",
      "si-glyph",
      "simple-icons",
      "simple-line-icons",
      "skill-icons",
      "solar",
      "streamline",
      "streamline-emojis",
      "subway",
      "svg-spinners",
      "system-uicons",
      "tabler",
      "tdesign",
      "teenyicons",
      "token",
      "token-branded",
      "topcoat",
      "twemoji",
      "typcn",
      "uil",
      "uim",
      "uis",
      "uit",
      "uiw",
      "unjs",
      "vaadin",
      "vs",
      "vscode-icons",
      "websymbol",
      "weui",
      "whh",
      "wi",
      "wpf",
      "zmdi",
      "zondicons"
    ],
    "fetchTimeout": 1500
  },
  "_MAPBOX_CONFIG": {
    "accessToken": ""
  }
};
const appConfig = /* @__PURE__ */ defuFn(cfg0, inlineConfig);
function useAppConfig() {
  const nuxtApp = useNuxtApp();
  nuxtApp._appConfig ||= klona(appConfig);
  return nuxtApp._appConfig;
}
const _0_siteConfig_i_yMjQUHdfsOan08JUMmAzex_7VXFWXiLqCwSqKsDW0 = /* @__PURE__ */ defineNuxtPlugin({
  name: "nuxt-site-config:init",
  enforce: "pre",
  async setup(nuxtApp) {
    const stack = useRequestEvent()?.context?.siteConfig;
    const state2 = useState("site-config");
    {
      nuxtApp.hooks.hook("app:rendered", () => {
        state2.value = stack?.get({
          debug: (/* @__PURE__ */ useRuntimeConfig())["nuxt-site-config"].debug,
          resolveRefs: true
        });
      });
    }
    return {
      provide: {
        nuxtSiteConfig: stack
      }
    };
  }
});
function useUserSession() {
  const serverEvent = useRequestEvent();
  const sessionState = useState("nuxt-session", () => null);
  const authReadyState = useState("nuxt-auth-ready", () => false);
  const clear = async () => {
    await useRequestFetch()("/api/_auth/session", {
      method: "DELETE",
      onResponse({ response: { headers } }) {
        if (serverEvent) {
          for (const setCookie2 of headers.getSetCookie()) {
            appendResponseHeader(serverEvent, "Set-Cookie", setCookie2);
          }
        }
      }
    });
    sessionState.value = null;
  };
  const fetch2 = async () => {
    sessionState.value = await useRequestFetch()("/api/_auth/session", {
      headers: {
        accept: "application/json"
      },
      retry: false
    }).catch(() => null);
    if (!authReadyState.value) {
      authReadyState.value = true;
    }
  };
  const popupListener = (e) => {
    if (e.key === "temp-nuxt-auth-utils-popup") {
      fetch2();
      (void 0).removeEventListener("storage", popupListener);
    }
  };
  const openInPopup = (route, size = {}) => {
    localStorage.setItem("temp-nuxt-auth-utils-popup", "true");
    const width = size.width ?? 960;
    const height = size.height ?? 600;
    const top = ((void 0).top?.outerHeight ?? 0) / 2 + ((void 0).top?.screenY ?? 0) - height / 2;
    const left = ((void 0).top?.outerWidth ?? 0) / 2 + ((void 0).top?.screenX ?? 0) - width / 2;
    (void 0).open(
      route,
      "nuxt-auth-utils-popup",
      `width=${width}, height=${height}, top=${top}, left=${left}, toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no`
    );
    (void 0).addEventListener("storage", popupListener);
  };
  return {
    ready: computed(() => authReadyState.value),
    loggedIn: computed(() => Boolean(sessionState.value?.user)),
    user: computed(() => sessionState.value?.user || null),
    session: sessionState,
    fetch: fetch2,
    openInPopup,
    clear
  };
}
const session_server_5_UxeDlpXA9IUgHZ_wiQRaJOs4O21k3HKzLLCcMjq9s = /* @__PURE__ */ defineNuxtPlugin({
  name: "session-fetch-plugin",
  enforce: "pre",
  async setup(nuxtApp) {
    let __temp, __restore;
    nuxtApp.payload.isCached = Boolean(useRequestEvent()?.context.cache);
    if (nuxtApp.payload.serverRendered && !nuxtApp.payload.prerenderedAt && !nuxtApp.payload.isCached) {
      [__temp, __restore] = executeAsync(() => useUserSession().fetch()), await __temp, __restore();
    }
  }
});
const VALID_ISLAND_KEY_RE = /^[a-z][a-z\d-]*_[a-z\d]+$/i;
function isValidIslandKey(key) {
  return typeof key === "string" && VALID_ISLAND_KEY_RE.test(key) && key.length <= 100;
}
const reducers = [
  ["NuxtError", (data) => isNuxtError(data) && data.toJSON()],
  ["EmptyShallowRef", (data) => isRef(data) && isShallow(data) && !data.value && (typeof data.value === "bigint" ? "0n" : JSON.stringify(data.value) || "_")],
  ["EmptyRef", (data) => isRef(data) && !data.value && (typeof data.value === "bigint" ? "0n" : JSON.stringify(data.value) || "_")],
  ["ShallowRef", (data) => isRef(data) && isShallow(data) && data.value],
  ["ShallowReactive", (data) => isReactive(data) && isShallow(data) && toRaw(data)],
  ["Ref", (data) => isRef(data) && data.value],
  ["Reactive", (data) => isReactive(data) && toRaw(data)]
];
{
  reducers.push(["Island", (data) => data && data?.__nuxt_island && isValidIslandKey(data.__nuxt_island.key) && data.__nuxt_island]);
}
const revive_payload_server_JGXiAkjgWmbeaRgEi0NNUhu6ZGpdJCIpUkB9KVT32cI = /* @__PURE__ */ defineNuxtPlugin({
  name: "nuxt:revive-payload:server",
  setup() {
    for (const [reducer, fn] of reducers) {
      definePayloadReducer(reducer, fn);
    }
  }
});
const plugin = /* @__PURE__ */ defineNuxtPlugin({
  name: "pinia",
  setup(nuxtApp) {
    const pinia = createPinia();
    nuxtApp.vueApp.use(pinia);
    setActivePinia(pinia);
    if (nuxtApp.payload && nuxtApp.payload.pinia) {
      pinia.state.value = nuxtApp.payload.pinia;
    }
    return {
      provide: {
        pinia
      }
    };
  },
  hooks: {
    "app:rendered"() {
      const nuxtApp = useNuxtApp();
      nuxtApp.payload.pinia = toRaw(nuxtApp.$pinia).state.value;
      setActivePinia(void 0);
    }
  }
});
const LazyIcon = defineAsyncComponent(() => Promise.resolve().then(() => index).then((r) => r["default"] || r.default || r));
const lazyGlobalComponents = [
  ["Icon", LazyIcon]
];
const components_plugin_4kY4pyzJIYX99vmMAAIorFf3CnAaptHitJgf7JxiED8 = /* @__PURE__ */ defineNuxtPlugin({
  name: "nuxt:global-components",
  setup(nuxtApp) {
    for (const [name2, component] of lazyGlobalComponents) {
      nuxtApp.vueApp.component(name2, component);
      nuxtApp.vueApp.component("Lazy" + name2, component);
    }
  }
});
function getNitroOrigin(e) {
  {
    e = e || useRequestEvent();
    return e?.context?.siteConfigNitroOrigin || "";
  }
}
function useNitroOrigin(e) {
  return getNitroOrigin(e);
}
function useSiteConfig(options) {
  const stack = useRequestEvent()?.context.siteConfig.get(defu({ resolveRefs: true }, options));
  delete stack._priority;
  return stack;
}
function resolveSitePath(pathOrUrl, options) {
  let path = pathOrUrl;
  if (hasProtocol(pathOrUrl, { strict: false, acceptRelative: true })) {
    const parsed = parseURL(pathOrUrl);
    path = parsed.pathname;
  }
  const base = withLeadingSlash(options.base || "/");
  if (base !== "/" && path.startsWith(base)) {
    path = path.slice(base.length);
  }
  let origin = withoutTrailingSlash(options.siteUrl);
  if (base !== "/" && origin.endsWith(base)) {
    origin = origin.slice(0, origin.indexOf(base));
  }
  const baseWithOrigin = options.withBase ? withBase(base, origin || "/") : origin;
  const resolvedUrl = withBase(path, baseWithOrigin);
  return path === "/" && !options.withBase ? withTrailingSlash(resolvedUrl) : fixSlashes(options.trailingSlash, resolvedUrl);
}
const fileExtensions = [
  // Images
  "jpg",
  "jpeg",
  "png",
  "gif",
  "bmp",
  "webp",
  "svg",
  "ico",
  // Documents
  "pdf",
  "doc",
  "docx",
  "xls",
  "xlsx",
  "ppt",
  "pptx",
  "txt",
  "md",
  "markdown",
  // Archives
  "zip",
  "rar",
  "7z",
  "tar",
  "gz",
  // Audio
  "mp3",
  "wav",
  "flac",
  "ogg",
  "opus",
  "m4a",
  "aac",
  "midi",
  "mid",
  // Video
  "mp4",
  "avi",
  "mkv",
  "mov",
  "wmv",
  "flv",
  "webm",
  // Web
  "html",
  "css",
  "js",
  "json",
  "xml",
  "tsx",
  "jsx",
  "ts",
  "vue",
  "svelte",
  "xsl",
  "rss",
  "atom",
  // Programming
  "php",
  "py",
  "rb",
  "java",
  "c",
  "cpp",
  "h",
  "go",
  // Data formats
  "csv",
  "tsv",
  "sql",
  "yaml",
  "yml",
  // Fonts
  "woff",
  "woff2",
  "ttf",
  "otf",
  "eot",
  // Executables/Binaries
  "exe",
  "msi",
  "apk",
  "ipa",
  "dmg",
  "iso",
  "bin",
  // Scripts/Config
  "bat",
  "cmd",
  "sh",
  "env",
  "htaccess",
  "conf",
  "toml",
  "ini",
  // Package formats
  "deb",
  "rpm",
  "jar",
  "war",
  // E-books
  "epub",
  "mobi",
  // Common temporary/backup files
  "log",
  "tmp",
  "bak",
  "old",
  "sav"
];
function isPathFile(path) {
  const lastSegment = path.split("/").pop();
  const ext = (lastSegment || path).match(/\.[0-9a-z]+$/i)?.[0];
  return ext && fileExtensions.includes(ext.replace(".", ""));
}
function fixSlashes(trailingSlash, pathOrUrl) {
  const $url = parseURL(pathOrUrl);
  if (isPathFile($url.pathname))
    return pathOrUrl;
  const fixedPath = trailingSlash ? withTrailingSlash($url.pathname) : withoutTrailingSlash($url.pathname);
  return `${$url.protocol ? `${$url.protocol}//` : ""}${$url.host || ""}${fixedPath}${$url.search || ""}${$url.hash || ""}`;
}
function withSiteUrl(path, options = {}) {
  const siteConfig = useSiteConfig();
  const nitroOrigin = useNitroOrigin();
  const base = (/* @__PURE__ */ useRuntimeConfig()).app.baseURL || "/";
  return computed(() => {
    return resolveSitePath(unref(path), {
      siteUrl: unref(options.canonical) !== false || false ? siteConfig.url : nitroOrigin,
      trailingSlash: siteConfig.trailingSlash,
      base,
      withBase: unref(options.withBase)
    });
  });
}
const componentNames = [{ "hash": "kCN-w-0p03as-Mta-3w6zhL-TOIBAqqYucwDtVMF0tw", "pascalName": "OgImagePhoto", "kebabName": "og-image-photo", "path": "/Users/xiaoyou/Desktop/chronoframe/app/components/OgImage/Photo.vue", "category": "app" }, { "hash": "SOHaoKfoo4fUkREsCFGw8ewxkl4-XkkHkug2VwYRtFM", "pascalName": "BrandedLogo", "kebabName": "branded-logo", "path": "/Users/xiaoyou/Desktop/chronoframe/node_modules/.pnpm/nuxt-og-image@5.1.12_@unhead+vue@2.1.1_vue@3.5.26_typescript@5.9.3___h3@1.15.4_magicast_cc5ffa53446ac9a9d3e84ffe6464de21/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/BrandedLogo.vue", "category": "community" }, { "hash": "tFoYPh0fXaZR3uXybAqFEOGnQuQsvz-E-Yq-CtrFlIY", "pascalName": "Frame", "kebabName": "frame", "path": "/Users/xiaoyou/Desktop/chronoframe/node_modules/.pnpm/nuxt-og-image@5.1.12_@unhead+vue@2.1.1_vue@3.5.26_typescript@5.9.3___h3@1.15.4_magicast_cc5ffa53446ac9a9d3e84ffe6464de21/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/Frame.vue", "category": "community" }, { "hash": "NPQTTXYQ8toXx5OaJ1VlRUUcxy1SNOxg-FoM7C08ZPM", "pascalName": "Nuxt", "kebabName": "nuxt", "path": "/Users/xiaoyou/Desktop/chronoframe/node_modules/.pnpm/nuxt-og-image@5.1.12_@unhead+vue@2.1.1_vue@3.5.26_typescript@5.9.3___h3@1.15.4_magicast_cc5ffa53446ac9a9d3e84ffe6464de21/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/Nuxt.vue", "category": "community" }, { "hash": "VAHSTZlVcPHzkozocV1iTnwc4-YttdoOkHsYfoSgDZ4", "pascalName": "NuxtSeo", "kebabName": "nuxt-seo", "path": "/Users/xiaoyou/Desktop/chronoframe/node_modules/.pnpm/nuxt-og-image@5.1.12_@unhead+vue@2.1.1_vue@3.5.26_typescript@5.9.3___h3@1.15.4_magicast_cc5ffa53446ac9a9d3e84ffe6464de21/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/NuxtSeo.vue", "category": "community" }, { "hash": "8CNn4yU043gQFqO-sZNDPz9GKED-h7ahXJ-61c9ThHM", "pascalName": "Pergel", "kebabName": "pergel", "path": "/Users/xiaoyou/Desktop/chronoframe/node_modules/.pnpm/nuxt-og-image@5.1.12_@unhead+vue@2.1.1_vue@3.5.26_typescript@5.9.3___h3@1.15.4_magicast_cc5ffa53446ac9a9d3e84ffe6464de21/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/Pergel.vue", "category": "community" }, { "hash": "b-Juo-FXQepo6SOCnA478MTAqbXNZuve6-MzHgTKA7s", "pascalName": "SimpleBlog", "kebabName": "simple-blog", "path": "/Users/xiaoyou/Desktop/chronoframe/node_modules/.pnpm/nuxt-og-image@5.1.12_@unhead+vue@2.1.1_vue@3.5.26_typescript@5.9.3___h3@1.15.4_magicast_cc5ffa53446ac9a9d3e84ffe6464de21/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/SimpleBlog.vue", "category": "community" }, { "hash": "vRUm5ru-64PEHIGsBby6-vCgLBg7iUJfvFKL6VuCXtI", "pascalName": "UnJs", "kebabName": "un-js", "path": "/Users/xiaoyou/Desktop/chronoframe/node_modules/.pnpm/nuxt-og-image@5.1.12_@unhead+vue@2.1.1_vue@3.5.26_typescript@5.9.3___h3@1.15.4_magicast_cc5ffa53446ac9a9d3e84ffe6464de21/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/UnJs.vue", "category": "community" }, { "hash": "hq07GBU-Yd16ICfETt8SfSxfaYj3qBmDAiQkTcv89nw", "pascalName": "Wave", "kebabName": "wave", "path": "/Users/xiaoyou/Desktop/chronoframe/node_modules/.pnpm/nuxt-og-image@5.1.12_@unhead+vue@2.1.1_vue@3.5.26_typescript@5.9.3___h3@1.15.4_magicast_cc5ffa53446ac9a9d3e84ffe6464de21/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/Wave.vue", "category": "community" }, { "hash": "zSwOodBXcjwS1qvFqGBJqitTEEnrvVfwQYkTeIxNpws", "pascalName": "WithEmoji", "kebabName": "with-emoji", "path": "/Users/xiaoyou/Desktop/chronoframe/node_modules/.pnpm/nuxt-og-image@5.1.12_@unhead+vue@2.1.1_vue@3.5.26_typescript@5.9.3___h3@1.15.4_magicast_cc5ffa53446ac9a9d3e84ffe6464de21/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/WithEmoji.vue", "category": "community" }];
function generateMeta(url, resolvedOptions) {
  const meta = [
    { property: "og:image", content: url },
    { property: "og:image:type", content: () => `image/${getExtension(toValue(url)) || resolvedOptions.extension}` },
    { name: "twitter:card", content: "summary_large_image" },
    // we don't need this but avoids issue when using useSeoMeta({ twitterImage })
    { name: "twitter:image", content: url },
    { name: "twitter:image:src", content: url }
  ];
  if (resolvedOptions.width) {
    meta.push({ property: "og:image:width", content: resolvedOptions.width });
    meta.push({ name: "twitter:image:width", content: resolvedOptions.width });
  }
  if (resolvedOptions.height) {
    meta.push({ property: "og:image:height", content: resolvedOptions.height });
    meta.push({ name: "twitter:image:height", content: resolvedOptions.height });
  }
  if (resolvedOptions.alt) {
    meta.push({ property: "og:image:alt", content: resolvedOptions.alt });
    meta.push({ name: "twitter:image:alt", content: resolvedOptions.alt });
  }
  return meta;
}
function isInternalRoute(path) {
  return path.startsWith("/_") || path.startsWith("@");
}
function filterIsOgImageOption(key) {
  const keys = [
    "url",
    "extension",
    "width",
    "height",
    "fonts",
    "alt",
    "props",
    "renderer",
    "html",
    "component",
    "renderer",
    "emojis",
    "_query",
    "satori",
    "resvg",
    "sharp",
    "screenshot",
    "cacheMaxAgeSeconds"
  ];
  return keys.includes(key);
}
function separateProps(options, ignoreKeys = []) {
  options = options || {};
  const _props = defu(options.props, Object.fromEntries(
    Object.entries({ ...options }).filter(([k2]) => !filterIsOgImageOption(k2) && !ignoreKeys.includes(k2))
  ));
  const props = {};
  Object.entries(_props).forEach(([key, val]) => {
    props[key.replace(/-([a-z])/g, (g2) => String(g2[1]).toUpperCase())] = val;
  });
  return {
    ...Object.fromEntries(
      Object.entries({ ...options }).filter(([k2]) => filterIsOgImageOption(k2) || ignoreKeys.includes(k2))
    ),
    props
  };
}
function withoutQuery(path) {
  return path.split("?")[0];
}
function getExtension(path) {
  path = withoutQuery(path);
  const lastSegment = path.split("/").pop() || path;
  const extension = lastSegment.split(".").pop() || lastSegment;
  if (extension === "jpg")
    return "jpeg";
  return extension;
}
function setHeadOgImagePrebuilt(input) {
  const url = input.url;
  if (!url)
    return;
  const meta = generateMeta(url, input);
  useHead({ meta }, { tagPriority: "high" });
}
function createOgImageMeta(src, input, ssrContext) {
  const { defaults } = useOgImageRuntimeConfig();
  const _input = separateProps(defu(input, ssrContext._ogImagePayload));
  if (input._query && Object.keys(input._query).length)
    src = withQuery(src, { _query: input._query });
  const meta = generateMeta(src, input);
  ssrContext._ogImageInstances = ssrContext._ogImageInstances || [];
  const script = [];
  if (src) {
    script.push({
      id: "nuxt-og-image-options",
      type: "application/json",
      processTemplateParams: true,
      innerHTML: () => {
        const payload = resolveUnrefHeadInput(_input);
        if (payload.props && typeof payload.props.title === "undefined")
          payload.props.title = "%s";
        payload.component = resolveComponentName(input.component, defaults.component || "");
        delete payload.url;
        if (payload._query && Object.keys(payload._query).length === 0) {
          delete payload._query;
        }
        const final = {};
        for (const k2 in payload) {
          if (payload[k2] !== defaults[k2]) {
            final[k2] = payload[k2];
          }
        }
        return stringify(final);
      },
      // we want this to be last in our head
      tagPosition: "bodyClose"
    });
  }
  const instance = useHead({
    script,
    meta
  }, {
    tagPriority: "high"
  });
  ssrContext._ogImagePayload = _input;
  ssrContext._ogImageInstances.push(instance);
}
function resolveComponentName(component, fallback) {
  component = component || fallback || componentNames?.[0]?.pascalName;
  if (component && componentNames) {
    const originalName = component;
    for (const component2 of componentNames) {
      if (component2.pascalName.endsWith(originalName) || component2.kebabName.endsWith(originalName)) {
        return component2.pascalName;
      }
    }
  }
  return component;
}
function getOgImagePath(pagePath, _options) {
  const baseURL2 = (/* @__PURE__ */ useRuntimeConfig()).app.baseURL;
  const extension = _options?.extension || useOgImageRuntimeConfig().defaults?.extension || "png";
  const path = joinURL("/", baseURL2, `__og-image__/${"image"}`, pagePath, `og.${extension}`);
  if (Object.keys(_options?._query || {}).length) {
    return withQuery(path, _options._query);
  }
  return path;
}
function useOgImageRuntimeConfig() {
  const c2 = /* @__PURE__ */ useRuntimeConfig();
  return {
    defaults: {},
    ...c2["nuxt-og-image"],
    app: {
      baseURL: c2.app.baseURL
    }
  };
}
function ogImageCanonicalUrls(nuxtApp) {
  nuxtApp.hooks.hook("app:rendered", async (ctx) => {
    const { ssrContext } = ctx;
    const e = useRequestEvent();
    const path = parseURL(e?.path || "").pathname;
    if (isInternalRoute(path))
      return;
    ssrContext?.head.use(TemplateParamsPlugin);
    ssrContext?.head.use({
      key: "nuxt-og-image:overrides-and-canonical-urls",
      hooks: {
        "tags:resolve": async (ctx2) => {
          const hasPrimaryPayload = ctx2.tags.some((tag) => tag.tag === "script" && tag.props.id === "nuxt-og-image-options");
          let overrides;
          for (const tag of ctx2.tags) {
            if (tag.tag === "script" && tag.props.id === "nuxt-og-image-overrides") {
              if (hasPrimaryPayload) {
                overrides = separateProps(parse$2(tag.innerHTML || "{}"));
                delete ctx2.tags[ctx2.tags.indexOf(tag)];
              } else {
                tag.props.id = "nuxt-og-image-options";
                tag.innerHTML = stringify(separateProps(parse$2(tag.innerHTML || "{}")));
                tag._d = "script:id:nuxt-og-image-options";
              }
              break;
            }
          }
          ctx2.tags = ctx2.tags.filter(Boolean);
          for (const tag of ctx2.tags) {
            if (tag.tag === "meta" && (tag.props.property === "og:image" || ["twitter:image:src", "twitter:image"].includes(tag.props.name || ""))) {
              if (!tag.props.content) {
                tag.props = {};
                continue;
              }
              if (!tag.props.content?.startsWith("https")) {
                await nuxtApp.runWithContext(() => {
                  tag.props.content = toValue(withSiteUrl(tag.props.content || "", {
                    withBase: true
                  }));
                });
              }
            } else if (overrides && tag.tag === "script" && tag.props.id === "nuxt-og-image-options") {
              tag.innerHTML = stringify(defu(overrides, parse$2(tag.innerHTML || "{}")));
            }
          }
        }
      }
    });
  });
}
function routeRuleOgImage(nuxtApp) {
  nuxtApp.hooks.hook("app:rendered", async (ctx) => {
    const { ssrContext } = ctx;
    const e = useRequestEvent();
    const path = parseURL(e?.path || "").pathname;
    if (isInternalRoute(path))
      return;
    const _routeRulesMatcher = toRouteMatcher(
      createRouter$1({ routes: ssrContext?.runtimeConfig?.nitro?.routeRules })
    );
    const matchedRules = _routeRulesMatcher.matchAll(
      withoutBase(path.split("?")?.[0] || "", ssrContext?.runtimeConfig?.app.baseURL || "")
    ).reverse();
    const combinedRules = defu({}, ...matchedRules);
    let routeRules = combinedRules?.ogImage;
    if (typeof routeRules === "undefined")
      return;
    const ogImageInstances = nuxtApp.ssrContext._ogImageInstances || [];
    if (routeRules === false) {
      ogImageInstances?.forEach((e2) => {
        e2.dispose();
      });
      nuxtApp.ssrContext._ogImagePayload = void 0;
      nuxtApp.ssrContext._ogImageInstances = void 0;
      return;
    }
    routeRules = defu(nuxtApp.ssrContext?.event?.context._nitro?.routeRules?.ogImage, routeRules);
    const src = getOgImagePath(ssrContext.url, routeRules);
    createOgImageMeta(src, routeRules, nuxtApp.ssrContext);
  });
}
const og_image_canonical_urls_server__SJeLZ8IhvQn4NsLhTaSDpX_JsYyby10BokME_5_Ixw = /* @__PURE__ */ defineNuxtPlugin({
  setup(nuxtApp) {
    ogImageCanonicalUrls(nuxtApp);
  }
});
const route_rule_og_image_server_fMUHedIg6IJyGlkb3J1ti72d0MoUU_RE87zkn2NS9gA = /* @__PURE__ */ defineNuxtPlugin({
  setup(nuxtApp) {
    routeRuleOgImage(nuxtApp);
  }
});
const i18nPluginDeps = ["i18n:plugin", "i18n:plugin:ssg-detect", "i18n:plugin:route-locale-detect"];
const i18n_sNLfHumFZpeSKAqN31zGP6UN5uEbL7CZMNGvEiTqVUU = /* @__PURE__ */ defineNuxtPlugin({
  name: "nuxt-site-config:i18n",
  dependsOn: i18nPluginDeps,
  setup(nuxtApp) {
    const i18n = nuxtApp.$i18n;
    if (!i18n)
      return;
    const stack = useRequestEvent()?.context.siteConfig;
    const i18nBaseUrl = toValue(i18n.baseUrl);
    if (i18nBaseUrl) {
      const siteConfig = stack.get({ resolveRefs: true });
      const currentUrl = siteConfig.url;
      if (currentUrl && !currentUrl.includes("localhost")) {
        const i18nURL = parseURL(i18nBaseUrl, "https://");
        const siteConfigURL = parseURL(currentUrl, "https://");
        if (i18nURL.host !== siteConfigURL.host) {
          if (siteConfig.env === "production") {
            console.error(`[Nuxt Site Config] Your I18n baseUrl \`${i18nURL.host}\` doesn't match your site url ${siteConfigURL.host}. This will cause production SEO issues. Either provide a matching baseUrl or remove the site url config.`);
          }
        }
      }
    }
    let siteConfigEntry;
    watch(i18n.locale, () => {
      if (siteConfigEntry) {
        siteConfigEntry();
      }
      const defaultLocale = computed(() => {
        const locale = toValue(i18n.locales).find((l) => l.code === i18n.defaultLocale);
        return locale?.language || locale?.iso || i18n.defaultLocale;
      });
      siteConfigEntry = stack.push({
        _priority: -2,
        _context: "@nuxtjs/i18n",
        url: computed(() => {
          const url = toValue(i18n.baseUrl);
          return url || void 0;
        }),
        defaultLocale,
        currentLocale: computed(() => {
          const properties = toValue(i18n.localeProperties);
          if (properties.language) {
            return properties.language;
          }
          return defaultLocale.value;
        }),
        // @ts-expect-error untyped
        description: computed(() => i18n.te("nuxtSiteConfig.description") ? i18n.t("nuxtSiteConfig.description") : void 0),
        // @ts-expect-error untyped
        name: computed(() => i18n.te("nuxtSiteConfig.name") ? i18n.t("nuxtSiteConfig.name") : void 0)
      });
    }, {
      immediate: true
    });
  }
});
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
const makeSymbol = (name2, shareable = false) => !shareable ? Symbol(name2) : Symbol.for(name2);
const generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
const friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
const isNumber$3 = (val) => typeof val === "number" && isFinite(val);
const isDate = (val) => toTypeString(val) === "[object Date]";
const isRegExp = (val) => toTypeString(val) === "[object RegExp]";
const isEmptyObject$1 = (val) => isPlainObject(val) && Object.keys(val).length === 0;
const assign = Object.assign;
const _create = Object.create;
const create = (obj = null) => _create(obj);
function escapeHtml(rawText) {
  return rawText.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/\//g, "&#x2F;").replace(/=/g, "&#x3D;");
}
function escapeAttributeValue(value) {
  return value.replace(/&(?![a-zA-Z0-9#]{2,6};)/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function sanitizeTranslatedHtml(html) {
  html = html.replace(/(\w+)\s*=\s*"([^"]*)"/g, (_2, attrName, attrValue) => `${attrName}="${escapeAttributeValue(attrValue)}"`);
  html = html.replace(/(\w+)\s*=\s*'([^']*)'/g, (_2, attrName, attrValue) => `${attrName}='${escapeAttributeValue(attrValue)}'`);
  const eventHandlerPattern = /\s*on\w+\s*=\s*["']?[^"'>]+["']?/gi;
  if (eventHandlerPattern.test(html)) {
    html = html.replace(/(\s+)(on)(\w+\s*=)/gi, "$1&#111;n$3");
  }
  const javascriptUrlPattern = [
    // In href, src, action, formaction attributes
    /(\s+(?:href|src|action|formaction)\s*=\s*["']?)\s*javascript:/gi,
    // In style attributes within url()
    /(style\s*=\s*["'][^"']*url\s*\(\s*)javascript:/gi
  ];
  javascriptUrlPattern.forEach((pattern) => {
    html = html.replace(pattern, "$1javascript&#58;");
  });
  return html;
}
const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
const isArray = Array.isArray;
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isBoolean = (val) => typeof val === "boolean";
const isObject$3 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$3(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const toDisplayString = (val) => {
  return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
function join(items, separator2 = "") {
  return items.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator2 + item, "");
}
const isNotObjectOrIsArray = (val) => !isObject$3(val) || isArray(val);
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack = [{ src, des }];
  while (stack.length) {
    const { src: src2, des: des2 } = stack.pop();
    Object.keys(src2).forEach((key) => {
      if (key === "__proto__") {
        return;
      }
      if (isObject$3(src2[key]) && !isObject$3(des2[key])) {
        des2[key] = Array.isArray(src2[key]) ? [] : create();
      }
      if (isNotObjectOrIsArray(des2[key]) || isNotObjectOrIsArray(src2[key])) {
        des2[key] = src2[key];
      } else {
        stack.push({ src: src2[key], des: des2[key] });
      }
    });
  }
}
function localeHead$1(options, currentLanguage = options.getCurrentLanguage(), currentDirection = options.getCurrentDirection()) {
  const metaObject = {
    htmlAttrs: {},
    link: [],
    meta: []
  };
  if (options.dir) {
    metaObject.htmlAttrs.dir = currentDirection;
  }
  if (options.lang && currentLanguage) {
    metaObject.htmlAttrs.lang = currentLanguage;
  }
  if (options.seo) {
    const alternateLinks = getHreflangLinks(options);
    metaObject.link = metaObject.link.concat(
      alternateLinks,
      getCanonicalLink(options)
    );
    metaObject.meta = metaObject.meta.concat(
      getOgUrl(options),
      getCurrentOgLocale(options),
      getAlternateOgLocales(
        options,
        options.locales.map((x) => x.language || x.code)
      )
    );
  }
  return metaObject;
}
function createLocaleMap(locales) {
  const localeMap = /* @__PURE__ */ new Map();
  for (const locale of locales) {
    if (!locale.language) {
      console.warn("Locale `language` ISO code is required to generate alternate link");
      continue;
    }
    const [language, region] = locale.language.split("-");
    if (language && region && (locale.isCatchallLocale || !localeMap.has(language))) {
      localeMap.set(language, locale);
    }
    localeMap.set(locale.language, locale);
  }
  return localeMap;
}
function getHreflangLinks(options) {
  if (!options.hreflangLinks) return [];
  const links = [];
  const localeMap = createLocaleMap(options.locales);
  for (const [language, locale] of localeMap.entries()) {
    const link = getHreflangLink(language, locale, options);
    if (!link) continue;
    links.push(link);
    if (options.defaultLocale && options.defaultLocale === locale.code && links[0].hreflang !== "x-default") {
      links.unshift(
        { [options.key]: "i18n-xd", rel: "alternate", href: link.href, hreflang: "x-default" }
      );
    }
  }
  return links;
}
function getHreflangLink(language, locale, options, routeWithoutQuery = options.strictCanonicals ? options.getRouteWithoutQuery() : void 0) {
  const localePath2 = options.getLocalizedRoute(locale.code, routeWithoutQuery);
  if (!localePath2) return void 0;
  const href = withQuery(
    hasProtocol(localePath2) ? localePath2 : joinURL(options.baseUrl, localePath2),
    options.strictCanonicals ? getCanonicalQueryParams(options) : {}
  );
  return { [options.key]: `i18n-alt-${language}`, rel: "alternate", href, hreflang: language };
}
function getCanonicalUrl(options, route = options.getCurrentRoute()) {
  const currentRoute = options.getLocaleRoute(
    Object.assign({}, route, { path: void 0, name: options.getRouteBaseName(route) })
  );
  if (!currentRoute) return "";
  return withQuery(joinURL(options.baseUrl, currentRoute.path), getCanonicalQueryParams(options));
}
function getCanonicalLink(options, href = getCanonicalUrl(options)) {
  if (!href) return [];
  return [{ [options.key]: "i18n-can", rel: "canonical", href }];
}
function getCanonicalQueryParams(options, route = options.getCurrentRoute()) {
  const currentRoute = options.getLocaleRoute(
    Object.assign({}, route, { path: void 0, name: options.getRouteBaseName(route) })
  );
  const currentRouteQuery = currentRoute?.query ?? {};
  const params = {};
  for (const param of options.canonicalQueries.filter((x) => x in currentRouteQuery)) {
    params[param] ??= [];
    for (const val of toArray$3(currentRouteQuery[param])) {
      params[param].push(val || "");
    }
  }
  return params;
}
function getOgUrl(options, href = getCanonicalUrl(options)) {
  if (!href) return [];
  return [
    { [options.key]: "i18n-og-url", property: "og:url", content: href }
  ];
}
function getCurrentOgLocale(options, currentLanguage = options.getCurrentLanguage()) {
  if (!currentLanguage) return [];
  return [
    { [options.key]: "i18n-og", property: "og:locale", content: formatOgLanguage(currentLanguage) }
  ];
}
function getAlternateOgLocales(options, languages, currentLanguage = options.getCurrentLanguage()) {
  const alternateLocales = languages.filter((locale) => locale && locale !== currentLanguage);
  return alternateLocales.map(
    (locale) => ({
      [options.key]: `i18n-og-alt-${locale}`,
      property: "og:locale:alternate",
      content: formatOgLanguage(locale)
    })
  );
}
function formatOgLanguage(val = "") {
  return val.replace(/-/g, "_");
}
function toArray$3(value) {
  return Array.isArray(value) ? value : [value];
}
function localePath(ctx, route, locale = ctx.getLocale()) {
  if (isString(route) && hasProtocol(route, { acceptRelative: true })) {
    return route;
  }
  try {
    return resolveRoute(ctx, route, locale).fullPath;
  } catch {
    return "";
  }
}
function localeRoute(ctx, route, locale = ctx.getLocale()) {
  try {
    return resolveRoute(ctx, route, locale);
  } catch {
    return;
  }
}
function normalizeRawLocation(route) {
  if (!isString(route)) {
    return assign({}, route);
  }
  if (route[0] === "/") {
    const { pathname: path, search, hash: hash2 } = parsePath(route);
    return { path, query: parseQuery(search), hash: hash2 };
  }
  return { name: route };
}
function resolveRoute(ctx, route, locale) {
  const normalized = normalizeRawLocation(route);
  const resolved = ctx.router.resolve(ctx.resolveLocalizedRouteObject(normalized, locale));
  if (resolved.name) {
    return resolved;
  }
  return ctx.router.resolve(route);
}
function switchLocalePath(ctx, locale, route = ctx.router.currentRoute.value) {
  const name2 = ctx.getRouteBaseName(route);
  if (!name2) {
    return "";
  }
  const routeCopy = {
    name: name2,
    params: assign({}, route.params, ctx.getLocalizedDynamicParams(locale)),
    fullPath: route.fullPath,
    query: route.query,
    hash: route.hash,
    path: route.path,
    meta: route.meta
  };
  const path = localePath(ctx, routeCopy, locale);
  return ctx.afterSwitchLocalePath(path, locale);
}
function createHeadContext(ctx, config, locale = ctx.getLocale(), locales = ctx.getLocales(), baseUrl = ctx.getBaseUrl()) {
  const currentLocale = locales.find((l) => l.code === locale) || {};
  const canonicalQueries = typeof config.seo === "object" && config.seo?.canonicalQueries || [];
  if (!baseUrl && true && true) {
    console.warn("I18n `baseUrl` is required to generate valid SEO tag links.");
  }
  return {
    ...config,
    key: "id",
    locales,
    baseUrl,
    canonicalQueries,
    hreflangLinks: ctx.routingOptions.hreflangLinks,
    defaultLocale: ctx.routingOptions.defaultLocale,
    strictCanonicals: ctx.routingOptions.strictCanonicals,
    getRouteBaseName: ctx.getRouteBaseName,
    getCurrentRoute: () => ctx.router.currentRoute.value,
    getCurrentLanguage: () => currentLocale.language,
    getCurrentDirection: () => currentLocale.dir || "ltr",
    getLocaleRoute: (route) => localeRoute(ctx, route),
    getLocalizedRoute: (locale2, route) => switchLocalePath(ctx, locale2, route),
    getRouteWithoutQuery: () => {
      try {
        return assign({}, ctx.router.resolve({ query: {} }), { meta: ctx.router.currentRoute.value.meta });
      } catch {
        return void 0;
      }
    }
  };
}
function localeHead(ctx, { dir = true, lang = true, seo = true }) {
  return localeHead$1(createHeadContext(ctx, { dir, lang, seo }));
}
function parseAcceptLanguage(value) {
  return value.split(",").map((tag) => tag.split(";")[0]).filter(
    (tag) => !(tag === "*" || tag === "")
  );
}
function createPathIndexLanguageParser(index2 = 0) {
  return (path) => {
    const rawPath = typeof path === "string" ? path : path.pathname;
    const normalizedPath = rawPath.split("?")[0];
    const parts = normalizedPath.split("/");
    if (parts[0] === "") {
      parts.shift();
    }
    return parts.length > index2 ? parts[index2] || "" : "";
  };
}
const separator$1 = "___";
function normalizeRouteName(routeName) {
  if (typeof routeName === "string") return routeName;
  if (routeName != null) return routeName.toString();
  return "";
}
function getRouteBaseName(route) {
  return normalizeRouteName(typeof route === "object" ? route?.name : route).split(separator$1)[0];
}
const pathLanguageParser = createPathIndexLanguageParser(0);
const getLocaleFromRoutePath = (path) => pathLanguageParser(path);
const getLocaleFromRouteName = (name2) => name2.split(separator$1).at(1) ?? "";
function normalizeInput(input) {
  return typeof input !== "object" ? String(input) : String(input?.name || input?.path || "");
}
function getLocaleFromRoute(route) {
  const input = normalizeInput(route);
  return input[0] === "/" ? getLocaleFromRoutePath(input) : getLocaleFromRouteName(input);
}
function createLocaleRouteNameGetter(defaultLocale) {
  {
    return (routeName) => normalizeRouteName(routeName);
  }
}
function createLocalizedRouteByPathResolver(router) {
  {
    return (route) => route;
  }
}
const localeCodes = [
  "zh-Hans",
  "zh-Hant-TW",
  "zh-Hant-HK",
  "en",
  "ja"
];
const localeLoaders = {
  "zh-Hans": [
    {
      key: "locale_zh_45Hans_46json_64a8294e",
      load: () => import(
        './zh-Hans-Dotp3207.mjs'
        /* webpackChunkName: "locale_zh_45Hans_46json_64a8294e" */
      ),
      cache: true
    }
  ],
  "zh-Hant-TW": [
    {
      key: "locale_zh_45Hant_45TW_46json_0939d749",
      load: () => import(
        './zh-Hant-TW-C4SRjvc8.mjs'
        /* webpackChunkName: "locale_zh_45Hant_45TW_46json_0939d749" */
      ),
      cache: true
    }
  ],
  "zh-Hant-HK": [
    {
      key: "locale_zh_45Hant_45HK_46json_aa8eae12",
      load: () => import(
        './zh-Hant-HK-CRqlY5zH.mjs'
        /* webpackChunkName: "locale_zh_45Hant_45HK_46json_aa8eae12" */
      ),
      cache: true
    }
  ],
  en: [
    {
      key: "locale_en_46json_838264ce",
      load: () => import(
        './en-vytBIx0D.mjs'
        /* webpackChunkName: "locale_en_46json_838264ce" */
      ),
      cache: true
    }
  ],
  ja: [
    {
      key: "locale_ja_46json_7a7620f8",
      load: () => import(
        './ja-gvXKROiH.mjs'
        /* webpackChunkName: "locale_ja_46json_7a7620f8" */
      ),
      cache: true
    }
  ]
};
const vueI18nConfigs = [
  () => import(
    './i18n.config-CxAnQks5.mjs'
    /* webpackChunkName: "config_i18n_46config_46ts_489b3db7" */
  )
];
const normalizedLocales = [
  {
    code: "zh-Hans",
    name: "简体中文",
    language: "zh"
  },
  {
    code: "zh-Hant-TW",
    name: "繁体中文(台湾)",
    language: "zh-TW"
  },
  {
    code: "zh-Hant-HK",
    name: "繁体中文(香港)",
    language: "zh-HK"
  },
  {
    code: "en",
    name: "English",
    language: "en"
  },
  {
    code: "ja",
    name: "日本語",
    language: "ja"
  }
];
const cacheMessages = /* @__PURE__ */ new Map();
const merger = createDefu((obj, key, value) => {
  if (key === "messages" || key === "datetimeFormats" || key === "numberFormats") {
    obj[key] ??= create(null);
    deepCopy(value, obj[key]);
    return true;
  }
});
async function loadVueI18nOptions(vueI18nConfigs2) {
  const nuxtApp = useNuxtApp();
  let vueI18nOptions = { messages: create(null) };
  for (const configFile of vueI18nConfigs2) {
    const resolver = await configFile().then((x) => x.default);
    const resolved = isFunction(resolver) ? await nuxtApp.runWithContext(() => resolver()) : resolver;
    vueI18nOptions = merger(create(null), resolved, vueI18nOptions);
  }
  vueI18nOptions.fallbackLocale ??= false;
  return vueI18nOptions;
}
const isModule = (val) => toTypeString(val) === "[object Module]";
const isResolvedModule = (val) => isModule(val) || true;
async function getLocaleMessages$1(locale, loader) {
  const nuxtApp = useNuxtApp();
  try {
    const getter = await nuxtApp.runWithContext(loader.load).then((x) => isResolvedModule(x) ? x.default : x);
    return isFunction(getter) ? await nuxtApp.runWithContext(() => getter(locale)) : getter;
  } catch (e) {
    throw new Error(`Failed loading locale (${locale}): ` + e.message);
  }
}
async function getLocaleMessagesMergedCached(locale, loaders = []) {
  const nuxtApp = useNuxtApp();
  const merged = {};
  for (const loader of loaders) {
    const cached = getCachedMessages(loader);
    const messages = cached || await nuxtApp.runWithContext(async () => await getLocaleMessages$1(locale, loader));
    if (!cached && loader.cache !== false) {
      cacheMessages.set(loader.key, { ttl: Date.now() + 86400 * 1e3, value: messages });
    }
    deepCopy(messages, merged);
  }
  return merged;
}
function getCachedMessages(loader) {
  if (loader.cache === false) return;
  const cache2 = cacheMessages.get(loader.key);
  if (cache2 == null) return;
  return cache2.ttl > Date.now() ? cache2.value : void 0;
}
function getI18nTarget(i18n) {
  return i18n != null && "global" in i18n && "mode" in i18n ? i18n.global : i18n;
}
function getComposer$3(i18n) {
  const target = getI18nTarget(i18n);
  return "__composer" in target ? target.__composer : target;
}
function useRuntimeI18n(nuxtApp) {
  if (!nuxtApp) {
    return (/* @__PURE__ */ useRuntimeConfig()).public.i18n;
  }
  return nuxtApp.$config.public.i18n;
}
function useI18nDetection(nuxtApp) {
  const detectBrowserLanguage = useRuntimeI18n(nuxtApp).detectBrowserLanguage;
  const detect = detectBrowserLanguage || {};
  return {
    ...detect,
    enabled: !!detectBrowserLanguage,
    cookieKey: detect.cookieKey || "i18n_redirected"
  };
}
function resolveRootRedirect(config) {
  if (!config) return void 0;
  return {
    path: "/" + (isString(config) ? config : config.path).replace(/^\//, ""),
    code: !isString(config) && config.statusCode || 302
  };
}
function toArray$2(value) {
  return Array.isArray(value) ? value : [value];
}
function matchDomainLocale(locales, host, pathLocale) {
  const normalizeDomain = (domain = "") => domain.replace(/https?:\/\//, "");
  const matches = locales.filter(
    (locale) => normalizeDomain(locale.domain) === host || toArray$2(locale.domains).includes(host)
  );
  if (matches.length <= 1) {
    return matches[0]?.code;
  }
  return (
    // match by current path locale
    matches.find((l) => l.code === pathLocale)?.code || // fallback to default locale for the domain
    matches.find((l) => l.defaultForDomains?.includes(host) ?? l.domainDefault)?.code
  );
}
function domainFromLocale(domainLocales, url, locale) {
  const lang = normalizedLocales.find((x) => x.code === locale);
  const domain = domainLocales?.[locale]?.domain || lang?.domain || lang?.domains?.find((v) => v === url.host);
  if (!domain) {
    return;
  }
  if (hasProtocol(domain, { strict: true })) {
    return domain;
  }
  return url.protocol + "//" + domain;
}
function getDefaultLocaleForDomain(host) {
  return normalizedLocales.find((l) => !!l.defaultForDomains?.includes(host))?.code;
}
const isSupportedLocale = (locale) => localeCodes.includes(locale || "");
const resolveSupportedLocale = (locale) => isSupportedLocale(locale) ? locale : void 0;
const useLocaleConfigs = () => useState(
  "i18n:cached-locale-configs",
  () => void 0
);
const useResolvedLocale = () => useState("i18n:resolved-locale", () => "");
function useI18nCookie({ cookieCrossOrigin, cookieDomain, cookieSecure, cookieKey }) {
  const date = /* @__PURE__ */ new Date();
  return useCookie(cookieKey, {
    path: "/",
    readonly: false,
    expires: new Date(date.setDate(date.getDate() + 365)),
    sameSite: cookieCrossOrigin ? "none" : "lax",
    domain: cookieDomain || void 0,
    secure: cookieCrossOrigin || cookieSecure
  });
}
function createNuxtI18nContext(nuxt, vueI18n, defaultLocale) {
  const i18n = getI18nTarget(vueI18n);
  const runtimeI18n = useRuntimeI18n(nuxt);
  const detectConfig = useI18nDetection(nuxt);
  const serverLocaleConfigs = useLocaleConfigs();
  const localeCookie = useI18nCookie(detectConfig);
  const getLocaleConfig = (locale) => serverLocaleConfigs.value[locale];
  const getDomainFromLocale = (locale) => domainFromLocale(runtimeI18n.domainLocales, useRequestURL({ xForwardedHost: true }), locale);
  const baseUrl = createBaseUrlGetter(nuxt, runtimeI18n.baseUrl);
  const resolvedLocale = useResolvedLocale();
  if (nuxt.ssrContext?.event?.context?.nuxtI18n?.detectLocale) {
    resolvedLocale.value = nuxt.ssrContext.event.context.nuxtI18n.detectLocale;
  }
  const loadMessagesFromClient = async (locale) => {
    const locales = getLocaleConfig(locale)?.fallbacks ?? [];
    if (!locales.includes(locale)) locales.push(locale);
    for (const k2 of locales) {
      const msg = await nuxt.runWithContext(() => getLocaleMessagesMergedCached(k2, localeLoaders[k2]));
      i18n.mergeLocaleMessage(k2, msg);
    }
  };
  const loadMessagesFromServer = async (locale) => {
    if (locale in localeLoaders === false) return;
    const headers = getLocaleConfig(locale)?.cacheable ? {} : { "Cache-Control": "no-cache" };
    const messages = await $fetch(`/_i18n/${"2U3Am7DZ"}/${locale}/messages.json`, { headers });
    for (const k2 of Object.keys(messages)) {
      i18n.mergeLocaleMessage(k2, messages[k2]);
    }
  };
  const ctx = {
    vueI18n,
    initial: true,
    preloaded: false,
    config: runtimeI18n,
    rootRedirect: resolveRootRedirect(runtimeI18n.rootRedirect),
    redirectStatusCode: runtimeI18n.redirectStatusCode ?? 302,
    dynamicResourcesSSG: false,
    getDefaultLocale: () => defaultLocale,
    getLocale: () => unref(i18n.locale),
    setLocale: async (locale) => {
      const oldLocale = ctx.getLocale();
      if (locale === oldLocale || !isSupportedLocale(locale)) return;
      if (isRef(i18n.locale)) {
        i18n.locale.value = locale;
      } else {
        i18n.locale = locale;
      }
      await nuxt.callHook("i18n:localeSwitched", { newLocale: locale, oldLocale });
      resolvedLocale.value = locale;
    },
    setLocaleSuspend: async (locale) => {
      if (!isSupportedLocale(locale)) return;
      ctx.vueI18n.__pendingLocale = locale;
      ctx.vueI18n.__pendingLocalePromise = new Promise((resolve) => {
        ctx.vueI18n.__resolvePendingLocalePromise = async () => {
          ctx.setCookieLocale(locale);
          await ctx.setLocale(locale);
          ctx.vueI18n.__pendingLocale = void 0;
          resolve();
        };
      });
      {
        await ctx.vueI18n.__resolvePendingLocalePromise?.();
      }
    },
    getLocales: () => unref(i18n.locales).map((x) => isString(x) ? { code: x } : x),
    setCookieLocale: (locale) => {
      if (detectConfig.useCookie && isSupportedLocale(locale)) {
        localeCookie.value = locale;
      }
    },
    getBaseUrl: (locale) => {
      if (locale) {
        return joinURL(getDomainFromLocale(locale) || baseUrl(), nuxt.$config.app.baseURL);
      }
      return joinURL(baseUrl(), nuxt.$config.app.baseURL);
    },
    loadMessages: async (locale) => {
      try {
        return ctx.dynamicResourcesSSG || false ? await loadMessagesFromClient(locale) : await loadMessagesFromServer(locale);
      } catch (e) {
        console.warn(`Failed to load messages for locale "${locale}"`, e);
      }
    },
    composableCtx: void 0
  };
  ctx.composableCtx = createComposableContext(ctx, nuxt);
  return ctx;
}
function useNuxtI18nContext(nuxt) {
  if (nuxt._nuxtI18n == null) {
    throw new Error("Nuxt I18n context has not been set up yet.");
  }
  return nuxt._nuxtI18n;
}
function matchBrowserLocale(locales, browserLocales) {
  const matchedLocales = [];
  for (const [index2, browserCode] of browserLocales.entries()) {
    const matchedLocale = locales.find((l) => l.language?.toLowerCase() === browserCode.toLowerCase());
    if (matchedLocale) {
      matchedLocales.push({ code: matchedLocale.code, score: 1 - index2 / browserLocales.length });
      break;
    }
  }
  for (const [index2, browserCode] of browserLocales.entries()) {
    const languageCode = browserCode.split("-")[0].toLowerCase();
    const matchedLocale = locales.find((l) => l.language?.split("-")[0].toLowerCase() === languageCode);
    if (matchedLocale) {
      matchedLocales.push({ code: matchedLocale.code, score: 0.999 - index2 / browserLocales.length });
      break;
    }
  }
  return matchedLocales;
}
function compareBrowserLocale(a, b) {
  if (a.score === b.score) {
    return b.code.length - a.code.length;
  }
  return b.score - a.score;
}
function findBrowserLocale(locales, browserLocales) {
  const matchedLocales = matchBrowserLocale(
    locales.map((l) => ({ code: l.code, language: l.language || l.code })),
    browserLocales
  );
  return matchedLocales.sort(compareBrowserLocale).at(0)?.code ?? "";
}
const getCookieLocale = (event, cookieName) => {
  const cookieValue = getRequestHeader(event, "cookie") || "";
  return parse$1(cookieValue)[cookieName];
};
const getRouteLocale = (event, route) => getLocaleFromRoute(route);
const getHeaderLocale = (event) => {
  return findBrowserLocale(normalizedLocales, parseAcceptLanguage(getRequestHeader(event, "accept-language") || ""));
};
const getHostLocale = (event, path, domainLocales) => {
  const host = getRequestURL(event, { xForwardedHost: true }).host;
  const locales = normalizedLocales.map((l) => ({
    ...l,
    domain: domainLocales[l.code]?.domain ?? l.domain
  }));
  return matchDomainLocale(locales, host, getLocaleFromRoutePath(path));
};
const useDetectors = (event, config, nuxtApp) => {
  if (!event) {
    throw new Error("H3Event is required for server-side locale detection");
  }
  const runtimeI18n = useRuntimeI18n(nuxtApp);
  return {
    cookie: () => getCookieLocale(event, config.cookieKey),
    header: () => getHeaderLocale(event),
    navigator: () => void 0,
    host: (path) => getHostLocale(event, path, runtimeI18n.domainLocales),
    route: (path) => getRouteLocale(event, path)
  };
};
const isRouteLocationPathRaw = (val) => !!val.path && !val.name;
function useComposableContext(nuxtApp) {
  const context = nuxtApp?._nuxtI18n?.composableCtx;
  if (!context) {
    throw new Error(
      "i18n context is not initialized. Ensure the i18n plugin is installed and the composable is used within a Vue component or setup function."
    );
  }
  return context;
}
const formatTrailingSlash = withoutTrailingSlash;
function createComposableContext(ctx, nuxtApp = useNuxtApp()) {
  const router = useRouter();
  useDetectors(useRequestEvent(), useI18nDetection(nuxtApp), nuxtApp);
  const defaultLocale = ctx.getDefaultLocale();
  const getLocalizedRouteName = createLocaleRouteNameGetter();
  function resolveLocalizedRouteByName(route, locale) {
    route.name ||= getRouteBaseName(router.currentRoute.value);
    const localizedName = getLocalizedRouteName(route.name, locale);
    if (router.hasRoute(localizedName)) {
      route.name = localizedName;
    }
    return route;
  }
  const routeByPathResolver = createLocalizedRouteByPathResolver();
  function resolveLocalizedRouteByPath(input, locale) {
    const route = routeByPathResolver(input, locale);
    const baseName = getRouteBaseName(route);
    if (baseName) {
      route.name = getLocalizedRouteName(baseName, locale);
      return route;
    }
    route.path = formatTrailingSlash(route.path, true);
    return route;
  }
  const composableCtx = {
    router,
    head: useHead({}),
    metaState: { htmlAttrs: {}, meta: [], link: [] },
    seoSettings: {
      dir: false,
      lang: false,
      seo: false
    },
    localePathPayload: getLocalePathPayload(),
    routingOptions: {
      defaultLocale,
      strictCanonicals: ctx.config.experimental.alternateLinkCanonicalQueries ?? true,
      hreflangLinks: false
    },
    getLocale: ctx.getLocale,
    getLocales: ctx.getLocales,
    getBaseUrl: ctx.getBaseUrl,
    getRouteBaseName,
    getRouteLocalizedParams: () => router.currentRoute.value.meta["nuxtI18nInternal"] ?? {},
    getLocalizedDynamicParams: (locale) => {
      return composableCtx.getRouteLocalizedParams()?.[locale];
    },
    afterSwitchLocalePath: (path, locale) => {
      composableCtx.getRouteLocalizedParams();
      return path;
    },
    resolveLocalizedRouteObject: (route, locale) => {
      return isRouteLocationPathRaw(route) ? resolveLocalizedRouteByPath(route, locale) : resolveLocalizedRouteByName(route, locale);
    }
  };
  return composableCtx;
}
function getLocalePathPayload(nuxtApp = useNuxtApp()) {
  return JSON.parse("{}");
}
async function loadAndSetLocale(nuxtApp, locale) {
  const ctx = useNuxtI18nContext(nuxtApp);
  const oldLocale = ctx.getLocale();
  if (locale === oldLocale && !ctx.initial) {
    return locale;
  }
  const data = { oldLocale, newLocale: locale, initialSetup: ctx.initial, context: nuxtApp };
  let override = await nuxtApp.callHook("i18n:beforeLocaleSwitch", data);
  if (override != null && false) {
    console.warn("[nuxt-i18n] Do not return in `i18n:beforeLocaleSwitch`, mutate `data.newLocale` instead.");
  }
  override ??= data.newLocale;
  if (isSupportedLocale(override)) {
    locale = override;
  }
  await ctx.loadMessages(locale);
  await ctx.setLocaleSuspend(locale);
  return locale;
}
function skipDetect(detect, path, pathLocale) {
  {
    return false;
  }
}
function detectLocale(nuxtApp, route) {
  const detectConfig = useI18nDetection(nuxtApp);
  const detectors = useDetectors(useRequestEvent(nuxtApp), detectConfig, nuxtApp);
  const ctx = useNuxtI18nContext(nuxtApp);
  const path = isString(route) ? route : route.path;
  function* detect() {
    if (ctx.initial && detectConfig.enabled && !skipDetect(detectConfig, path, detectors.route(path))) {
      yield detectors.cookie();
      yield detectors.header();
      yield detectors.navigator();
      yield detectConfig.fallbackLocale;
    }
  }
  for (const detected of detect()) {
    if (detected && isSupportedLocale(detected)) {
      return detected;
    }
  }
  return ctx.getLocale() || ctx.getDefaultLocale() || "";
}
function navigate(nuxtApp, to, locale) {
  return;
}
function createBaseUrlGetter(nuxt, baseUrl, defaultLocale, getDomainFromLocale) {
  if (isFunction(baseUrl)) {
    return () => baseUrl(nuxt);
  }
  return () => {
    return baseUrl ?? "";
  };
}
function createPosition(line, column, offset) {
  return { line, column, offset };
}
function createLocation(start, end, source) {
  const loc = { start, end };
  return loc;
}
const CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14};
const COMPILE_ERROR_CODES_EXTEND_POINT = 17;
function createCompileError(code, loc, options = {}) {
  const { domain, messages, args } = options;
  const msg = code;
  const error = new SyntaxError(String(msg));
  error.code = code;
  if (loc) {
    error.location = loc;
  }
  error.domain = domain;
  return error;
}
function defaultOnError(error) {
  throw error;
}
const CHAR_SP = " ";
const CHAR_CR = "\r";
const CHAR_LF = "\n";
const CHAR_LS = String.fromCharCode(8232);
const CHAR_PS = String.fromCharCode(8233);
function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = (index22) => _buf[index22] === CHAR_CR && _buf[index22 + 1] === CHAR_LF;
  const isLF = (index22) => _buf[index22] === CHAR_LF;
  const isPS = (index22) => _buf[index22] === CHAR_PS;
  const isLS = (index22) => _buf[index22] === CHAR_LS;
  const isLineEnd = (index22) => isCRLF(index22) || isLF(index22) || isPS(index22) || isLS(index22);
  const index2 = () => _index;
  const line = () => _line;
  const column = () => _column;
  const peekOffset = () => _peekOffset;
  const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
  const currentChar = () => charAt(_index);
  const currentPeek = () => charAt(_index + _peekOffset);
  function next() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  function reset() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  function resetPeek(offset = 0) {
    _peekOffset = offset;
  }
  function skipToPeek() {
    const target = _index + _peekOffset;
    while (target !== _index) {
      next();
    }
    _peekOffset = 0;
  }
  return {
    index: index2,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next,
    peek,
    reset,
    resetPeek,
    skipToPeek
  };
}
const EOF = void 0;
const DOT = ".";
const LITERAL_DELIMITER = "'";
const ERROR_DOMAIN$3 = "tokenizer";
function createTokenizer(source, options = {}) {
  const location = options.location !== false;
  const _scnr = createScanner(source);
  const currentOffset = () => _scnr.index();
  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 13,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 13,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context = () => _context;
  const { onError } = options;
  function emitError(code, pos, offset, ...args) {
    const ctx = context();
    pos.column += offset;
    pos.offset += offset;
    if (onError) {
      const loc = location ? createLocation(ctx.startLoc, pos) : null;
      const err = createCompileError(code, loc, {
        domain: ERROR_DOMAIN$3,
        args
      });
      onError(err);
    }
  }
  function getToken(context2, type, value) {
    context2.endLoc = currentPosition();
    context2.currentType = type;
    const token = { type };
    if (location) {
      token.loc = createLocation(context2.startLoc, context2.endLoc);
    }
    if (value != null) {
      token.value = value;
    }
    return token;
  }
  const getEndToken = (context2) => getToken(
    context2,
    13
    /* TokenTypes.EOF */
  );
  function eat(scnr, ch) {
    if (scnr.currentChar() === ch) {
      scnr.next();
      return ch;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);
      return "";
    }
  }
  function peekSpaces(scnr) {
    let buf = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }
    return buf;
  }
  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }
  function isIdentifierStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc === 95;
  }
  function isNumberStart(ch) {
    if (ch === EOF) {
      return false;
    }
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function isNamedIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isListIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch);
    scnr.resetPeek();
    return ret;
  }
  function isLiteralStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDotStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 7) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedModifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDelimiterStart(scnr, context2) {
    const { currentType } = context2;
    if (!(currentType === 7 || currentType === 11)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedReferStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 9) {
      return false;
    }
    const fn = () => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return isIdentifierStart(scnr.peek());
      } else if (ch === "@" || ch === "|" || ch === ":" || ch === "." || ch === CHAR_SP || !ch) {
        return false;
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn();
      } else {
        return isTextStart(scnr, false);
      }
    };
    const ret = fn();
    scnr.resetPeek();
    return ret;
  }
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  function isTextStart(scnr, reset = true) {
    const fn = (hasSpace = false, prev = "") => {
      const ch = scnr.currentPeek();
      if (ch === "{") {
        return hasSpace;
      } else if (ch === "@" || !ch) {
        return hasSpace;
      } else if (ch === "|") {
        return !(prev === CHAR_SP || prev === CHAR_LF);
      } else if (ch === CHAR_SP) {
        scnr.peek();
        return fn(true, CHAR_SP);
      } else if (ch === CHAR_LF) {
        scnr.peek();
        return fn(true, CHAR_LF);
      } else {
        return true;
      }
    };
    const ret = fn();
    reset && scnr.resetPeek();
    return ret;
  }
  function takeChar(scnr, fn) {
    const ch = scnr.currentChar();
    if (ch === EOF) {
      return EOF;
    }
    if (fn(ch)) {
      scnr.next();
      return ch;
    }
    return null;
  }
  function isIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36;
  }
  function takeIdentifierChar(scnr) {
    return takeChar(scnr, isIdentifier);
  }
  function isNamedIdentifier(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 97 && cc <= 122 || // a-z
    cc >= 65 && cc <= 90 || // A-Z
    cc >= 48 && cc <= 57 || // 0-9
    cc === 95 || // _
    cc === 36 || // $
    cc === 45;
  }
  function takeNamedIdentifierChar(scnr) {
    return takeChar(scnr, isNamedIdentifier);
  }
  function isDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57;
  }
  function takeDigit(scnr) {
    return takeChar(scnr, isDigit);
  }
  function isHexDigit(ch) {
    const cc = ch.charCodeAt(0);
    return cc >= 48 && cc <= 57 || // 0-9
    cc >= 65 && cc <= 70 || // A-F
    cc >= 97 && cc <= 102;
  }
  function takeHexDigit(scnr) {
    return takeChar(scnr, isHexDigit);
  }
  function getDigits(scnr) {
    let ch = "";
    let num = "";
    while (ch = takeDigit(scnr)) {
      num += ch;
    }
    return num;
  }
  function readText(scnr) {
    let buf = "";
    while (true) {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "}" || ch === "@" || ch === "|" || !ch) {
        break;
      } else if (ch === CHAR_SP || ch === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch;
          scnr.next();
        }
      } else {
        buf += ch;
        scnr.next();
      }
    }
    return buf;
  }
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let name2 = "";
    while (ch = takeNamedIdentifierChar(scnr)) {
      name2 += ch;
    }
    const currentChar = scnr.currentChar();
    if (currentChar && currentChar !== "}" && currentChar !== EOF && currentChar !== CHAR_SP && currentChar !== CHAR_LF && currentChar !== "　") {
      const invalidPart = readInvalidIdentifier(scnr);
      emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, name2 + invalidPart);
      return name2 + invalidPart;
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name2;
  }
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value += `-${getDigits(scnr)}`;
    } else {
      value += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value;
  }
  function isLiteral2(ch) {
    return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;
  }
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch = "";
    let literal = "";
    while (ch = takeChar(scnr, isLiteral2)) {
      if (ch === "\\") {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch;
      }
    }
    const current = scnr.currentChar();
    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal;
    }
    eat(scnr, `'`);
    return literal;
  }
  function readEscapeSequence(scnr) {
    const ch = scnr.currentChar();
    switch (ch) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch, 6);
      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);
        return "";
    }
  }
  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = "";
    for (let i = 0; i < digits; i++) {
      const ch = takeHexDigit(scnr);
      if (!ch) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch;
    }
    return `\\${unicode}${sequence}`;
  }
  function isInvalidIdentifier(ch) {
    return ch !== "{" && ch !== "}" && ch !== CHAR_SP && ch !== CHAR_LF;
  }
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch = "";
    let identifiers = "";
    while (ch = takeChar(scnr, isInvalidIdentifier)) {
      identifiers += ch;
    }
    return identifiers;
  }
  function readLinkedModifier(scnr) {
    let ch = "";
    let name2 = "";
    while (ch = takeIdentifierChar(scnr)) {
      name2 += ch;
    }
    return name2;
  }
  function readLinkedRefer(scnr) {
    const fn = (buf) => {
      const ch = scnr.currentChar();
      if (ch === "{" || ch === "@" || ch === "|" || ch === "(" || ch === ")" || !ch) {
        return buf;
      } else if (ch === CHAR_SP) {
        return buf;
      } else if (ch === CHAR_LF || ch === DOT) {
        buf += ch;
        scnr.next();
        return fn(buf);
      } else {
        buf += ch;
        scnr.next();
        return fn(buf);
      }
    };
    return fn("");
  }
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(
      scnr,
      "|"
      /* TokenChars.Pipe */
    );
    skipSpaces(scnr);
    return plural;
  }
  function readTokenInPlaceholder(scnr, context2) {
    let token = null;
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        if (context2.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          2,
          "{"
          /* TokenChars.BraceLeft */
        );
        skipSpaces(scnr);
        context2.braceNest++;
        return token;
      case "}":
        if (context2.braceNest > 0 && context2.currentType === 2) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
        context2.braceNest--;
        context2.braceNest > 0 && skipSpaces(scnr);
        if (context2.inLinked && context2.braceNest === 0) {
          context2.inLinked = false;
        }
        return token;
      case "@":
        if (context2.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token = readTokenInLinked(scnr, context2) || getEndToken(context2);
        context2.braceNest = 0;
        return token;
      default: {
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (context2.braceNest > 0 && (context2.currentType === 4 || context2.currentType === 5 || context2.currentType === 6)) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context2.braceNest = 0;
          return readToken(scnr, context2);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
          token = getToken(context2, 4, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
          token = getToken(context2, 5, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validLiteral = isLiteralStart(scnr, context2)) {
          token = getToken(context2, 6, readLiteral(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token = getToken(context2, 12, readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
          skipSpaces(scnr);
          return token;
        }
        break;
      }
    }
    return token;
  }
  function readTokenInLinked(scnr, context2) {
    const { currentType } = context2;
    let token = null;
    const ch = scnr.currentChar();
    if ((currentType === 7 || currentType === 8 || currentType === 11 || currentType === 9) && (ch === CHAR_LF || ch === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch) {
      case "@":
        scnr.next();
        token = getToken(
          context2,
          7,
          "@"
          /* TokenChars.LinkedAlias */
        );
        context2.inLinked = true;
        return token;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          8,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          9,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context2);
        }
        if (isLinkedModifierStart(scnr, context2)) {
          skipSpaces(scnr);
          return getToken(context2, 11, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context2)) {
          skipSpaces(scnr);
          if (ch === "{") {
            return readTokenInPlaceholder(scnr, context2) || token;
          } else {
            return getToken(context2, 10, readLinkedRefer(scnr));
          }
        }
        if (currentType === 7) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context2.braceNest = 0;
        context2.inLinked = false;
        return readToken(scnr, context2);
    }
  }
  function readToken(scnr, context2) {
    let token = {
      type: 13
      /* TokenTypes.EOF */
    };
    if (context2.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
    }
    if (context2.inLinked) {
      return readTokenInLinked(scnr, context2) || getEndToken(context2);
    }
    const ch = scnr.currentChar();
    switch (ch) {
      case "{":
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      case "}":
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      default: {
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (isTextStart(scnr)) {
          return getToken(context2, 0, readText(scnr));
        }
        break;
      }
    }
    return token;
  }
  function nextToken() {
    const { currentType, offset, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(
        _context,
        13
        /* TokenTypes.EOF */
      );
    }
    return readToken(_scnr, _context);
  }
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}
const ERROR_DOMAIN$2 = "parser";
const KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;
    // eslint-disable-next-line no-useless-escape
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "�";
    }
  }
}
function createParser(options = {}) {
  const location = options.location !== false;
  const { onError } = options;
  function emitError(tokenzer, code, start, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onError) {
      const loc = location ? createLocation(start, end) : null;
      const err = createCompileError(code, loc, {
        domain: ERROR_DOMAIN$2,
        args
      });
      onError(err);
    }
  }
  function startNode(type, offset, loc) {
    const node = { type };
    if (location) {
      node.start = offset;
      node.end = offset;
      node.loc = { start: loc, end: loc };
    }
    return node;
  }
  function endNode(node, offset, pos, type) {
    if (location) {
      node.end = offset;
      if (node.loc) {
        node.loc.end = pos;
      }
    }
  }
  function parseText(tokenizer, value) {
    const context = tokenizer.context();
    const node = startNode(3, context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseList(tokenizer, index2) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(5, offset, loc);
    node.index = parseInt(index2, 10);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseNamed(tokenizer, key) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(4, offset, loc);
    node.key = key;
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLiteral(tokenizer, value) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(9, offset, loc);
    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinkedModifier(tokenizer) {
    const token = tokenizer.nextToken();
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(8, offset, loc);
    if (token.type !== 11) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node.value = "";
      endNode(node, offset, loc);
      return {
        nextConsumeToken: token,
        node
      };
    }
    if (token.value == null) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    node.value = token.value || "";
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node
    };
  }
  function parseLinkedKey(tokenizer, value) {
    const context = tokenizer.context();
    const node = startNode(7, context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinked(tokenizer) {
    const context = tokenizer.context();
    const linkedNode = startNode(6, context.offset, context.startLoc);
    let token = tokenizer.nextToken();
    if (token.type === 8) {
      const parsed = parseLinkedModifier(tokenizer);
      linkedNode.modifier = parsed.node;
      token = parsed.nextConsumeToken || tokenizer.nextToken();
    }
    if (token.type !== 9) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    token = tokenizer.nextToken();
    if (token.type === 2) {
      token = tokenizer.nextToken();
    }
    switch (token.type) {
      case 10:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
        break;
      case 4:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseNamed(tokenizer, token.value || "");
        break;
      case 5:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseList(tokenizer, token.value || "");
        break;
      case 6:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLiteral(tokenizer, token.value || "");
        break;
      default: {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token,
          node: linkedNode
        };
      }
    }
    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: linkedNode
    };
  }
  function parseMessage(tokenizer) {
    const context = tokenizer.context();
    const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
    const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
    const node = startNode(2, startOffset, startLoc);
    node.items = [];
    let nextToken = null;
    do {
      const token = nextToken || tokenizer.nextToken();
      nextToken = null;
      switch (token.type) {
        case 0:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseText(tokenizer, token.value || ""));
          break;
        case 5:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseList(tokenizer, token.value || ""));
          break;
        case 4:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseNamed(tokenizer, token.value || ""));
          break;
        case 6:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseLiteral(tokenizer, token.value || ""));
          break;
        case 7: {
          const parsed = parseLinked(tokenizer);
          node.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
        }
      }
    } while (context.currentType !== 13 && context.currentType !== 1);
    const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
    const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
    endNode(node, endOffset, endLoc);
    return node;
  }
  function parsePlural(tokenizer, offset, loc, msgNode) {
    const context = tokenizer.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node = startNode(1, offset, loc);
    node.cases = [];
    node.cases.push(msgNode);
    do {
      const msg = parseMessage(tokenizer);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node.cases.push(msg);
    } while (context.currentType !== 13);
    if (hasEmptyMessage) {
      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseResource(tokenizer) {
    const context = tokenizer.context();
    const { offset, startLoc } = context;
    const msgNode = parseMessage(tokenizer);
    if (context.currentType === 13) {
      return msgNode;
    } else {
      return parsePlural(tokenizer, offset, startLoc, msgNode);
    }
  }
  function parse2(source) {
    const tokenizer = createTokenizer(source, assign({}, options));
    const context = tokenizer.context();
    const node = startNode(0, context.offset, context.startLoc);
    if (location && node.loc) {
      node.loc.source = source;
    }
    node.body = parseResource(tokenizer);
    if (options.onCacheKey) {
      node.cacheKey = options.onCacheKey(source);
    }
    if (context.currentType !== 13) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  return { parse: parse2 };
}
function getTokenCaption(token) {
  if (token.type === 13) {
    return "EOF";
  }
  const name2 = (token.value || "").replace(/\r?\n/gu, "\\n");
  return name2.length > 10 ? name2.slice(0, 9) + "…" : name2;
}
function createTransformer$1(ast, options = {}) {
  const _context = {
    ast,
    helpers: /* @__PURE__ */ new Set()
  };
  const context = () => _context;
  const helper = (name2) => {
    _context.helpers.add(name2);
    return name2;
  };
  return { context, helper };
}
function traverseNodes(nodes, transformer) {
  for (let i = 0; i < nodes.length; i++) {
    traverseNode(nodes[i], transformer);
  }
}
function traverseNode(node, transformer) {
  switch (node.type) {
    case 1:
      traverseNodes(node.cases, transformer);
      transformer.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      traverseNodes(node.items, transformer);
      break;
    case 6: {
      const linked = node;
      traverseNode(linked.key, transformer);
      transformer.helper(
        "linked"
        /* HelperNameMap.LINKED */
      );
      transformer.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function transform(ast, options = {}) {
  const transformer = createTransformer$1(ast);
  transformer.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  );
  ast.body && traverseNode(ast.body, transformer);
  const context = transformer.context();
  ast.helpers = Array.from(context.helpers);
}
function optimize(ast) {
  const body = ast.body;
  if (body.type === 2) {
    optimizeMessageNode(body);
  } else {
    body.cases.forEach((c2) => optimizeMessageNode(c2));
  }
  return ast;
}
function optimizeMessageNode(message) {
  if (message.items.length === 1) {
    const item = message.items[0];
    if (item.type === 3 || item.type === 9) {
      message.static = item.value;
      delete item.value;
    }
  } else {
    const values = [];
    for (let i = 0; i < message.items.length; i++) {
      const item = message.items[i];
      if (!(item.type === 3 || item.type === 9)) {
        break;
      }
      if (item.value == null) {
        break;
      }
      values.push(item.value);
    }
    if (values.length === message.items.length) {
      message.static = join(values);
      for (let i = 0; i < message.items.length; i++) {
        const item = message.items[i];
        if (item.type === 3 || item.type === 9) {
          delete item.value;
        }
      }
    }
  }
}
function minify(node) {
  node.t = node.type;
  switch (node.type) {
    case 0: {
      const resource = node;
      minify(resource.body);
      resource.b = resource.body;
      delete resource.body;
      break;
    }
    case 1: {
      const plural = node;
      const cases = plural.cases;
      for (let i = 0; i < cases.length; i++) {
        minify(cases[i]);
      }
      plural.c = cases;
      delete plural.cases;
      break;
    }
    case 2: {
      const message = node;
      const items = message.items;
      for (let i = 0; i < items.length; i++) {
        minify(items[i]);
      }
      message.i = items;
      delete message.items;
      if (message.static) {
        message.s = message.static;
        delete message.static;
      }
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const valueNode = node;
      if (valueNode.value) {
        valueNode.v = valueNode.value;
        delete valueNode.value;
      }
      break;
    }
    case 6: {
      const linked = node;
      minify(linked.key);
      linked.k = linked.key;
      delete linked.key;
      if (linked.modifier) {
        minify(linked.modifier);
        linked.m = linked.modifier;
        delete linked.modifier;
      }
      break;
    }
    case 5: {
      const list = node;
      list.i = list.index;
      delete list.index;
      break;
    }
    case 4: {
      const named = node;
      named.k = named.key;
      delete named.key;
      break;
    }
  }
  delete node.type;
}
function createCodeGenerator(ast, options) {
  const { filename, breakLineCode, needIndent: _needIndent } = options;
  const location = options.location !== false;
  const _context = {
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  if (location && ast.loc) {
    _context.source = ast.loc.source;
  }
  const context = () => _context;
  function push(code, node) {
    _context.code += code;
  }
  function _newline(n, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
  }
  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  function newline() {
    _newline(_context.indentLevel);
  }
  const helper = (key) => `_${key}`;
  const needIndent = () => _context.needIndent;
  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper,
    needIndent
  };
}
function generateLinkedNode(generator, node) {
  const { helper } = generator;
  generator.push(`${helper(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`);
  generateNode(generator, node.key);
  if (node.modifier) {
    generator.push(`, `);
    generateNode(generator, node.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }
  generator.push(`)`);
}
function generateMessageNode(generator, node) {
  const { helper, needIndent } = generator;
  generator.push(`${helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`);
  generator.indent(needIndent());
  const length = node.items.length;
  for (let i = 0; i < length; i++) {
    generateNode(generator, node.items[i]);
    if (i === length - 1) {
      break;
    }
    generator.push(", ");
  }
  generator.deindent(needIndent());
  generator.push("])");
}
function generatePluralNode(generator, node) {
  const { helper, needIndent } = generator;
  if (node.cases.length > 1) {
    generator.push(`${helper(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`);
    generator.indent(needIndent());
    const length = node.cases.length;
    for (let i = 0; i < length; i++) {
      generateNode(generator, node.cases[i]);
      if (i === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push(`])`);
  }
}
function generateResource(generator, node) {
  if (node.body) {
    generateNode(generator, node.body);
  } else {
    generator.push("null");
  }
}
function generateNode(generator, node) {
  const { helper } = generator;
  switch (node.type) {
    case 0:
      generateResource(generator, node);
      break;
    case 1:
      generatePluralNode(generator, node);
      break;
    case 2:
      generateMessageNode(generator, node);
      break;
    case 6:
      generateLinkedNode(generator, node);
      break;
    case 8:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 7:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 5:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "list"
        /* HelperNameMap.LIST */
      )}(${node.index}))`, node);
      break;
    case 4:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(node.key)}))`, node);
      break;
    case 9:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 3:
      generator.push(JSON.stringify(node.value), node);
      break;
  }
}
const generate = (ast, options = {}) => {
  const mode = isString(options.mode) ? options.mode : "normal";
  const filename = isString(options.filename) ? options.filename : "message.intl";
  !!options.sourceMap;
  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
  const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    filename,
    breakLineCode,
    needIndent
  });
  generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);
  if (helpers.length > 0) {
    generator.push(`const { ${join(helpers.map((s) => `${s}: _${s}`), ", ")} } = ctx`);
    generator.newline();
  }
  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  delete ast.helpers;
  const { code, map } = generator.context();
  return {
    ast,
    code,
    map: map ? map.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function baseCompile$1(source, options = {}) {
  const assignedOptions = assign({}, options);
  const jit = !!assignedOptions.jit;
  const enalbeMinify = !!assignedOptions.minify;
  const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
  const parser = createParser(assignedOptions);
  const ast = parser.parse(source);
  if (!jit) {
    transform(ast, assignedOptions);
    return generate(ast, assignedOptions);
  } else {
    enambeOptimize && optimize(ast);
    enalbeMinify && minify(ast);
    return { ast, code: "" };
  }
}
function isMessageAST(val) {
  return isObject$3(val) && resolveType(val) === 0 && (hasOwn(val, "b") || hasOwn(val, "body"));
}
const PROPS_BODY = ["b", "body"];
function resolveBody(node) {
  return resolveProps(node, PROPS_BODY);
}
const PROPS_CASES = ["c", "cases"];
function resolveCases(node) {
  return resolveProps(node, PROPS_CASES, []);
}
const PROPS_STATIC = ["s", "static"];
function resolveStatic(node) {
  return resolveProps(node, PROPS_STATIC);
}
const PROPS_ITEMS = ["i", "items"];
function resolveItems(node) {
  return resolveProps(node, PROPS_ITEMS, []);
}
const PROPS_TYPE = ["t", "type"];
function resolveType(node) {
  return resolveProps(node, PROPS_TYPE);
}
const PROPS_VALUE = ["v", "value"];
function resolveValue$1(node, type) {
  const resolved = resolveProps(node, PROPS_VALUE);
  if (resolved != null) {
    return resolved;
  } else {
    throw createUnhandleNodeError(type);
  }
}
const PROPS_MODIFIER = ["m", "modifier"];
function resolveLinkedModifier(node) {
  return resolveProps(node, PROPS_MODIFIER);
}
const PROPS_KEY = ["k", "key"];
function resolveLinkedKey(node) {
  const resolved = resolveProps(node, PROPS_KEY);
  if (resolved) {
    return resolved;
  } else {
    throw createUnhandleNodeError(
      6
      /* NodeTypes.Linked */
    );
  }
}
function resolveProps(node, props, defaultValue) {
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (hasOwn(node, prop) && node[prop] != null) {
      return node[prop];
    }
  }
  return defaultValue;
}
const AST_NODE_PROPS_KEYS = [
  ...PROPS_BODY,
  ...PROPS_CASES,
  ...PROPS_STATIC,
  ...PROPS_ITEMS,
  ...PROPS_KEY,
  ...PROPS_MODIFIER,
  ...PROPS_VALUE,
  ...PROPS_TYPE
];
function createUnhandleNodeError(type) {
  return new Error(`unhandled node type: ${type}`);
}
function format$1(ast) {
  const msg = (ctx) => formatParts(ctx, ast);
  return msg;
}
function formatParts(ctx, ast) {
  const body = resolveBody(ast);
  if (body == null) {
    throw createUnhandleNodeError(
      0
      /* NodeTypes.Resource */
    );
  }
  const type = resolveType(body);
  if (type === 1) {
    const plural = body;
    const cases = resolveCases(plural);
    return ctx.plural(cases.reduce((messages, c2) => [
      ...messages,
      formatMessageParts(ctx, c2)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
function formatMessageParts(ctx, node) {
  const static_ = resolveStatic(node);
  if (static_ != null) {
    return ctx.type === "text" ? static_ : ctx.normalize([static_]);
  } else {
    const messages = resolveItems(node).reduce((acm, c2) => [...acm, formatMessagePart(ctx, c2)], []);
    return ctx.normalize(messages);
  }
}
function formatMessagePart(ctx, node) {
  const type = resolveType(node);
  switch (type) {
    case 3: {
      return resolveValue$1(node, type);
    }
    case 9: {
      return resolveValue$1(node, type);
    }
    case 4: {
      const named = node;
      if (hasOwn(named, "k") && named.k) {
        return ctx.interpolate(ctx.named(named.k));
      }
      if (hasOwn(named, "key") && named.key) {
        return ctx.interpolate(ctx.named(named.key));
      }
      throw createUnhandleNodeError(type);
    }
    case 5: {
      const list = node;
      if (hasOwn(list, "i") && isNumber$3(list.i)) {
        return ctx.interpolate(ctx.list(list.i));
      }
      if (hasOwn(list, "index") && isNumber$3(list.index)) {
        return ctx.interpolate(ctx.list(list.index));
      }
      throw createUnhandleNodeError(type);
    }
    case 6: {
      const linked = node;
      const modifier = resolveLinkedModifier(linked);
      const key = resolveLinkedKey(linked);
      return ctx.linked(formatMessagePart(ctx, key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
    }
    case 7: {
      return resolveValue$1(node, type);
    }
    case 8: {
      return resolveValue$1(node, type);
    }
    default:
      throw new Error(`unhandled node on format message part: ${type}`);
  }
}
const defaultOnCacheKey = (message) => message;
let compileCache = create();
function baseCompile(message, options = {}) {
  let detectError = false;
  const onError = options.onError || defaultOnError;
  options.onError = (err) => {
    detectError = true;
    onError(err);
  };
  return { ...baseCompile$1(message, options), detectError };
}
// @__NO_SIDE_EFFECTS__
function compile(message, context) {
  if (isString(message)) {
    isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile(message, {
      ...context,
      location: "production" !== "production",
      jit: true
    });
    const msg = format$1(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    const cacheKey = message.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format$1(message);
    } else {
      return format$1(message);
    }
  }
}
const CoreErrorCodes = {
  INVALID_ARGUMENT: COMPILE_ERROR_CODES_EXTEND_POINT,
  // 17
  INVALID_DATE_ARGUMENT: 18,
  INVALID_ISO_DATE_ARGUMENT: 19,
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
  NOT_SUPPORT_LOCALE_TYPE: 23
};
const CORE_ERROR_CODES_EXTEND_POINT = 24;
function createCoreError(code) {
  return createCompileError(code, null, void 0);
}
function getLocale(context, options) {
  return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
}
let _resolveLocale;
function resolveLocale(locale) {
  if (isString(locale)) {
    return locale;
  } else {
    if (isFunction(locale)) {
      if (locale.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale.constructor.name === "Function") {
        const resolve = locale();
        if (isPromise(resolve)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
function fallbackWithSimple(ctx, fallback, start) {
  return [.../* @__PURE__ */ new Set([
    start,
    ...isArray(fallback) ? fallback : isObject$3(fallback) ? Object.keys(fallback) : isString(fallback) ? [fallback] : [start]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = isString(start) ? start : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block = [start];
    while (isArray(block)) {
      block = appendBlockToChain(chain, block, fallback);
    }
    const defaults = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block = isString(defaults) ? [defaults] : defaults;
    if (isArray(block)) {
      appendBlockToChain(chain, block, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block, blocks) {
  let follow = true;
  for (let i = 0; i < block.length && isBoolean(follow); i++) {
    const locale = block[i];
    if (isString(locale)) {
      follow = appendLocaleToChain(chain, block[i], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens = locale.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target, blocks) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale = target.replace(/!/g, "");
      chain.push(locale);
      if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale]) {
        follow = blocks[locale];
      }
    }
  }
  return follow;
}
const pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
const literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch) {
  if (ch === void 0 || ch === null) {
    return "o";
  }
  const code = ch.charCodeAt(0);
  switch (code) {
    case 91:
    // [
    case 93:
    // ]
    case 46:
    // .
    case 34:
    // "
    case 39:
      return ch;
    case 95:
    // _
    case 36:
    // $
    case 45:
      return "i";
    case 9:
    // Tab (HT)
    case 10:
    // Newline (LF)
    case 13:
    // Return (CR)
    case 160:
    // No-break space (NBSP)
    case 65279:
    // Byte Order Mark (BOM)
    case 8232:
    // Line Separator (LS)
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse(path) {
  const keys = [];
  let index2 = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c2;
  let key;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index2 + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index2++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  while (mode !== null) {
    index2++;
    c2 = path[index2];
    if (c2 === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c2);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c2;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys;
    }
  }
}
const cache = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject$3(obj) ? obj[path] : null;
}
function resolveValue(obj, path) {
  if (!isObject$3(obj)) {
    return null;
  }
  let hit = cache.get(path);
  if (!hit) {
    hit = parse(path);
    if (hit) {
      cache.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i = 0;
  while (i < len) {
    const key = hit[i];
    if (AST_NODE_PROPS_KEYS.includes(key) && isMessageAST(last)) {
      return null;
    }
    const val = last[key];
    if (val === void 0) {
      return null;
    }
    if (isFunction(last)) {
      return null;
    }
    last = val;
    i++;
  }
  return last;
}
const VERSION$1 = "11.2.7";
const NOT_REOSLVED = -1;
const DEFAULT_LOCALE = "en-US";
const MISSING_RESOLVE_VALUE = "";
const capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type) => {
      return type === "text" && isString(val) ? val.toUpperCase() : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type) => {
      return type === "text" && isString(val) ? val.toLowerCase() : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type) => {
      return type === "text" && isString(val) ? capitalize(val) : type === "vnode" && isObject$3(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }
  };
}
let _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
let _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
let _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
const setAdditionalMeta = /* @__NO_SIDE_EFFECTS__ */ (meta) => {
};
let _fallbackContext = null;
const setFallbackContext = (context) => {
  _fallbackContext = context;
};
const getFallbackContext = () => _fallbackContext;
let _cid = 0;
function createCoreContext(options = {}) {
  const onWarn = isFunction(options.onWarn) ? options.onWarn : warn;
  const version2 = isString(options.version) ? options.version : VERSION$1;
  const locale = isString(options.locale) || isFunction(options.locale) ? options.locale : DEFAULT_LOCALE;
  const _locale = isFunction(locale) ? DEFAULT_LOCALE : locale;
  const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
  const messages = isPlainObject(options.messages) ? options.messages : createResources(_locale);
  const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : createResources(_locale);
  const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : createResources(_locale);
  const modifiers = assign(create(), options.modifiers, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || create();
  const missing = isFunction(options.missing) ? options.missing : null;
  const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
  const messageResolver = isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject$3(options.fallbackContext) ? options.fallbackContext : void 0;
  const internalOptions = options;
  const __datetimeFormatters = isObject$3(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject$3(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject$3(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version2,
    cid: _cid,
    locale,
    fallbackLocale,
    messages,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  return context;
}
const createResources = (locale) => ({ [locale]: create() });
function handleMissing(context, key, locale, missingWarn, type) {
  const { missing, onWarn } = context;
  if (missing !== null) {
    const ret = missing(context, locale, key, type);
    return isString(ret) ? ret : key;
  } else {
    return key;
  }
}
function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
function isAlmostSameLocale(locale, compareLocale) {
  if (locale === compareLocale)
    return false;
  return locale.split("-")[0] === compareLocale.split("-")[0];
}
function isImplicitFallback(targetLocale, locales) {
  const index2 = locales.indexOf(targetLocale);
  if (index2 === -1) {
    return false;
  }
  for (let i = index2 + 1; i < locales.length; i++) {
    if (isAlmostSameLocale(targetLocale, locales[i])) {
      return true;
    }
  }
  return false;
}
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  const [key, value, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString(key) || key === "") {
    return new Intl.DateTimeFormat(locale, overrides).format(value);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "datetime format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format2 = datetimeFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject(format2) || !isString(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject$1(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign({}, format2, overrides));
    __datetimeFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = create();
  let overrides = create();
  let value;
  if (isString(arg1)) {
    const matches = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches[3] ? matches[3].trim().startsWith("T") ? `${matches[1].trim()}${matches[3].trim()}` : `${matches[1].trim()}T${matches[3].trim()}` : matches[1].trim();
    value = new Date(dateTime);
    try {
      value.toISOString();
    } catch {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value = arg1;
  } else if (isNumber$3(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearDateTimeFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id2 = `${locale}__${key}`;
    if (!context.__datetimeFormatters.has(id2)) {
      continue;
    }
    context.__datetimeFormatters.delete(id2);
  }
}
function number$1(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  const [key, value, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString(key) || key === "") {
    return new Intl.NumberFormat(locale, overrides).format(value);
  }
  let numberFormat = {};
  let targetLocale;
  let format2 = null;
  const type = "number format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    numberFormat = numberFormats[targetLocale] || {};
    format2 = numberFormat[key];
    if (isPlainObject(format2))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
  }
  if (!isPlainObject(format2) || !isString(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject$1(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign({}, format2, overrides));
    __numberFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
const NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = create();
  let overrides = create();
  if (!isNumber$3(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value = arg1;
  if (isString(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearNumberFormat(ctx, locale, format2) {
  const context = ctx;
  for (const key in format2) {
    const id2 = `${locale}__${key}`;
    if (!context.__numberFormatters.has(id2)) {
      continue;
    }
    context.__numberFormatters.delete(id2);
  }
}
const DEFAULT_MODIFIER = (str) => str;
const DEFAULT_MESSAGE = (ctx) => "";
const DEFAULT_MESSAGE_DATA_TYPE = "text";
const DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join(values);
const DEFAULT_INTERPOLATE = toDisplayString;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
  const index2 = isNumber$3(options.pluralIndex) ? options.pluralIndex : -1;
  return options.named && (isNumber$3(options.named.count) || isNumber$3(options.named.n)) ? isNumber$3(options.named.count) ? options.named.count : isNumber$3(options.named.n) ? options.named.n : index2 : index2;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject$3(options.pluralRules) && isString(locale) && isFunction(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject$3(options.pluralRules) && isString(locale) && isFunction(options.pluralRules[locale]) ? pluralDefault : void 0;
  const plural = (messages) => {
    return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
  };
  const _list = options.list || [];
  const list = (index2) => _list[index2];
  const _named = options.named || create();
  isNumber$3(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key) => _named[key];
  function message(key, useLinked) {
    const msg = isFunction(options.messages) ? options.messages(key, !!useLinked) : isObject$3(options.messages) ? options.messages[key] : false;
    return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name2) => options.modifiers ? options.modifiers[name2] : DEFAULT_MODIFIER;
  const normalize = isPlainObject(options.processor) && isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate2 = isPlainObject(options.processor) && isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject(options.processor) && isString(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type2 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject$3(arg1)) {
        modifier = arg1.modifier || modifier;
        type2 = arg1.type || type2;
      } else if (isString(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString(arg2)) {
        type2 = arg2 || type2;
      }
    }
    const ret = message(key, true)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type2 === "vnode" && isArray(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type2) : msg;
  };
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate2,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign(create(), _list, _named)
  };
  return ctx;
}
const NOOP_MESSAGE_FUNCTION = () => "";
const isMessageFunction = (val) => isFunction(val);
function translate$1(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;
  const [key, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage;
  const defaultMsgOrKey = isString(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : null;
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey != null && (isString(defaultMsgOrKey) || isFunction(defaultMsgOrKey));
  const locale = getLocale(context, options);
  escapeParameter && escapeParams(options);
  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale,
    messages[locale] || create()
  ];
  let format2 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString(format2) || isMessageAST(format2) || isMessageFunction(format2))) {
    if (enableDefaultMsg) {
      format2 = defaultMsgOrKey;
      cacheBaseKey = format2;
    }
  }
  if (!resolvedMessage && (!(isString(format2) || isMessageAST(format2) || isMessageFunction(format2)) || !isString(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let occurred = false;
  const onError = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format2) ? compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) : format2;
  if (occurred) {
    return format2;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  let ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (escapeParameter && isString(ret)) {
    ret = sanitizeTranslatedHtml(ret);
  }
  return ret;
}
function escapeParams(options) {
  if (isArray(options.list)) {
    options.list = options.list.map((item) => isString(item) ? escapeHtml(item) : item);
  } else if (isObject$3(options.named)) {
    Object.keys(options.named).forEach((key) => {
      if (isString(options.named[key])) {
        options.named[key] = escapeHtml(options.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  let message = create();
  let targetLocale;
  let format2 = null;
  const type = "translate";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = locales[i];
    message = messages[targetLocale] || create();
    if ((format2 = resolveValue2(message, key)) === null) {
      format2 = message[key];
    }
    if (isString(format2) || isMessageAST(format2) || isMessageFunction(format2)) {
      break;
    }
    if (!isImplicitFallback(targetLocale, locales)) {
      const missingRet = handleMissing(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        key,
        targetLocale,
        missingWarn,
        type
      );
      if (missingRet !== key) {
        format2 = missingRet;
      }
    }
  }
  return [format2, targetLocale, message];
}
function compileMessageFormat(context, key, targetLocale, format2, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format2)) {
    const msg2 = format2;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = (() => format2);
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  const msg = messageCompiler(format2, getCompileContext(context, targetLocale, cacheBaseKey, format2, warnHtmlMessage, onError));
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format2;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  const messaged = msg(msgCtx);
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = create();
  if (!isString(arg1) && !isNumber$3(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber$3(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber$3(arg2)) {
    options.plural = arg2;
  } else if (isString(arg2)) {
    options.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject$1(arg2)) {
    options.named = arg2;
  } else if (isArray(arg2)) {
    options.list = arg2;
  }
  if (isNumber$3(arg3)) {
    options.plural = arg3;
  } else if (isString(arg3)) {
    options.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign(options, arg3);
  }
  return [key, options];
}
function getCompileContext(context, locale, key, source, warnHtmlMessage, onError) {
  return {
    locale,
    key,
    warnHtmlMessage,
    onError: (err) => {
      onError && onError(err);
      {
        throw err;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
  };
}
function getMessageContextOptions(context, locale, message, options) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = (key, useLinked) => {
    let val = resolveValue2(message, key);
    if (val == null && (fallbackContext || useLinked)) {
      const [, , message2] = resolveMessageFormat(
        fallbackContext || context,
        // NOTE: if has fallbackContext, fallback to root, else if use linked, fallback to local context
        key,
        locale,
        fallbackLocale,
        fallbackWarn,
        missingWarn
      );
      val = resolveValue2(message2, key);
    }
    if (isString(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key, locale, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options.list) {
    ctxOptions.list = options.list;
  }
  if (options.named) {
    ctxOptions.named = options.named;
  }
  if (isNumber$3(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }
  return ctxOptions;
}
const VERSION = "11.2.7";
const I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: CORE_ERROR_CODES_EXTEND_POINT,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: 25,
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: 26,
  NOT_INSTALLED: 27,
  // directive module errors
  REQUIRED_VALUE: 28,
  INVALID_VALUE: 29,
  NOT_INSTALLED_WITH_PROVIDE: 31,
  // unexpected error
  UNEXPECTED_ERROR: 32};
function createI18nError(code, ...args) {
  return createCompileError(code, null, void 0);
}
const TranslateVNodeSymbol = /* @__PURE__ */ makeSymbol("__translateVNode");
const DatetimePartsSymbol = /* @__PURE__ */ makeSymbol("__datetimeParts");
const NumberPartsSymbol = /* @__PURE__ */ makeSymbol("__numberParts");
const SetPluralRulesSymbol = makeSymbol("__setPluralRules");
const InejctWithOptionSymbol = /* @__PURE__ */ makeSymbol("__injectWithOption");
const DisposeSymbol = /* @__PURE__ */ makeSymbol("__dispose");
function handleFlatJson(obj) {
  if (!isObject$3(obj)) {
    return obj;
  }
  if (isMessageAST(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject$3(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i = 0; i < lastIndex; i++) {
        if (subKeys[i] === "__proto__") {
          throw new Error(`unsafe key: ${subKeys[i]}`);
        }
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = create();
        }
        if (!isObject$3(currentObj[subKeys[i]])) {
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i]];
      }
      if (!hasStringValue) {
        if (!isMessageAST(currentObj)) {
          currentObj[subKeys[lastIndex]] = obj[key];
          delete obj[key];
        } else {
          if (!AST_NODE_PROPS_KEYS.includes(subKeys[lastIndex])) {
            delete obj[key];
          }
        }
      }
      if (!isMessageAST(currentObj)) {
        const target = currentObj[subKeys[lastIndex]];
        if (isObject$3(target)) {
          handleFlatJson(target);
        }
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale, options) {
  const { messages, __i18n, messageResolver, flatJson } = options;
  const ret = isPlainObject(messages) ? messages : isArray(__i18n) ? create() : { [locale]: create() };
  if (isArray(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale2, resource } = custom;
        if (locale2) {
          ret[locale2] = ret[locale2] || create();
          deepCopy(resource, ret[locale2]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
function getComponentOptions(instance) {
  return instance.type;
}
function adjustI18nResources(gl, options, componentOptions) {
  let messages = isObject$3(options.messages) ? options.messages : create();
  if ("__i18nGlobal" in componentOptions) {
    messages = getLocaleMessages(gl.locale.value, {
      messages,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages);
  if (locales.length) {
    locales.forEach((locale) => {
      gl.mergeLocaleMessage(locale, messages[locale]);
    });
  }
  {
    if (isObject$3(options.datetimeFormats)) {
      const locales2 = Object.keys(options.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    }
    if (isObject$3(options.numberFormats)) {
      const locales2 = Object.keys(options.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
function getCurrentInstance() {
  const key = "currentInstance";
  if (key in vue) {
    return vue[key];
  } else {
    return vue.getCurrentInstance();
  }
}
const DEVTOOLS_META = "__INTLIFY_META__";
const NOOP_RETURN_ARRAY = () => [];
const NOOP_RETURN_FALSE = () => false;
let composerID = 0;
function defineCoreMissingHandler(missing) {
  return ((ctx, locale, key, type) => {
    return missing(locale, key, getCurrentInstance() || void 0, type);
  });
}
const getMetaInfo = /* @__NO_SIDE_EFFECTS__ */ () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options = {}) {
  const { __root, __injectWithOption } = options;
  const _isGlobal = __root === void 0;
  const flatJson = options.flatJson;
  const _ref = shallowRef;
  let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = _ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = _ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  let _fallbackFormat = !!options.fallbackFormat;
  let _missing = isFunction(options.missing) ? options.missing : null;
  let _runtimeMissing = isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
  let _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  let _escapeParameter = !!options.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  let _pluralRules = options.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      messageCompiler: options.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => _locale.value,
    set: (val) => {
      _context.locale = val;
      _locale.value = val;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _context.fallbackLocale = val;
      _fallbackLocale.value = val;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages = computed(() => _messages.value);
  const datetimeFormats = /* @__PURE__ */ computed(() => _datetimeFormats.value);
  const numberFormats = /* @__PURE__ */ computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  const wrapWithDeps = (fn, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if ("production" !== "production" || false) ;
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn(_context);
    } finally {
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (warnType !== "translate exists" && // for not `te` (e.g `t`)
    isNumber$3(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate$1, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root) => Reflect.apply(root.t, root, [...args]), (key) => key, (val) => isString(val));
  }
  function rt2(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject$3(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t(...[arg1, arg2, assign({ resolvedMessage: true }, arg3 || {})]);
  }
  function d(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root) => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString(val) || isArray(val));
  }
  function n(...args) {
    return wrapWithDeps((context) => Reflect.apply(number$1, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root) => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString(val) || isArray(val));
  }
  function normalize(values) {
    return values.map((val) => isString(val) || isNumber$3(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  const interpolate2 = (val) => val;
  const processor = {
    normalize,
    interpolate: interpolate2,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps((context) => {
      let ret;
      const _context2 = context;
      try {
        _context2.processor = processor;
        ret = Reflect.apply(translate$1, null, [_context2, ...args]);
      } finally {
        _context2.processor = null;
      }
      return ret;
    }, () => parseTranslateArgs(...args), "translate", (root) => root[TranslateVNodeSymbol](...args), (key) => [createTextNode(key)], (val) => isArray(val));
  }
  function numberParts(...args) {
    return wrapWithDeps((context) => Reflect.apply(number$1, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root) => root[NumberPartsSymbol](...args), NOOP_RETURN_ARRAY, (val) => isString(val) || isArray(val));
  }
  function datetimeParts(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root) => root[DatetimePartsSymbol](...args), NOOP_RETURN_ARRAY, (val) => isString(val) || isArray(val));
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te(key, locale2) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString(locale2) ? locale2 : _locale.value;
      const message = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message, key);
      return isMessageAST(resolved) || isMessageFunction(resolved) || isString(resolved);
    }, () => [key], "translate exists", (root) => {
      return Reflect.apply(root.te, root, [key, locale2]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
  }
  function resolveMessages(key) {
    let messages2 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i = 0; i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages2 = messageValue;
        break;
      }
    }
    return messages2;
  }
  function tm(key) {
    const messages2 = resolveMessages(key);
    return messages2 != null ? messages2 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message) {
    if (flatJson) {
      const _message = { [locale2]: message };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message = _message[locale2];
    }
    _messages.value[locale2] = message;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    const _message = { [locale2]: message };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message = _message[locale2];
    deepCopy(message, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = format2;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function mergeDateTimeFormat(locale2, format2) {
    _datetimeFormats.value[locale2] = assign(_datetimeFormats.value[locale2] || {}, format2);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format2);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = format2;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  function mergeNumberFormat(locale2, format2) {
    _numberFormats.value[locale2] = assign(_numberFormats.value[locale2] || {}, format2);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format2);
  }
  composerID++;
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt2;
    composer.te = te;
    composer.tm = tm;
    composer.d = d;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  return composer;
}
const baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys) {
  if (keys.length === 1 && keys[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, create());
  }
}
function getFragmentableTag() {
  return Fragment;
}
const TranslationImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      validator: (val) => isNumber$3(val) || !isNaN(val)
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const { slots, attrs } = context;
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys = Object.keys(slots).filter((key) => key[0] !== "_");
      const options = create();
      if (props.locale) {
        options.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options.plural = isString(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys);
      const children = i18n[TranslateVNodeSymbol](props.keypath, arg, options);
      const assignedAttrs = assign(create(), attrs);
      const tag = isString(props.tag) || isObject$3(props.tag) ? props.tag : getFragmentableTag();
      return h(tag, assignedAttrs, children);
    };
  }
});
const Translation = TranslationImpl;
function isVNode(target) {
  return isArray(target) && !isString(target[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs } = context;
  return () => {
    const options = { part: true };
    let overrides = create();
    if (props.locale) {
      options.locale = props.locale;
    }
    if (isString(props.format)) {
      options.key = props.format;
    } else if (isObject$3(props.format)) {
      if (isString(props.format.key)) {
        options.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options2, prop) => {
        return slotKeys.includes(prop) ? assign(create(), options2, { [prop]: props.format[prop] }) : options2;
      }, create());
    }
    const parts = partFormatter(...[props.value, options, overrides]);
    let children = [options.key];
    if (isArray(parts)) {
      children = parts.map((part, index2) => {
        const slot = slots[part.type];
        const node = slot ? slot({ [part.type]: part.value, index: index2, parts }) : [part.value];
        if (isVNode(node)) {
          node[0].key = `${part.type}-${index2}`;
        }
        return node;
      });
    } else if (isString(parts)) {
      children = [parts];
    }
    const assignedAttrs = assign(create(), attrs);
    const tag = isString(props.tag) || isObject$3(props.tag) ? props.tag : getFragmentableTag();
    return h(tag, assignedAttrs, children);
  };
}
const NumberFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n[NumberPartsSymbol](...args)
    ));
  }
});
const NumberFormat = NumberFormatImpl;
function getComposer$1(i18n, instance) {
  const i18nInternal = i18n;
  if (i18n.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n.global.__composer;
  }
}
function vTDirective(i18n) {
  const _process = (binding) => {
    const { instance, value } = binding;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$1(i18n, instance.$);
    const parsedValue = parseValue(value);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register = (el, binding) => {
    const [textContent, composer] = _process(binding);
    el.__composer = composer;
    el.textContent = textContent;
  };
  const unregister = (el) => {
    if (el.__composer) {
      el.__composer = void 0;
      delete el.__composer;
    }
  };
  const update = (el, { value }) => {
    if (el.__composer) {
      const composer = el.__composer;
      const parsedValue = parseValue(value);
      el.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  };
  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update,
    getSSRProps
  };
}
function parseValue(value) {
  if (isString(value)) {
    return { path: value };
  } else if (isPlainObject(value)) {
    if (!("path" in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value) {
  const { path, locale, args, choice, plural } = value;
  const options = {};
  const named = args || {};
  if (isString(locale)) {
    options.locale = locale;
  }
  if (isNumber$3(choice)) {
    options.plural = choice;
  }
  if (isNumber$3(plural)) {
    options.plural = plural;
  }
  return [path, named, options];
}
function apply(app, i18n, ...options) {
  const pluginOptions = isPlainObject(options[0]) ? options[0] : {};
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall) {
    [Translation.name, "I18nT"].forEach((name2) => app.component(name2, Translation));
    [NumberFormat.name, "I18nN"].forEach((name2) => app.component(name2, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name2) => app.component(name2, DatetimeFormat));
  }
  {
    app.directive("t", vTDirective(i18n));
  }
}
const I18nInjectionKey = /* @__PURE__ */ makeSymbol("global-vue-i18n");
function createI18n(options = {}) {
  const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options);
  const symbol = /* @__PURE__ */ makeSymbol("");
  function __getInstance(component) {
    return __instances.get(component) || null;
  }
  function __setInstance(component, instance) {
    __instances.set(component, instance);
  }
  function __deleteInstance(component) {
    __instances.delete(component);
  }
  const i18n = {
    // mode
    get mode() {
      return "composition";
    },
    // install plugin
    async install(app, ...options2) {
      app.__VUE_I18N_SYMBOL__ = symbol;
      app.provide(app.__VUE_I18N_SYMBOL__, i18n);
      if (isPlainObject(options2[0])) {
        const opts = options2[0];
        i18n.__composerExtend = opts.__composerExtend;
        i18n.__vueI18nExtend = opts.__vueI18nExtend;
      }
      let globalReleaseHandler = null;
      if (__globalInjection) {
        globalReleaseHandler = injectGlobalFields(app, i18n.global);
      }
      {
        apply(app, i18n, ...options2);
      }
      const unmountApp = app.unmount;
      app.unmount = () => {
        globalReleaseHandler && globalReleaseHandler();
        i18n.dispose();
        unmountApp();
      };
    },
    // global accessor
    get global() {
      return __global;
    },
    dispose() {
      globalScope.stop();
    },
    // @internal
    __instances,
    // @internal
    __getInstance,
    // @internal
    __setInstance,
    // @internal
    __deleteInstance
  };
  return i18n;
}
function useI18n(options = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n = getI18nInstance(instance);
  const gl = getGlobalComposer(i18n);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options, componentOptions);
  if (scope === "global") {
    adjustI18nResources(gl, options, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n, instance, options.__useComponent);
    if (composer2 == null) {
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign({}, options);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
function createGlobal(options, legacyMode) {
  const scope = effectScope();
  const obj = scope.run(() => createComposer(options));
  if (obj == null) {
    throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
  }
  return [scope, obj];
}
function getI18nInstance(instance) {
  const i18n = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
  if (!i18n) {
    throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
  }
  return i18n;
}
function getScope(options, componentOptions) {
  return isEmptyObject$1(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
}
function getGlobalComposer(i18n) {
  return i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
}
function getComposer(i18n, target, useComponent = false) {
  let composer = null;
  const root = target.root;
  let current = getParentComponentInstance(target, useComponent);
  while (current != null) {
    const i18nInternal = i18n;
    if (i18n.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    }
    if (composer != null) {
      break;
    }
    if (root === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function getParentComponentInstance(target, useComponent = false) {
  if (target == null) {
    return null;
  }
  return !useComponent ? target.parent : target.vnode.ctx || target.parent;
}
const globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
const globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app, composer) {
  const i18n = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap2 = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n, prop, wrap2);
  });
  app.config.globalProperties.$i18n = i18n;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app.config.globalProperties, `$${method}`, desc);
  });
  const dispose = () => {
    delete app.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app.config.globalProperties[`$${method}`];
    });
  };
  return dispose;
}
const DatetimeFormatImpl = /* @__PURE__ */ defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n[DatetimePartsSymbol](...args)
    ));
  }
});
const DatetimeFormat = DatetimeFormatImpl;
registerMessageCompiler(compile);
registerMessageResolver(resolveValue);
registerLocaleFallbacker(fallbackWithLocaleChain);
function useRouteBaseName(nuxtApp = useNuxtApp()) {
  const common = useComposableContext(nuxtApp);
  return (route) => {
    if (route == null) return;
    return common.getRouteBaseName(route) || void 0;
  };
}
function useLocalePath(nuxtApp = useNuxtApp()) {
  const common = useComposableContext(nuxtApp);
  return (route, locale) => localePath(common, route, locale);
}
function useLocaleRoute(nuxtApp = useNuxtApp()) {
  const common = useComposableContext(nuxtApp);
  return (route, locale) => localeRoute(common, route, locale);
}
function useSwitchLocalePath(nuxtApp = useNuxtApp()) {
  const common = useComposableContext(nuxtApp);
  return (locale) => switchLocalePath(common, locale);
}
const identifier = "nuxt-i18n-slp";
const switchLocalePathLinkWrapperExpr = new RegExp(
  [`<!--${identifier}-\\[(\\w+)\\]-->`, `.+?`, `<!--/${identifier}-->`].join(""),
  "g"
);
const switch_locale_path_ssr_Dze1NTXfrlXHhwAF_2CPZW1RISIQ5nyVFa0AHzdg25U = /* @__PURE__ */ defineNuxtPlugin({
  name: "i18n:plugin:switch-locale-path-ssr",
  dependsOn: ["i18n:plugin"],
  setup(_nuxt) {
    const nuxt = useNuxtApp(_nuxt._id);
    const switchLocalePath2 = useSwitchLocalePath(nuxt);
    nuxt.hook("app:rendered", (ctx) => {
      if (ctx.renderResult?.html == null) return;
      ctx.renderResult.html = ctx.renderResult.html.replaceAll(
        switchLocalePathLinkWrapperExpr,
        (match, p1) => {
          const encoded = encodeURI(switchLocalePath2(p1 ?? ""));
          return match.replace(
            /href="([^"]+)"/,
            `href="${encoded || "#"}" ${""}`
          );
        }
      );
    });
  }
});
const route_locale_detect_2J0uY6yg03Fl3HcWrCmbdaA0_d2jkpgnfFSLwIVDjGM = /* @__PURE__ */ defineNuxtPlugin({
  name: "i18n:plugin:route-locale-detect",
  dependsOn: ["i18n:plugin"],
  async setup(_nuxt) {
    let __temp, __restore;
    const nuxt = useNuxtApp(_nuxt._id);
    const ctx = useNuxtI18nContext(nuxt);
    const resolvedLocale = useResolvedLocale();
    [__temp, __restore] = executeAsync(() => nuxt.runWithContext(
      () => loadAndSetLocale(
        nuxt,
        ctx.initial && resolvedLocale.value || detectLocale(nuxt, nuxt.$router.currentRoute.value)
      )
    )), await __temp, __restore();
    return;
  }
});
const preload_gcC1VaCwF_vIh4_YThnEj2iARUbOWQ_7HmzWTQ7k2QI = /* @__PURE__ */ defineNuxtPlugin({
  name: "i18n:plugin:preload",
  dependsOn: ["i18n:plugin"],
  async setup(_nuxt) {
    return;
  }
});
function extendI18n(i18n, { extendComposer, extendComposerInstance }) {
  const scope = effectScope();
  const installI18n = i18n.install.bind(i18n);
  i18n.install = (app, ...options) => {
    const pluginOptions = assign({}, options[0]);
    pluginOptions.__composerExtend = (c2) => {
      extendComposerInstance(c2, getComposer$3(i18n));
      return () => {
      };
    };
    if (i18n.mode === "legacy") {
      pluginOptions.__vueI18nExtend = (vueI18n) => {
        extendComposerInstance(vueI18n, getComposer$3(vueI18n));
        return () => {
        };
      };
    }
    Reflect.apply(installI18n, i18n, [app, pluginOptions]);
    const globalComposer = getComposer$3(i18n);
    scope.run(() => {
      extendComposer(globalComposer);
      if (i18n.mode === "legacy" && "__composer" in i18n.global) {
        extendComposerInstance(i18n.global, getComposer$3(i18n.global));
      }
    });
    if (i18n.mode === "composition" && app.config.globalProperties.$i18n != null) {
      extendComposerInstance(app.config.globalProperties.$i18n, globalComposer);
    }
    if (app.unmount) {
      const unmountApp = app.unmount.bind(app);
      app.unmount = () => {
        scope.stop();
        unmountApp();
      };
    }
  };
}
const setupVueI18nOptions = async (defaultLocale) => {
  const options = await loadVueI18nOptions(vueI18nConfigs);
  options.locale = defaultLocale || options.locale || "en-US";
  options.defaultLocale = defaultLocale;
  options.fallbackLocale ??= false;
  options.messages ??= {};
  for (const locale of localeCodes) {
    options.messages[locale] ??= {};
  }
  return options;
};
const i18n_9VvcYVujdwTF_eqLEvU7W5fit2iS7KZYn9D_F7xJTck = /* @__PURE__ */ defineNuxtPlugin({
  name: "i18n:plugin",
  parallel: false,
  async setup(_nuxt) {
    let __temp, __restore;
    Object.defineProperty(_nuxt.versions, "nuxtI18n", { get: () => "10.1.0" });
    const nuxt = useNuxtApp(_nuxt._id);
    const runtimeI18n = useRuntimeI18n(nuxt);
    const preloadedOptions = nuxt.ssrContext?.event?.context?.nuxtI18n?.vueI18nOptions;
    const _defaultLocale = getDefaultLocaleForDomain(useRequestURL({ xForwardedHost: true }).host) || runtimeI18n.defaultLocale || "";
    const optionsI18n = preloadedOptions || ([__temp, __restore] = executeAsync(() => setupVueI18nOptions(_defaultLocale)), __temp = await __temp, __restore(), __temp);
    const localeConfigs = useLocaleConfigs();
    {
      localeConfigs.value = useRequestEvent().context.nuxtI18n?.localeConfigs || {};
    }
    prerenderRoutes(localeCodes.map((locale) => `/_i18n/${"2U3Am7DZ"}/${locale}/messages.json`));
    const i18n = createI18n(optionsI18n);
    const detectors = useDetectors(useRequestEvent(nuxt), useI18nDetection(nuxt), nuxt);
    const ctx = createNuxtI18nContext(nuxt, i18n, optionsI18n.defaultLocale);
    nuxt._nuxtI18n = ctx;
    extendI18n(i18n, {
      extendComposer(composer) {
        composer.locales = computed(() => runtimeI18n.locales);
        composer.localeCodes = computed(() => localeCodes);
        const _baseUrl = ref(ctx.getBaseUrl());
        composer.baseUrl = computed(() => _baseUrl.value);
        composer.strategy = "no_prefix";
        composer.localeProperties = computed(
          () => normalizedLocales.find((l) => l.code === composer.locale.value) || { code: composer.locale.value }
        );
        composer.setLocale = async (locale) => {
          await loadAndSetLocale(nuxt, locale);
          await nuxt.runWithContext(() => navigate(nuxt, nuxt.$router.currentRoute.value));
        };
        composer.loadLocaleMessages = ctx.loadMessages;
        composer.differentDomains = false;
        composer.defaultLocale = optionsI18n.defaultLocale;
        composer.getBrowserLocale = () => resolveSupportedLocale(detectors.header());
        composer.getLocaleCookie = () => resolveSupportedLocale(detectors.cookie());
        composer.setLocaleCookie = ctx.setCookieLocale;
        composer.finalizePendingLocaleChange = async () => {
          if (!i18n.__pendingLocale) return;
          await i18n.__resolvePendingLocalePromise?.();
        };
        composer.waitForPendingLocaleChange = async () => {
          await i18n?.__pendingLocalePromise;
        };
      },
      extendComposerInstance(instance, c2) {
        const props = [
          ["locales", () => c2.locales],
          ["localeCodes", () => c2.localeCodes],
          ["baseUrl", () => c2.baseUrl],
          ["strategy", () => "no_prefix"],
          ["localeProperties", () => c2.localeProperties],
          ["setLocale", () => async (locale) => Reflect.apply(c2.setLocale, c2, [locale])],
          ["loadLocaleMessages", () => async (locale) => Reflect.apply(c2.loadLocaleMessages, c2, [locale])],
          ["differentDomains", () => false],
          ["defaultLocale", () => c2.defaultLocale],
          ["getBrowserLocale", () => () => Reflect.apply(c2.getBrowserLocale, c2, [])],
          ["getLocaleCookie", () => () => Reflect.apply(c2.getLocaleCookie, c2, [])],
          ["setLocaleCookie", () => (locale) => Reflect.apply(c2.setLocaleCookie, c2, [locale])],
          ["finalizePendingLocaleChange", () => () => Reflect.apply(c2.finalizePendingLocaleChange, c2, [])],
          ["waitForPendingLocaleChange", () => () => Reflect.apply(c2.waitForPendingLocaleChange, c2, [])]
        ];
        for (const [key, get2] of props) {
          Object.defineProperty(instance, key, { get: get2 });
        }
      }
    });
    nuxt.vueApp.use(i18n);
    Object.defineProperty(nuxt, "$i18n", { get: () => getI18nTarget(i18n) });
    nuxt.provide("localeHead", (options) => localeHead(nuxt._nuxtI18n.composableCtx, options));
    nuxt.provide("localePath", useLocalePath(nuxt));
    nuxt.provide("localeRoute", useLocaleRoute(nuxt));
    nuxt.provide("routeBaseName", useRouteBaseName(nuxt));
    nuxt.provide("getRouteBaseName", useRouteBaseName(nuxt));
    nuxt.provide("switchLocalePath", useSwitchLocalePath(nuxt));
  }
});
dayjs.extend(updateLocale);
dayjs.extend(relativeTime);
dayjs.extend(utc);
dayjs.extend(timezone);
dayjs.extend(duration);
dayjs.extend(localizedFormat);
dayjs.extend(isBetween);
dayjs.tz.setDefault("Asia/Shanghai");
const plugin_9_EpKXPMHOpyihxvImx0aIXN6zBuUpKODx_p4SQZ7jU = /* @__PURE__ */ defineNuxtPlugin(async (nuxtApp) => nuxtApp.provide("dayjs", dayjs));
const matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
const stringToIcon = (value, validate2, allowSimpleName, provider = "") => {
  const colonSeparated = value.split(":");
  if (value.slice(0, 1) === "@") {
    if (colonSeparated.length < 2 || colonSeparated.length > 3) {
      return null;
    }
    provider = colonSeparated.shift().slice(1);
  }
  if (colonSeparated.length > 3 || !colonSeparated.length) {
    return null;
  }
  if (colonSeparated.length > 1) {
    const name22 = colonSeparated.pop();
    const prefix = colonSeparated.pop();
    const result = {
      // Allow provider without '@': "provider:prefix:name"
      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
      prefix,
      name: name22
    };
    return validate2 && !validateIconName(result) ? null : result;
  }
  const name2 = colonSeparated[0];
  const dashSeparated = name2.split("-");
  if (dashSeparated.length > 1) {
    const result = {
      provider,
      prefix: dashSeparated.shift(),
      name: dashSeparated.join("-")
    };
    return validate2 && !validateIconName(result) ? null : result;
  }
  if (allowSimpleName && provider === "") {
    const result = {
      provider,
      prefix: "",
      name: name2
    };
    return validate2 && !validateIconName(result, allowSimpleName) ? null : result;
  }
  return null;
};
const validateIconName = (icon, allowSimpleName) => {
  if (!icon) {
    return false;
  }
  return !!// Check prefix: cannot be empty, unless allowSimpleName is enabled
  // Check name: cannot be empty
  ((allowSimpleName && icon.prefix === "" || !!icon.prefix) && !!icon.name);
};
const defaultIconDimensions$1 = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
const defaultIconTransformations$1 = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
const defaultIconProps$1 = Object.freeze({
  ...defaultIconDimensions$1,
  ...defaultIconTransformations$1
});
const defaultExtendedIconProps = Object.freeze({
  ...defaultIconProps$1,
  body: "",
  hidden: false
});
function mergeIconTransformations(obj1, obj2) {
  const result = {};
  if (!obj1.hFlip !== !obj2.hFlip) {
    result.hFlip = true;
  }
  if (!obj1.vFlip !== !obj2.vFlip) {
    result.vFlip = true;
  }
  const rotate2 = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
  if (rotate2) {
    result.rotate = rotate2;
  }
  return result;
}
function mergeIconData(parent, child) {
  const result = mergeIconTransformations(parent, child);
  for (const key in defaultExtendedIconProps) {
    if (key in defaultIconTransformations$1) {
      if (key in parent && !(key in result)) {
        result[key] = defaultIconTransformations$1[key];
      }
    } else if (key in child) {
      result[key] = child[key];
    } else if (key in parent) {
      result[key] = parent[key];
    }
  }
  return result;
}
function getIconsTree(data, names) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  const resolved = /* @__PURE__ */ Object.create(null);
  function resolve(name2) {
    if (icons[name2]) {
      return resolved[name2] = [];
    }
    if (!(name2 in resolved)) {
      resolved[name2] = null;
      const parent = aliases[name2] && aliases[name2].parent;
      const value = parent && resolve(parent);
      if (value) {
        resolved[name2] = [parent].concat(value);
      }
    }
    return resolved[name2];
  }
  Object.keys(icons).concat(Object.keys(aliases)).forEach(resolve);
  return resolved;
}
function internalGetIconData(data, name2, tree) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  let currentProps = {};
  function parse2(name22) {
    currentProps = mergeIconData(
      icons[name22] || aliases[name22],
      currentProps
    );
  }
  parse2(name2);
  tree.forEach(parse2);
  return mergeIconData(data, currentProps);
}
function parseIconSet(data, callback) {
  const names = [];
  if (typeof data !== "object" || typeof data.icons !== "object") {
    return names;
  }
  if (data.not_found instanceof Array) {
    data.not_found.forEach((name2) => {
      callback(name2, null);
      names.push(name2);
    });
  }
  const tree = getIconsTree(data);
  for (const name2 in tree) {
    const item = tree[name2];
    if (item) {
      callback(name2, internalGetIconData(data, name2, item));
      names.push(name2);
    }
  }
  return names;
}
const optionalPropertyDefaults = {
  provider: "",
  aliases: {},
  not_found: {},
  ...defaultIconDimensions$1
};
function checkOptionalProps(item, defaults) {
  for (const prop in defaults) {
    if (prop in item && typeof item[prop] !== typeof defaults[prop]) {
      return false;
    }
  }
  return true;
}
function quicklyValidateIconSet(obj) {
  if (typeof obj !== "object" || obj === null) {
    return null;
  }
  const data = obj;
  if (typeof data.prefix !== "string" || !obj.icons || typeof obj.icons !== "object") {
    return null;
  }
  if (!checkOptionalProps(obj, optionalPropertyDefaults)) {
    return null;
  }
  const icons = data.icons;
  for (const name2 in icons) {
    const icon = icons[name2];
    if (
      // Name cannot be empty
      !name2 || // Must have body
      typeof icon.body !== "string" || // Check other props
      !checkOptionalProps(
        icon,
        defaultExtendedIconProps
      )
    ) {
      return null;
    }
  }
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  for (const name2 in aliases) {
    const icon = aliases[name2];
    const parent = icon.parent;
    if (
      // Name cannot be empty
      !name2 || // Parent must be set and point to existing icon
      typeof parent !== "string" || !icons[parent] && !aliases[parent] || // Check other props
      !checkOptionalProps(
        icon,
        defaultExtendedIconProps
      )
    ) {
      return null;
    }
  }
  return data;
}
const dataStorage = /* @__PURE__ */ Object.create(null);
function newStorage(provider, prefix) {
  return {
    provider,
    prefix,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function getStorage(provider, prefix) {
  const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));
  return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));
}
function addIconSet(storage2, data) {
  if (!quicklyValidateIconSet(data)) {
    return [];
  }
  return parseIconSet(data, (name2, icon) => {
    if (icon) {
      storage2.icons[name2] = icon;
    } else {
      storage2.missing.add(name2);
    }
  });
}
function addIconToStorage(storage2, name2, icon) {
  try {
    if (typeof icon.body === "string") {
      storage2.icons[name2] = { ...icon };
      return true;
    }
  } catch (err) {
  }
  return false;
}
let simpleNames = false;
function allowSimpleNames(allow) {
  if (typeof allow === "boolean") {
    simpleNames = allow;
  }
  return simpleNames;
}
function getIconData(name2) {
  const icon = typeof name2 === "string" ? stringToIcon(name2, true, simpleNames) : name2;
  if (icon) {
    const storage2 = getStorage(icon.provider, icon.prefix);
    const iconName = icon.name;
    return storage2.icons[iconName] || (storage2.missing.has(iconName) ? null : void 0);
  }
}
function addIcon(name2, data) {
  const icon = stringToIcon(name2, true, simpleNames);
  if (!icon) {
    return false;
  }
  const storage2 = getStorage(icon.provider, icon.prefix);
  if (data) {
    return addIconToStorage(storage2, icon.name, data);
  } else {
    storage2.missing.add(icon.name);
    return true;
  }
}
function getIcon(name2) {
  const result = getIconData(name2);
  return result ? {
    ...defaultIconProps$1,
    ...result
  } : result;
}
const defaultIconSizeCustomisations$1 = Object.freeze({
  width: null,
  height: null
});
const defaultIconCustomisations$1 = Object.freeze({
  // Dimensions
  ...defaultIconSizeCustomisations$1,
  // Transformations
  ...defaultIconTransformations$1
});
const unitsSplit$1 = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
const unitsTest$1 = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize$1(size, ratio, precision) {
  if (ratio === 1) {
    return size;
  }
  precision = precision || 100;
  if (typeof size === "number") {
    return Math.ceil(size * ratio * precision) / precision;
  }
  if (typeof size !== "string") {
    return size;
  }
  const oldParts = size.split(unitsSplit$1);
  if (oldParts === null || !oldParts.length) {
    return size;
  }
  const newParts = [];
  let code = oldParts.shift();
  let isNumber2 = unitsTest$1.test(code);
  while (true) {
    if (isNumber2) {
      const num = parseFloat(code);
      if (isNaN(num)) {
        newParts.push(code);
      } else {
        newParts.push(Math.ceil(num * ratio * precision) / precision);
      }
    } else {
      newParts.push(code);
    }
    code = oldParts.shift();
    if (code === void 0) {
      return newParts.join("");
    }
    isNumber2 = !isNumber2;
  }
}
function splitSVGDefs$1(content, tag = "defs") {
  let defs = "";
  const index2 = content.indexOf("<" + tag);
  while (index2 >= 0) {
    const start = content.indexOf(">", index2);
    const end = content.indexOf("</" + tag);
    if (start === -1 || end === -1) {
      break;
    }
    const endEnd = content.indexOf(">", end);
    if (endEnd === -1) {
      break;
    }
    defs += content.slice(start + 1, end).trim();
    content = content.slice(0, index2).trim() + content.slice(endEnd + 1);
  }
  return {
    defs,
    content
  };
}
function mergeDefsAndContent$1(defs, content) {
  return defs ? "<defs>" + defs + "</defs>" + content : content;
}
function wrapSVGContent$1(body, start, end) {
  const split = splitSVGDefs$1(body);
  return mergeDefsAndContent$1(split.defs, start + split.content + end);
}
const isUnsetKeyword$1 = (value) => value === "unset" || value === "undefined" || value === "none";
function iconToSVG$1(icon, customisations) {
  const fullIcon = {
    ...defaultIconProps$1,
    ...icon
  };
  const fullCustomisations = {
    ...defaultIconCustomisations$1,
    ...customisations
  };
  const box = {
    left: fullIcon.left,
    top: fullIcon.top,
    width: fullIcon.width,
    height: fullIcon.height
  };
  let body = fullIcon.body;
  [fullIcon, fullCustomisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation2 = props.rotate;
    if (hFlip) {
      if (vFlip) {
        rotation2 += 2;
      } else {
        transformations.push(
          "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
        );
        transformations.push("scale(-1 1)");
        box.top = box.left = 0;
      }
    } else if (vFlip) {
      transformations.push(
        "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
      );
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation2 < 0) {
      rotation2 -= Math.floor(rotation2 / 4) * 4;
    }
    rotation2 = rotation2 % 4;
    switch (rotation2) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift(
          "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
      case 2:
        transformations.unshift(
          "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
        );
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift(
          "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
    }
    if (rotation2 % 2 === 1) {
      if (box.left !== box.top) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) {
      body = wrapSVGContent$1(
        body,
        '<g transform="' + transformations.join(" ") + '">',
        "</g>"
      );
    }
  });
  const customisationsWidth = fullCustomisations.width;
  const customisationsHeight = fullCustomisations.height;
  const boxWidth = box.width;
  const boxHeight = box.height;
  let width;
  let height;
  if (customisationsWidth === null) {
    height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
    width = calculateSize$1(height, boxWidth / boxHeight);
  } else {
    width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
    height = customisationsHeight === null ? calculateSize$1(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
  }
  const attributes = {};
  const setAttr = (prop, value) => {
    if (!isUnsetKeyword$1(value)) {
      attributes[prop] = value.toString();
    }
  };
  setAttr("width", width);
  setAttr("height", height);
  const viewBox = [box.left, box.top, boxWidth, boxHeight];
  attributes.viewBox = viewBox.join(" ");
  return {
    attributes,
    viewBox,
    body
  };
}
const regex = /\sid="(\S+)"/g;
const randomPrefix = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let counter = 0;
function replaceIDs(body, prefix = randomPrefix) {
  const ids = [];
  let match;
  while (match = regex.exec(body)) {
    ids.push(match[1]);
  }
  if (!ids.length) {
    return body;
  }
  const suffix = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  ids.forEach((id2) => {
    const newID = typeof prefix === "function" ? prefix(id2) : prefix + (counter++).toString();
    const escapedID = id2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    body = body.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + escapedID + ')([")]|\\.[a-z])', "g"),
      "$1" + newID + suffix + "$3"
    );
  });
  body = body.replace(new RegExp(suffix, "g"), "");
  return body;
}
const storage = /* @__PURE__ */ Object.create(null);
function setAPIModule(provider, item) {
  storage[provider] = item;
}
function getAPIModule(provider) {
  return storage[provider] || storage[""];
}
function createAPIConfig(source) {
  let resources;
  if (typeof source.resources === "string") {
    resources = [source.resources];
  } else {
    resources = source.resources;
    if (!(resources instanceof Array) || !resources.length) {
      return null;
    }
  }
  const result = {
    // API hosts
    resources,
    // Root path
    path: source.path || "/",
    // URL length limit
    maxURL: source.maxURL || 500,
    // Timeout before next host is used.
    rotate: source.rotate || 750,
    // Timeout before failing query.
    timeout: source.timeout || 5e3,
    // Randomise default API end point.
    random: source.random === true,
    // Start index
    index: source.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: source.dataAfterTimeout !== false
  };
  return result;
}
const configStorage = /* @__PURE__ */ Object.create(null);
const fallBackAPISources = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
const fallBackAPI = [];
while (fallBackAPISources.length > 0) {
  if (fallBackAPISources.length === 1) {
    fallBackAPI.push(fallBackAPISources.shift());
  } else {
    if (Math.random() > 0.5) {
      fallBackAPI.push(fallBackAPISources.shift());
    } else {
      fallBackAPI.push(fallBackAPISources.pop());
    }
  }
}
configStorage[""] = createAPIConfig({
  resources: ["https://api.iconify.design"].concat(fallBackAPI)
});
function addAPIProvider(provider, customConfig) {
  const config = createAPIConfig(customConfig);
  if (config === null) {
    return false;
  }
  configStorage[provider] = config;
  return true;
}
function getAPIConfig(provider) {
  return configStorage[provider];
}
function listAPIProviders() {
  return Object.keys(configStorage);
}
const detectFetch = () => {
  let callback;
  try {
    callback = fetch;
    if (typeof callback === "function") {
      return callback;
    }
  } catch (err) {
  }
};
let fetchModule = detectFetch();
function setFetch(fetch2) {
  fetchModule = fetch2;
}
function getFetch() {
  return fetchModule;
}
function calculateMaxLength(provider, prefix) {
  const config = getAPIConfig(provider);
  if (!config) {
    return 0;
  }
  let result;
  if (!config.maxURL) {
    result = 0;
  } else {
    let maxHostLength = 0;
    config.resources.forEach((item) => {
      const host = item;
      maxHostLength = Math.max(maxHostLength, host.length);
    });
    const url = prefix + ".json?icons=";
    result = config.maxURL - maxHostLength - config.path.length - url.length;
  }
  return result;
}
function shouldAbort(status) {
  return status === 404;
}
const prepare = (provider, prefix, icons) => {
  const results = [];
  const maxLength = calculateMaxLength(provider, prefix);
  const type = "icons";
  let item = {
    type,
    provider,
    prefix,
    icons: []
  };
  let length = 0;
  icons.forEach((name2, index2) => {
    length += name2.length + 1;
    if (length >= maxLength && index2 > 0) {
      results.push(item);
      item = {
        type,
        provider,
        prefix,
        icons: []
      };
      length = name2.length;
    }
    item.icons.push(name2);
  });
  results.push(item);
  return results;
};
function getPath(provider) {
  if (typeof provider === "string") {
    const config = getAPIConfig(provider);
    if (config) {
      return config.path;
    }
  }
  return "/";
}
const send = (host, params, callback) => {
  if (!fetchModule) {
    callback("abort", 424);
    return;
  }
  let path = getPath(params.provider);
  switch (params.type) {
    case "icons": {
      const prefix = params.prefix;
      const icons = params.icons;
      const iconsList = icons.join(",");
      const urlParams = new URLSearchParams({
        icons: iconsList
      });
      path += prefix + ".json?" + urlParams.toString();
      break;
    }
    case "custom": {
      const uri = params.uri;
      path += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;
      break;
    }
    default:
      callback("abort", 400);
      return;
  }
  let defaultError = 503;
  fetchModule(host + path).then((response) => {
    const status = response.status;
    if (status !== 200) {
      setTimeout(() => {
        callback(shouldAbort(status) ? "abort" : "next", status);
      });
      return;
    }
    defaultError = 501;
    return response.json();
  }).then((data) => {
    if (typeof data !== "object" || data === null) {
      setTimeout(() => {
        if (data === 404) {
          callback("abort", data);
        } else {
          callback("next", defaultError);
        }
      });
      return;
    }
    setTimeout(() => {
      callback("success", data);
    });
  }).catch(() => {
    callback("next", defaultError);
  });
};
const fetchAPIModule = {
  prepare,
  send
};
function sortIcons(icons) {
  const result = {
    loaded: [],
    missing: [],
    pending: []
  };
  const storage2 = /* @__PURE__ */ Object.create(null);
  icons.sort((a, b) => {
    if (a.provider !== b.provider) {
      return a.provider.localeCompare(b.provider);
    }
    if (a.prefix !== b.prefix) {
      return a.prefix.localeCompare(b.prefix);
    }
    return a.name.localeCompare(b.name);
  });
  let lastIcon = {
    provider: "",
    prefix: "",
    name: ""
  };
  icons.forEach((icon) => {
    if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {
      return;
    }
    lastIcon = icon;
    const provider = icon.provider;
    const prefix = icon.prefix;
    const name2 = icon.name;
    const providerStorage = storage2[provider] || (storage2[provider] = /* @__PURE__ */ Object.create(null));
    const localStorage2 = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));
    let list;
    if (name2 in localStorage2.icons) {
      list = result.loaded;
    } else if (prefix === "" || localStorage2.missing.has(name2)) {
      list = result.missing;
    } else {
      list = result.pending;
    }
    const item = {
      provider,
      prefix,
      name: name2
    };
    list.push(item);
  });
  return result;
}
function removeCallback(storages, id2) {
  storages.forEach((storage2) => {
    const items = storage2.loaderCallbacks;
    if (items) {
      storage2.loaderCallbacks = items.filter((row) => row.id !== id2);
    }
  });
}
function updateCallbacks(storage2) {
  if (!storage2.pendingCallbacksFlag) {
    storage2.pendingCallbacksFlag = true;
    setTimeout(() => {
      storage2.pendingCallbacksFlag = false;
      const items = storage2.loaderCallbacks ? storage2.loaderCallbacks.slice(0) : [];
      if (!items.length) {
        return;
      }
      let hasPending = false;
      const provider = storage2.provider;
      const prefix = storage2.prefix;
      items.forEach((item) => {
        const icons = item.icons;
        const oldLength = icons.pending.length;
        icons.pending = icons.pending.filter((icon) => {
          if (icon.prefix !== prefix) {
            return true;
          }
          const name2 = icon.name;
          if (storage2.icons[name2]) {
            icons.loaded.push({
              provider,
              prefix,
              name: name2
            });
          } else if (storage2.missing.has(name2)) {
            icons.missing.push({
              provider,
              prefix,
              name: name2
            });
          } else {
            hasPending = true;
            return true;
          }
          return false;
        });
        if (icons.pending.length !== oldLength) {
          if (!hasPending) {
            removeCallback([storage2], item.id);
          }
          item.callback(
            icons.loaded.slice(0),
            icons.missing.slice(0),
            icons.pending.slice(0),
            item.abort
          );
        }
      });
    });
  }
}
let idCounter = 0;
function storeCallback(callback, icons, pendingSources) {
  const id2 = idCounter++;
  const abort = removeCallback.bind(null, pendingSources, id2);
  if (!icons.pending.length) {
    return abort;
  }
  const item = {
    id: id2,
    icons,
    callback,
    abort
  };
  pendingSources.forEach((storage2) => {
    (storage2.loaderCallbacks || (storage2.loaderCallbacks = [])).push(item);
  });
  return abort;
}
function listToIcons(list, validate2 = true, simpleNames2 = false) {
  const result = [];
  list.forEach((item) => {
    const icon = typeof item === "string" ? stringToIcon(item, validate2, simpleNames2) : item;
    if (icon) {
      result.push(icon);
    }
  });
  return result;
}
var defaultConfig$2 = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function sendQuery(config, payload, query, done) {
  const resourcesCount = config.resources.length;
  const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;
  let resources;
  if (config.random) {
    let list = config.resources.slice(0);
    resources = [];
    while (list.length > 1) {
      const nextIndex = Math.floor(Math.random() * list.length);
      resources.push(list[nextIndex]);
      list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));
    }
    resources = resources.concat(list);
  } else {
    resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));
  }
  const startTime = Date.now();
  let status = "pending";
  let queriesSent = 0;
  let lastError;
  let timer = null;
  let queue = [];
  let doneCallbacks2 = [];
  if (typeof done === "function") {
    doneCallbacks2.push(done);
  }
  function resetTimer() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function abort() {
    if (status === "pending") {
      status = "aborted";
    }
    resetTimer();
    queue.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue = [];
  }
  function subscribe(callback, overwrite) {
    if (overwrite) {
      doneCallbacks2 = [];
    }
    if (typeof callback === "function") {
      doneCallbacks2.push(callback);
    }
  }
  function getQueryStatus() {
    return {
      startTime,
      payload,
      status,
      queriesSent,
      queriesPending: queue.length,
      subscribe,
      abort
    };
  }
  function failQuery() {
    status = "failed";
    doneCallbacks2.forEach((callback) => {
      callback(void 0, lastError);
    });
  }
  function clearQueue() {
    queue.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue = [];
  }
  function moduleResponse(item, response, data) {
    const isError = response !== "success";
    queue = queue.filter((queued) => queued !== item);
    switch (status) {
      case "pending":
        break;
      case "failed":
        if (isError || !config.dataAfterTimeout) {
          return;
        }
        break;
      default:
        return;
    }
    if (response === "abort") {
      lastError = data;
      failQuery();
      return;
    }
    if (isError) {
      lastError = data;
      if (!queue.length) {
        if (!resources.length) {
          failQuery();
        } else {
          execNext();
        }
      }
      return;
    }
    resetTimer();
    clearQueue();
    if (!config.random) {
      const index2 = config.resources.indexOf(item.resource);
      if (index2 !== -1 && index2 !== config.index) {
        config.index = index2;
      }
    }
    status = "completed";
    doneCallbacks2.forEach((callback) => {
      callback(data);
    });
  }
  function execNext() {
    if (status !== "pending") {
      return;
    }
    resetTimer();
    const resource = resources.shift();
    if (resource === void 0) {
      if (queue.length) {
        timer = setTimeout(() => {
          resetTimer();
          if (status === "pending") {
            clearQueue();
            failQuery();
          }
        }, config.timeout);
        return;
      }
      failQuery();
      return;
    }
    const item = {
      status: "pending",
      resource,
      callback: (status2, data) => {
        moduleResponse(item, status2, data);
      }
    };
    queue.push(item);
    queriesSent++;
    timer = setTimeout(execNext, config.rotate);
    query(resource, payload, item.callback);
  }
  setTimeout(execNext);
  return getQueryStatus;
}
function initRedundancy(cfg) {
  const config = {
    ...defaultConfig$2,
    ...cfg
  };
  let queries = [];
  function cleanup() {
    queries = queries.filter((item) => item().status === "pending");
  }
  function query(payload, queryCallback, doneCallback) {
    const query2 = sendQuery(
      config,
      payload,
      queryCallback,
      (data, error) => {
        cleanup();
        if (doneCallback) {
          doneCallback(data, error);
        }
      }
    );
    queries.push(query2);
    return query2;
  }
  function find(callback) {
    return queries.find((value) => {
      return callback(value);
    }) || null;
  }
  const instance = {
    query,
    find,
    setIndex: (index2) => {
      config.index = index2;
    },
    getIndex: () => config.index,
    cleanup
  };
  return instance;
}
function emptyCallback$1() {
}
const redundancyCache = /* @__PURE__ */ Object.create(null);
function getRedundancyCache(provider) {
  if (!redundancyCache[provider]) {
    const config = getAPIConfig(provider);
    if (!config) {
      return;
    }
    const redundancy = initRedundancy(config);
    const cachedReundancy = {
      config,
      redundancy
    };
    redundancyCache[provider] = cachedReundancy;
  }
  return redundancyCache[provider];
}
function sendAPIQuery(target, query, callback) {
  let redundancy;
  let send2;
  if (typeof target === "string") {
    const api = getAPIModule(target);
    if (!api) {
      callback(void 0, 424);
      return emptyCallback$1;
    }
    send2 = api.send;
    const cached = getRedundancyCache(target);
    if (cached) {
      redundancy = cached.redundancy;
    }
  } else {
    const config = createAPIConfig(target);
    if (config) {
      redundancy = initRedundancy(config);
      const moduleKey = target.resources ? target.resources[0] : "";
      const api = getAPIModule(moduleKey);
      if (api) {
        send2 = api.send;
      }
    }
  }
  if (!redundancy || !send2) {
    callback(void 0, 424);
    return emptyCallback$1;
  }
  return redundancy.query(query, send2, callback)().abort;
}
function emptyCallback() {
}
function loadedNewIcons(storage2) {
  if (!storage2.iconsLoaderFlag) {
    storage2.iconsLoaderFlag = true;
    setTimeout(() => {
      storage2.iconsLoaderFlag = false;
      updateCallbacks(storage2);
    });
  }
}
function checkIconNamesForAPI(icons) {
  const valid = [];
  const invalid = [];
  icons.forEach((name2) => {
    (name2.match(matchIconName) ? valid : invalid).push(name2);
  });
  return {
    valid,
    invalid
  };
}
function parseLoaderResponse(storage2, icons, data) {
  function checkMissing() {
    const pending = storage2.pendingIcons;
    icons.forEach((name2) => {
      if (pending) {
        pending.delete(name2);
      }
      if (!storage2.icons[name2]) {
        storage2.missing.add(name2);
      }
    });
  }
  if (data && typeof data === "object") {
    try {
      const parsed = addIconSet(storage2, data);
      if (!parsed.length) {
        checkMissing();
        return;
      }
    } catch (err) {
      console.error(err);
    }
  }
  checkMissing();
  loadedNewIcons(storage2);
}
function parsePossiblyAsyncResponse(response, callback) {
  if (response instanceof Promise) {
    response.then((data) => {
      callback(data);
    }).catch(() => {
      callback(null);
    });
  } else {
    callback(response);
  }
}
function loadNewIcons(storage2, icons) {
  if (!storage2.iconsToLoad) {
    storage2.iconsToLoad = icons;
  } else {
    storage2.iconsToLoad = storage2.iconsToLoad.concat(icons).sort();
  }
  if (!storage2.iconsQueueFlag) {
    storage2.iconsQueueFlag = true;
    setTimeout(() => {
      storage2.iconsQueueFlag = false;
      const { provider, prefix } = storage2;
      const icons2 = storage2.iconsToLoad;
      delete storage2.iconsToLoad;
      if (!icons2 || !icons2.length) {
        return;
      }
      const customIconLoader = storage2.loadIcon;
      if (storage2.loadIcons && (icons2.length > 1 || !customIconLoader)) {
        parsePossiblyAsyncResponse(
          storage2.loadIcons(icons2, prefix, provider),
          (data) => {
            parseLoaderResponse(storage2, icons2, data);
          }
        );
        return;
      }
      if (customIconLoader) {
        icons2.forEach((name2) => {
          const response = customIconLoader(name2, prefix, provider);
          parsePossiblyAsyncResponse(response, (data) => {
            const iconSet = data ? {
              prefix,
              icons: {
                [name2]: data
              }
            } : null;
            parseLoaderResponse(storage2, [name2], iconSet);
          });
        });
        return;
      }
      const { valid, invalid } = checkIconNamesForAPI(icons2);
      if (invalid.length) {
        parseLoaderResponse(storage2, invalid, null);
      }
      if (!valid.length) {
        return;
      }
      const api = prefix.match(matchIconName) ? getAPIModule(provider) : null;
      if (!api) {
        parseLoaderResponse(storage2, valid, null);
        return;
      }
      const params = api.prepare(provider, prefix, valid);
      params.forEach((item) => {
        sendAPIQuery(provider, item, (data) => {
          parseLoaderResponse(storage2, item.icons, data);
        });
      });
    });
  }
}
const loadIcons = (icons, callback) => {
  const cleanedIcons = listToIcons(icons, true, allowSimpleNames());
  const sortedIcons = sortIcons(cleanedIcons);
  if (!sortedIcons.pending.length) {
    let callCallback = true;
    if (callback) {
      setTimeout(() => {
        if (callCallback) {
          callback(
            sortedIcons.loaded,
            sortedIcons.missing,
            sortedIcons.pending,
            emptyCallback
          );
        }
      });
    }
    return () => {
      callCallback = false;
    };
  }
  const newIcons = /* @__PURE__ */ Object.create(null);
  const sources2 = [];
  let lastProvider, lastPrefix;
  sortedIcons.pending.forEach((icon) => {
    const { provider, prefix } = icon;
    if (prefix === lastPrefix && provider === lastProvider) {
      return;
    }
    lastProvider = provider;
    lastPrefix = prefix;
    sources2.push(getStorage(provider, prefix));
    const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));
    if (!providerNewIcons[prefix]) {
      providerNewIcons[prefix] = [];
    }
  });
  sortedIcons.pending.forEach((icon) => {
    const { provider, prefix, name: name2 } = icon;
    const storage2 = getStorage(provider, prefix);
    const pendingQueue = storage2.pendingIcons || (storage2.pendingIcons = /* @__PURE__ */ new Set());
    if (!pendingQueue.has(name2)) {
      pendingQueue.add(name2);
      newIcons[provider][prefix].push(name2);
    }
  });
  sources2.forEach((storage2) => {
    const list = newIcons[storage2.provider][storage2.prefix];
    if (list.length) {
      loadNewIcons(storage2, list);
    }
  });
  return callback ? storeCallback(callback, sortedIcons, sources2) : emptyCallback;
};
const loadIcon$1 = (icon) => {
  return new Promise((fulfill, reject) => {
    const iconObj = typeof icon === "string" ? stringToIcon(icon, true) : icon;
    if (!iconObj) {
      reject(icon);
      return;
    }
    loadIcons([iconObj || icon], (loaded) => {
      if (loaded.length && iconObj) {
        const data = getIconData(iconObj);
        if (data) {
          fulfill({
            ...defaultIconProps$1,
            ...data
          });
          return;
        }
      }
      reject(icon);
    });
  });
};
function setCustomIconsLoader(loader, prefix, provider) {
  getStorage("", prefix).loadIcons = loader;
}
function mergeCustomisations(defaults, item) {
  const result = {
    ...defaults
  };
  for (const key in item) {
    const value = item[key];
    const valueType = typeof value;
    if (key in defaultIconSizeCustomisations$1) {
      if (value === null || value && (valueType === "string" || valueType === "number")) {
        result[key] = value;
      }
    } else if (valueType === typeof result[key]) {
      result[key] = key === "rotate" ? value % 4 : value;
    }
  }
  return result;
}
const separator = /[\s,]+/;
function flipFromString(custom, flip) {
  flip.split(separator).forEach((str) => {
    const value = str.trim();
    switch (value) {
      case "horizontal":
        custom.hFlip = true;
        break;
      case "vertical":
        custom.vFlip = true;
        break;
    }
  });
}
function rotateFromString(value, defaultValue = 0) {
  const units = value.replace(/^-?[0-9.]*/, "");
  function cleanup(value2) {
    while (value2 < 0) {
      value2 += 4;
    }
    return value2 % 4;
  }
  if (units === "") {
    const num = parseInt(value);
    return isNaN(num) ? 0 : cleanup(num);
  } else if (units !== value) {
    let split = 0;
    switch (units) {
      case "%":
        split = 25;
        break;
      case "deg":
        split = 90;
    }
    if (split) {
      let num = parseFloat(value.slice(0, value.length - units.length));
      if (isNaN(num)) {
        return 0;
      }
      num = num / split;
      return num % 1 === 0 ? cleanup(num) : 0;
    }
  }
  return defaultValue;
}
function iconToHTML$1(body, attributes) {
  let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const attr in attributes) {
    renderAttribsHTML += " " + attr + '="' + attributes[attr] + '"';
  }
  return '<svg xmlns="http://www.w3.org/2000/svg"' + renderAttribsHTML + ">" + body + "</svg>";
}
function encodeSVGforURL$1(svg) {
  return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function svgToData$1(svg) {
  return "data:image/svg+xml," + encodeSVGforURL$1(svg);
}
function svgToURL$1(svg) {
  return 'url("' + svgToData$1(svg) + '")';
}
const defaultExtendedIconCustomisations = {
  ...defaultIconCustomisations$1,
  inline: false
};
const svgDefaults = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": true,
  "role": "img"
};
const commonProps = {
  display: "inline-block"
};
const monotoneProps = {
  backgroundColor: "currentColor"
};
const coloredProps = {
  backgroundColor: "transparent"
};
const propsToAdd = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
};
const propsToAddTo = {
  webkitMask: monotoneProps,
  mask: monotoneProps,
  background: coloredProps
};
for (const prefix in propsToAddTo) {
  const list = propsToAddTo[prefix];
  for (const prop in propsToAdd) {
    list[prefix + prop] = propsToAdd[prop];
  }
}
const customisationAliases = {};
["horizontal", "vertical"].forEach((prefix) => {
  const attr = prefix.slice(0, 1) + "Flip";
  customisationAliases[prefix + "-flip"] = attr;
  customisationAliases[prefix.slice(0, 1) + "-flip"] = attr;
  customisationAliases[prefix + "Flip"] = attr;
});
function fixSize(value) {
  return value + (value.match(/^[-0-9.]+$/) ? "px" : "");
}
const render = (icon, props) => {
  const customisations = mergeCustomisations(defaultExtendedIconCustomisations, props);
  const componentProps = { ...svgDefaults };
  const mode = props.mode || "svg";
  const style2 = {};
  const propsStyle = props.style;
  const customStyle = typeof propsStyle === "object" && !(propsStyle instanceof Array) ? propsStyle : {};
  for (let key in props) {
    const value = props[key];
    if (value === void 0) {
      continue;
    }
    switch (key) {
      // Properties to ignore
      case "icon":
      case "style":
      case "onLoad":
      case "mode":
      case "ssr":
        break;
      // Boolean attributes
      case "inline":
      case "hFlip":
      case "vFlip":
        customisations[key] = value === true || value === "true" || value === 1;
        break;
      // Flip as string: 'horizontal,vertical'
      case "flip":
        if (typeof value === "string") {
          flipFromString(customisations, value);
        }
        break;
      // Color: override style
      case "color":
        style2.color = value;
        break;
      // Rotation as string
      case "rotate":
        if (typeof value === "string") {
          customisations[key] = rotateFromString(value);
        } else if (typeof value === "number") {
          customisations[key] = value;
        }
        break;
      // Remove aria-hidden
      case "ariaHidden":
      case "aria-hidden":
        if (value !== true && value !== "true") {
          delete componentProps["aria-hidden"];
        }
        break;
      default: {
        const alias = customisationAliases[key];
        if (alias) {
          if (value === true || value === "true" || value === 1) {
            customisations[alias] = true;
          }
        } else if (defaultExtendedIconCustomisations[key] === void 0) {
          componentProps[key] = value;
        }
      }
    }
  }
  const item = iconToSVG$1(icon, customisations);
  const renderAttribs = item.attributes;
  if (customisations.inline) {
    style2.verticalAlign = "-0.125em";
  }
  if (mode === "svg") {
    componentProps.style = {
      ...style2,
      ...customStyle
    };
    Object.assign(componentProps, renderAttribs);
    let localCounter = 0;
    let id2 = props.id;
    if (typeof id2 === "string") {
      id2 = id2.replace(/-/g, "_");
    }
    componentProps["innerHTML"] = replaceIDs(item.body, id2 ? () => id2 + "ID" + localCounter++ : "iconifyVue");
    return h("svg", componentProps);
  }
  const { body, width, height } = icon;
  const useMask = mode === "mask" || (mode === "bg" ? false : body.indexOf("currentColor") !== -1);
  const html = iconToHTML$1(body, {
    ...renderAttribs,
    width: width + "",
    height: height + ""
  });
  componentProps.style = {
    ...style2,
    "--svg": svgToURL$1(html),
    "width": fixSize(renderAttribs.width),
    "height": fixSize(renderAttribs.height),
    ...commonProps,
    ...useMask ? monotoneProps : coloredProps,
    ...customStyle
  };
  return h("span", componentProps);
};
allowSimpleNames(true);
setAPIModule("", fetchAPIModule);
const emptyIcon = {
  ...defaultIconProps$1,
  body: ""
};
const Icon = defineComponent((props, { emit }) => {
  const loader = ref(null);
  function abortLoading() {
    if (loader.value) {
      loader.value.abort?.();
      loader.value = null;
    }
  }
  const rendering = ref(!!props.ssr);
  const lastRenderedIconName = ref("");
  const iconData = shallowRef(null);
  function getIcon2() {
    const icon = props.icon;
    if (typeof icon === "object" && icon !== null && typeof icon.body === "string") {
      lastRenderedIconName.value = "";
      return {
        data: icon
      };
    }
    let iconName;
    if (typeof icon !== "string" || (iconName = stringToIcon(icon, false, true)) === null) {
      return null;
    }
    let data = getIconData(iconName);
    if (!data) {
      const oldState = loader.value;
      if (!oldState || oldState.name !== icon) {
        if (data === null) {
          loader.value = {
            name: icon
          };
        } else {
          loader.value = {
            name: icon,
            abort: loadIcons([iconName], updateIconData)
          };
        }
      }
      return null;
    }
    abortLoading();
    if (lastRenderedIconName.value !== icon) {
      lastRenderedIconName.value = icon;
      nextTick(() => {
        emit("load", icon);
      });
    }
    const customise = props.customise;
    if (customise) {
      data = Object.assign({}, data);
      const customised = customise(data.body, iconName.name, iconName.prefix, iconName.provider);
      if (typeof customised === "string") {
        data.body = customised;
      }
    }
    const classes = ["iconify"];
    if (iconName.prefix !== "") {
      classes.push("iconify--" + iconName.prefix);
    }
    if (iconName.provider !== "") {
      classes.push("iconify--" + iconName.provider);
    }
    return { data, classes };
  }
  function updateIconData() {
    const icon = getIcon2();
    if (!icon) {
      iconData.value = null;
    } else if (icon.data !== iconData.value?.data) {
      iconData.value = icon;
    }
  }
  if (rendering.value) {
    updateIconData();
  }
  watch(() => props.icon, updateIconData);
  return () => {
    const icon = iconData.value;
    if (!icon) {
      return render(emptyIcon, props);
    }
    let newProps = props;
    if (icon.classes) {
      newProps = {
        ...props,
        class: icon.classes.join(" ")
      };
    }
    return render({
      ...defaultIconProps$1,
      ...icon.data
    }, newProps);
  };
}, {
  props: [
    // Icon and render mode
    "icon",
    "mode",
    "ssr",
    // Layout and style
    "width",
    "height",
    "style",
    "color",
    "inline",
    // Transformations
    "rotate",
    "hFlip",
    "horizontalFlip",
    "vFlip",
    "verticalFlip",
    "flip",
    // Misc
    "id",
    "ariaHidden",
    "customise",
    "title"
  ],
  emits: ["load"]
});
const _api = {
  getAPIConfig,
  setAPIModule,
  sendAPIQuery,
  setFetch,
  getFetch,
  listAPIProviders
};
const plugin_xOlP7bygCPMvfAMNVzJMTA1dWEVSX3FRDAocIaN5oYs = /* @__PURE__ */ defineNuxtPlugin({
  name: "@nuxt/icon",
  setup() {
    const configs = /* @__PURE__ */ useRuntimeConfig();
    const options = useAppConfig().icon;
    _api.setFetch($fetch.native);
    const resources = [];
    if (options.provider === "server") {
      const baseURL2 = configs.app?.baseURL?.replace(/\/$/, "") ?? "";
      resources.push(baseURL2 + (options.localApiEndpoint || "/api/_nuxt_icon"));
      if (options.fallbackToApi === true || options.fallbackToApi === "client-only") {
        resources.push(options.iconifyApiEndpoint);
      }
    } else if (options.provider === "none") {
      _api.setFetch(() => Promise.resolve(new Response()));
    } else {
      resources.push(options.iconifyApiEndpoint);
    }
    async function customIconLoader(icons, prefix) {
      try {
        const data = await $fetch(resources[0] + "/" + prefix + ".json", {
          query: {
            icons: icons.join(",")
          }
        });
        if (!data || data.prefix !== prefix || !data.icons)
          throw new Error("Invalid data" + JSON.stringify(data));
        return data;
      } catch (e) {
        console.error("Failed to load custom icons", e);
        return null;
      }
    }
    addAPIProvider("", { resources });
    for (const prefix of options.customCollections || []) {
      if (prefix)
        setCustomIconsLoader(customIconLoader, prefix);
    }
  }
  // For type portability
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
});
const shades = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950];
function getColor(color2, shade) {
  if (color2 in colors && typeof colors[color2] === "object" && shade in colors[color2]) {
    return colors[color2][shade];
  }
  return "";
}
function generateShades(key, value, prefix) {
  const prefixStr = prefix ? `${prefix}-` : "";
  return `${shades.map((shade) => `--ui-color-${key}-${shade}: var(--${prefixStr}color-${value === "neutral" ? "old-neutral" : value}-${shade}, ${getColor(value, shade)});`).join("\n  ")}`;
}
function generateColor(key, shade) {
  return `--ui-${key}: var(--ui-color-${key}-${shade});`;
}
const colors_bE0YZl93PIqdfvWM0aF3q3gOe_ktYfgf7_Jcz_ItiYo = /* @__PURE__ */ defineNuxtPlugin(() => {
  const appConfig2 = useAppConfig();
  useNuxtApp();
  const root = computed(() => {
    const { neutral, ...colors2 } = appConfig2.ui.colors;
    const prefix = appConfig2.ui.prefix;
    return `@layer theme {
  :root, :host {
  ${Object.entries(appConfig2.ui.colors).map(([key, value]) => generateShades(key, value, prefix)).join("\n  ")}
  }
  :root, :host, .light {
  ${Object.keys(colors2).map((key) => generateColor(key, 500)).join("\n  ")}
  }
  .dark {
  ${Object.keys(colors2).map((key) => generateColor(key, 400)).join("\n  ")}
  }
}`;
  });
  const headData = {
    style: [{
      innerHTML: () => root.value,
      tagPriority: -2,
      id: "nuxt-ui-colors"
    }]
  };
  useHead(headData);
});
const preference = "system";
const plugin_server_1VsdcVlQN2tv6RG6Fy0EvkojZKbQX61TrTVJeEFBIfo = /* @__PURE__ */ defineNuxtPlugin((nuxtApp) => {
  const colorMode = nuxtApp.ssrContext?.islandContext ? ref({}) : useState("color-mode", () => reactive({
    preference,
    value: preference,
    unknown: true,
    forced: false
  })).value;
  const htmlAttrs = {};
  {
    useHead({ htmlAttrs });
  }
  useRouter().afterEach((to) => {
    const forcedColorMode = to.meta.colorMode;
    if (forcedColorMode && forcedColorMode !== "system") {
      colorMode.value = htmlAttrs["data-color-mode-forced"] = forcedColorMode;
      colorMode.forced = true;
    } else if (forcedColorMode === "system") {
      console.warn("You cannot force the colorMode to system at the page level.");
    }
  });
  nuxtApp.provide("colorMode", colorMode);
});
var E = /* @__PURE__ */ ((r) => (r.IDLE = "idle", r.IMAGE_LOADING = "image-loading", r.TEXTURE_LOADING = "texture-loading", r.TILE_LOADING = "tile-loading", r.COMPLETE = "complete", r.ERROR = "error", r))(E || {});
const g = {
  minScale: 0.1,
  maxScale: 10,
  wheelStep: 0.1,
  pinchStep: 0.5,
  doubleClickStep: 2,
  doubleClickMode: "toggle",
  animationTime: 200,
  wheelDisabled: false,
  touchPadDisabled: false,
  pinchDisabled: false,
  doubleClickDisabled: false,
  panningDisabled: false,
  velocityDisabled: true,
  centerOnInit: true,
  debug: false,
  limitToBounds: true,
  smooth: true,
  tileEnabled: true,
  tileSize: 1024,
  alignmentAnimation: {
    duration: 300,
    easing: (n) => 1 - Math.pow(1 - n, 4)
    // easeOutQuart
  },
  velocityAnimation: {
    duration: 400,
    easing: (n) => 1 - Math.pow(1 - n, 3)
    // easeOutCubic
  }
}, V = {
  /** 渲染节流间隔 (60fps) */
  THROTTLE_MS: 16
}, Z = {
  /** 四次方缓出函数 */
  easeOutQuart: (n) => 1 - Math.pow(1 - n, 4)
}, _ = {
  /** 双击检测时间间隔 */
  DOUBLE_CLICK_DELAY: 300
};
function M(n, t, e) {
  return Math.min(Math.max(n, t), e);
}
function B(n, t) {
  const e = t.x - n.x, i = t.y - n.y;
  return Math.sqrt(e * e + i * i);
}
function P(n) {
  const t = n.reduce(
    (e, i) => ({
      x: e.x + i.x,
      y: e.y + i.y
    }),
    { x: 0, y: 0 }
  );
  return {
    x: t.x / n.length,
    y: t.y / n.length
  };
}
function k(n) {
  return Array.from(n).map((t) => ({
    x: t.clientX,
    y: t.clientY
  }));
}
function Q(n, t) {
  let e = 0;
  return (...i) => {
    const s = Date.now();
    s - e >= t && (e = s, n(...i));
  };
}
function j(n, t, e) {
  return new Float32Array([n, 0, 0, 0, n, 0, t, e, 1]);
}
function q() {
  try {
    const n = (void 0).createElement("canvas");
    return !!(n.getContext("webgl") || n.getContext("experimental-webgl"));
  } catch {
    return false;
  }
}
function S(n) {
  try {
    return n.getParameter(n.MAX_TEXTURE_SIZE);
  } catch {
    return 4096;
  }
}
const K = `
  attribute vec2 a_position;
  attribute vec2 a_texCoord;
  
  uniform mat3 u_matrix;
  uniform vec2 u_resolution;
  
  varying vec2 v_texCoord;
  
  void main() {
    // 将顶点位置从像素坐标转换为裁剪空间坐标
    vec2 position = (u_matrix * vec3(a_position, 1)).xy;
    
    // 从像素坐标转换为 0 到 1
    vec2 zeroToOne = position / u_resolution;
    
    // 从 0->1 转换为 0->2
    vec2 zeroToTwo = zeroToOne * 2.0;
    
    // 从 0->2 转换为 -1->+1 (裁剪空间)
    vec2 clipSpace = zeroToTwo - 1.0;
    
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
    
    // 传递纹理坐标给片段着色器
    v_texCoord = a_texCoord;
  }
`, $ = `
  precision mediump float;
  
  uniform sampler2D u_image;
  uniform bool u_debugTiles;
  uniform vec4 u_tileBorderColor;
  uniform vec2 u_tileBorderWidth;
  
  varying vec2 v_texCoord;
  
  void main() {
    vec4 color = texture2D(u_image, v_texCoord);

    if (u_debugTiles) {
      float left = 1.0 - step(u_tileBorderWidth.x, v_texCoord.x);
      float right = 1.0 - step(u_tileBorderWidth.x, 1.0 - v_texCoord.x);
      float top = 1.0 - step(u_tileBorderWidth.y, v_texCoord.y);
      float bottom = 1.0 - step(u_tileBorderWidth.y, 1.0 - v_texCoord.y);
      float border = clamp(max(max(left, right), max(top, bottom)), 0.0, 1.0);
      color = mix(color, u_tileBorderColor, border);
    }

    gl_FragColor = color;
  }
`;
function U(n, t, e) {
  const i = n.createShader(t);
  return i ? (n.shaderSource(i, e), n.compileShader(i), n.getShaderParameter(i, n.COMPILE_STATUS) ? i : (console.error("An error occurred compiling the shaders:", n.getShaderInfoLog(i)), n.deleteShader(i), null)) : (console.error("Unable to create shader"), null);
}
function J(n, t, e) {
  const i = n.createProgram();
  return i ? (n.attachShader(i, t), n.attachShader(i, e), n.linkProgram(i), n.getProgramParameter(i, n.LINK_STATUS) ? i : (console.error("Unable to initialize the shader program:", n.getProgramInfoLog(i)), null)) : (console.error("Unable to create shader program"), null);
}
function tt(n) {
  const t = U(n, n.VERTEX_SHADER, K), e = U(n, n.FRAGMENT_SHADER, $);
  if (!t || !e)
    return null;
  const i = J(n, t, e);
  return n.deleteShader(t), n.deleteShader(e), i;
}
const et = `// @ts-nocheck
/// <reference lib="webworker" />

/**
 * Image decoder worker
 * @param {MessageEvent} event
 * @returns
 */
self.onmessage = async (event) => {
  const { type } = event.data

  if (type === 'load') {
    const { payload } = event.data
    try {
      let src = payload.src
      try {
        const absolute = new URL(src, self.location?.origin || 'http://localhost')
        src = absolute.toString()
      } catch { /* empty */ }
      const response = await fetch(src, { mode: 'cors' })
      if (!response.ok) {
        throw new Error(\`Failed to fetch image: \${response.status}\`)
      }

      const blob = await response.blob()

      const imageBitmap = await createImageBitmap(blob)

      self.postMessage(
        {
          type: 'loaded',
          payload: {
            imageBitmap,
            width: imageBitmap.width,
            height: imageBitmap.height,
          },
        },
        [imageBitmap],
      )
    } catch (error) {
      self.postMessage({
        type: 'load-error',
        payload: error instanceof Error ? error : 'Unknown error',
      })
    }
  }
}
`, D = 2.4, it = [
  0.4,
  0.7,
  0.9,
  0.25
];
class st {
  constructor(t, e = {}) {
    this.image = null, this.texture = null, this.program = null, this.tiles = [], this.useTiles = false, this.worker = null, this.imageLoadingResolve = null, this.imageLoadingReject = null, this.transform = { scale: 1, translateX: 0, translateY: 0 }, this.initialScale = 1, this.animation = null, this.animationId = null, this.isDragging = false, this.lastMousePos = null, this.touchState = null, this.lastClickTime = 0, this.lastTouchTime = 0, this.lastTouchPosition = null, this.hasMoved = false, this.positionBuffer = null, this.texCoordBuffer = null, this.positionLocation = -1, this.texCoordLocation = -1, this.matrixLocation = null, this.resolutionLocation = null, this.imageLocation = null, this.tileDebugLocation = null, this.tileBorderColorLocation = null, this.tileBorderWidthLocation = null, this.resizeObserver = null, this.currentQuality = "unknown", this.isLoadingTexture = false, this.currentLoadingState = E.IDLE, this.canvas = t, this.config = { ...g, ...e };
    const i = t.getContext("webgl", {
      alpha: true,
      antialias: true,
      depth: false,
      stencil: false,
      preserveDrawingBuffer: false
    });
    if (!i)
      throw new Error("WebGL not supported");
    this.gl = i, this.throttledRender = Q(
      () => this.render(),
      V.THROTTLE_MS
    ), this.boundHandleMouseUp = this.handleMouseUp.bind(this), this.boundHandleMouseMove = this.handleMouseMove.bind(this), this.boundHandleMouseLeave = this.handleMouseLeave.bind(this), this.init();
  }
  init() {
    this.setupWebGL(), this.setupWorker(), this.setupEventListeners(), this.setupResizeObserver(), this.resize();
  }
  setupWebGL() {
    const { gl: t } = this;
    if (this.program = tt(t), !this.program)
      throw new Error("Failed to create shader program");
    t.useProgram(this.program), this.positionLocation = t.getAttribLocation(this.program, "a_position"), this.texCoordLocation = t.getAttribLocation(this.program, "a_texCoord"), this.matrixLocation = t.getUniformLocation(this.program, "u_matrix"), this.resolutionLocation = t.getUniformLocation(
      this.program,
      "u_resolution"
    ), this.imageLocation = t.getUniformLocation(this.program, "u_image"), this.tileDebugLocation = t.getUniformLocation(this.program, "u_debugTiles"), this.tileBorderColorLocation = t.getUniformLocation(
      this.program,
      "u_tileBorderColor"
    ), this.tileBorderWidthLocation = t.getUniformLocation(
      this.program,
      "u_tileBorderWidth"
    ), this.createBuffers(), t.enable(t.BLEND), t.blendFunc(t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA), t.clearColor(0, 0, 0, 0);
  }
  setupWorker() {
    if (typeof Worker > "u") {
      console.warn("Web Workers not supported, falling back to main thread");
      return;
    }
    this.worker = new Worker(
      URL.createObjectURL(new Blob([et])),
      {
        name: "image-decoder-worker"
      }
    ), this.worker.onmessage = (t) => {
      const { type: e, payload: i } = t.data;
      switch (e) {
        case "loaded":
          this.handleWorkerImageLoaded(i);
          break;
        case "load-error":
          this.handleWorkerImageLoadError(i);
          break;
      }
    }, this.worker.onerror = (t) => {
      console.error("Worker error:", t);
    };
  }
  handleWorkerImageLoaded(t) {
    const { imageBitmap: e } = t;
    try {
      this.image = e;
      const i = this.shouldUseTiles(e);
      let s = false;
      i && (this.emitLoadingStateChange(true, E.TILE_LOADING), s = this.createTiles(e)), s ? this.updatePositionBuffer() : (this.emitLoadingStateChange(true, E.TEXTURE_LOADING), this.createTexture(e)), this.useTiles = s, this.config.centerOnInit && this.centerImage(), this.currentQuality = "high", this.emitLoadingStateChange(
        false,
        E.COMPLETE,
        this.currentQuality
      ), this.render(), this.imageLoadingResolve && this.imageLoadingResolve();
    } catch (i) {
      console.error("Failed to create texture from ImageBitmap:", i), this.emitLoadingStateChange(false, E.ERROR), this.imageLoadingReject && this.imageLoadingReject(i);
    }
  }
  handleWorkerImageLoadError(t) {
    console.error("Image load error from worker:", t), this.emitLoadingStateChange(false, E.ERROR), this.imageLoadingReject && this.imageLoadingReject(t);
  }
  createBuffers() {
    const { gl: t } = this;
    this.positionBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this.positionBuffer), this.texCoordBuffer = t.createBuffer(), t.bindBuffer(t.ARRAY_BUFFER, this.texCoordBuffer);
    const e = new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]);
    t.bufferData(t.ARRAY_BUFFER, e, t.STATIC_DRAW);
  }
  updatePositionBuffer() {
    if (!this.image || !this.positionBuffer) return;
    const { gl: t } = this, { width: e, height: i } = this.image;
    t.bindBuffer(t.ARRAY_BUFFER, this.positionBuffer);
    const s = new Float32Array([
      0,
      0,
      e,
      0,
      0,
      i,
      0,
      i,
      e,
      0,
      e,
      i
    ]);
    t.bufferData(t.ARRAY_BUFFER, s, t.STATIC_DRAW);
  }
  setupEventListeners() {
    this.canvas.addEventListener("mousedown", this.handleMouseDown.bind(this)), this.canvas.addEventListener("mouseleave", this.boundHandleMouseLeave), this.canvas.addEventListener("wheel", this.handleWheel.bind(this), {
      passive: false
    }), this.canvas.addEventListener("click", this.handleClick.bind(this)), this.canvas.addEventListener(
      "touchstart",
      this.handleTouchStart.bind(this),
      { passive: false }
    ), this.canvas.addEventListener("touchmove", this.handleTouchMove.bind(this), {
      passive: false
    }), this.canvas.addEventListener("touchend", this.handleTouchEnd.bind(this), {
      passive: false
    }), this.canvas.addEventListener(
      "webglcontextlost",
      this.handleContextLost.bind(this),
      false
    ), this.canvas.addEventListener(
      "webglcontextrestored",
      this.handleContextRestored.bind(this),
      false
    ), this.canvas.addEventListener("contextmenu", (t) => t.preventDefault());
  }
  setupResizeObserver() {
    this.resizeObserver = new ResizeObserver(() => {
      this.resize();
    }), this.resizeObserver.observe(this.canvas);
  }
  emitLoadingStateChange(t, e, i) {
    this.isLoadingTexture = t, e && (this.currentLoadingState = e), this.onLoadingStateChange?.(t, e, i);
  }
  async loadImage(t) {
    return console.log("Post load image:", t), this.emitLoadingStateChange(true, E.IMAGE_LOADING), new Promise((e, i) => {
      if (this.imageLoadingResolve = e, this.imageLoadingReject = i, this.worker)
        try {
          const s = new URL(t, self.location?.origin || "http://localhost");
          this.worker.postMessage({ type: "load", payload: { src: s.toString() } });
        } catch {
          this.worker.postMessage({ type: "load", payload: { src: t } });
        }
      else
        i(new Error("No worker available"));
    });
  }
  createTexture(t) {
    const { gl: e } = this;
    this.cleanupTiles(), this.useTiles = false, this.texture && e.deleteTexture(this.texture);
    const i = S(e), s = t.width ?? t.width ?? t.width, a = t.height ?? t.height ?? t.height;
    let o = t;
    if (typeof s == "number" && typeof a == "number" && (s > i || a > i)) {
      const r = Math.min(
        i / s,
        i / a
      ), d = Math.max(1, Math.floor(s * r)), c2 = Math.max(1, Math.floor(a * r)), m = (void 0).createElement("canvas");
      m.width = d, m.height = c2;
      const f = m.getContext("2d");
      f ? (f.imageSmoothingEnabled = true, f.imageSmoothingQuality = "high", f.drawImage(t, 0, 0, d, c2), o = m) : o = t;
    }
    return this.texture = e.createTexture(), e.bindTexture(e.TEXTURE_2D, this.texture), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texImage2D(
      e.TEXTURE_2D,
      0,
      e.RGBA,
      e.RGBA,
      e.UNSIGNED_BYTE,
      o
    ), this.image = o, this.updatePositionBuffer(), this.texture;
  }
  cleanupTiles() {
    if (!this.tiles.length) return;
    const { gl: t } = this;
    for (const e of this.tiles)
      e.texture && t.deleteTexture(e.texture);
    this.tiles = [];
  }
  shouldUseTiles(t) {
    if (!t) return false;
    const e = S(this.gl);
    return t.width > e || t.height > e ? true : this.config.tileEnabled ? t.width > this.config.tileSize || t.height > this.config.tileSize : false;
  }
  createTiles(t) {
    const { gl: e } = this;
    this.texture && (e.deleteTexture(this.texture), this.texture = null), this.cleanupTiles();
    const i = S(e), s = Math.max(
      1,
      Math.min(this.config.tileSize, i)
    ), a = t.width ?? t.width ?? t.width, o = t.height ?? t.height ?? t.height;
    if (!a || !o)
      return false;
    const r = Math.ceil(a / s), d = Math.ceil(o / s), c2 = (void 0).createElement("canvas"), m = [], f = () => {
      for (const v of m)
        v.texture && e.deleteTexture(v.texture);
    };
    try {
      for (let v = 0; v < d; v++)
        for (let x = 0; x < r; x++) {
          const E2 = x * s, L = v * s, b = Math.min(s, a - E2), T = Math.min(s, o - L);
          if (b <= 0 || T <= 0) continue;
          c2.width = b, c2.height = T;
          const C = c2.getContext("2d");
          if (!C)
            return console.warn(
              "Failed to acquire 2D context for tile rendering, falling back to single texture."
            ), f(), this.cleanupTiles(), false;
          C.clearRect(0, 0, b, T), C.drawImage(
            t,
            E2,
            L,
            b,
            T,
            0,
            0,
            b,
            T
          );
          const h2 = e.createTexture();
          if (!h2)
            return console.warn(
              "Failed to create tile texture, falling back to single texture rendering."
            ), f(), this.cleanupTiles(), false;
          e.bindTexture(e.TEXTURE_2D, h2), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texImage2D(
            e.TEXTURE_2D,
            0,
            e.RGBA,
            e.RGBA,
            e.UNSIGNED_BYTE,
            c2
          ), m.push({
            x: E2,
            y: L,
            width: b,
            height: T,
            texture: h2
          });
        }
    } catch (v) {
      return console.warn("Failed to create tiles, falling back to single texture.", v), f(), this.cleanupTiles(), false;
    } finally {
      e.bindTexture(e.TEXTURE_2D, null);
    }
    return this.tiles = m, this.useTiles = this.tiles.length > 0, this.useTiles;
  }
  getVisibleTiles() {
    if (!this.useTiles || !this.tiles.length)
      return [];
    const t = this.transform.scale;
    if (!isFinite(t) || t <= 0)
      return this.tiles;
    const e = -this.transform.translateX / t, i = -this.transform.translateY / t, s = (this.canvas.width - this.transform.translateX) / t, a = (this.canvas.height - this.transform.translateY) / t;
    return this.tiles.filter((o) => {
      const r = o.x + o.width, d = o.y + o.height;
      return r >= e && o.x <= s && d >= i && o.y <= a;
    });
  }
  resize() {
    const t = this.canvas.getBoundingClientRect(), e = (void 0).devicePixelRatio || 1;
    if (!(t.width <= 0 || t.height <= 0)) {
      if (this.canvas.width = t.width * e, this.canvas.height = t.height * e, this.gl.viewport(0, 0, this.canvas.width, this.canvas.height), this.image) {
        const i = this.transform.translateX, s = this.transform.translateY;
        this.constrainToBounds(), (i !== this.transform.translateX || s !== this.transform.translateY) && this.emitTransformChange();
      }
      this.image && (this.texture || this.useTiles) && this.throttledRender();
    }
  }
  centerImage() {
    if (!this.image || this.image.width <= 0 || this.image.height <= 0) return;
    const t = this.canvas.width / this.canvas.height, e = this.image.width / this.image.height;
    if (this.canvas.width <= 0 || this.canvas.height <= 0) return;
    let i;
    e > t ? i = this.canvas.width / this.image.width : i = this.canvas.height / this.image.height, this.initialScale = i;
    const s = this.clampScale(i), a = this.image.width * s, o = this.image.height * s;
    this.transform = {
      scale: s,
      translateX: (this.canvas.width - a) / 2,
      translateY: (this.canvas.height - o) / 2
    }, this.emitZoomChange(), this.emitTransformChange();
  }
  constrainToBounds() {
    if (!this.config.limitToBounds || !this.image) return;
    const t = this.image.width * this.transform.scale, e = this.image.height * this.transform.scale;
    if (t <= this.canvas.width)
      this.transform.translateX = (this.canvas.width - t) / 2;
    else {
      const s = this.canvas.width - t;
      this.transform.translateX = M(
        this.transform.translateX,
        s,
        0
      );
    }
    if (e <= this.canvas.height)
      this.transform.translateY = (this.canvas.height - e) / 2;
    else {
      const s = this.canvas.height - e;
      this.transform.translateY = M(
        this.transform.translateY,
        s,
        0
      );
    }
  }
  /**
   * 获取基于相对缩放的绝对最小缩放值
   */
  getAbsoluteMinScale() {
    return this.initialScale * this.config.minScale;
  }
  /**
   * 获取基于相对缩放的绝对最大缩放值
   */
  getAbsoluteMaxScale() {
    return this.initialScale * this.config.maxScale;
  }
  /**
   * 基于相对缩放限制来约束绝对缩放值
   */
  clampScale(t) {
    return M(t, this.getAbsoluteMinScale(), this.getAbsoluteMaxScale());
  }
  render() {
    if (!this.program || !this.texture && !this.useTiles || this.useTiles && !this.tiles.length) return;
    const { gl: t } = this;
    try {
      if (t.isContextLost()) {
        console.warn("WebGL context is lost, skipping render");
        return;
      }
      this.updateAnimation(), t.clear(t.COLOR_BUFFER_BIT), t.useProgram(this.program), t.uniform2f(this.resolutionLocation, this.canvas.width, this.canvas.height), t.uniform1i(this.imageLocation, 0);
      const e = j(
        this.transform.scale,
        this.transform.translateX,
        this.transform.translateY
      );
      if (t.uniformMatrix3fv(this.matrixLocation, false, e), !this.positionBuffer || !this.texCoordBuffer)
        return;
      const i = !!this.config.debug && (!!this.texture || this.useTiles);
      if (this.tileDebugLocation && t.uniform1i(this.tileDebugLocation, i ? 1 : 0), this.tileBorderColorLocation) {
        const [o, r, d, c2] = it;
        t.uniform4f(this.tileBorderColorLocation, o, r, d, c2);
      }
      !i && this.tileBorderWidthLocation && t.uniform2f(this.tileBorderWidthLocation, 0, 0);
      const s = this.tileBorderWidthLocation;
      if (t.bindBuffer(t.ARRAY_BUFFER, this.texCoordBuffer), t.enableVertexAttribArray(this.texCoordLocation), t.vertexAttribPointer(this.texCoordLocation, 2, t.FLOAT, false, 0, 0), t.bindBuffer(t.ARRAY_BUFFER, this.positionBuffer), t.enableVertexAttribArray(this.positionLocation), t.vertexAttribPointer(this.positionLocation, 2, t.FLOAT, false, 0, 0), t.activeTexture(t.TEXTURE0), this.useTiles) {
        const o = this.getVisibleTiles();
        for (const r of o) {
          if (!r.texture) continue;
          if (i && s) {
            const c2 = Math.max(r.width, 1), m = Math.max(r.height, 1);
            t.uniform2f(
              s,
              D / c2,
              D / m
            );
          }
          const d = new Float32Array([
            r.x,
            r.y,
            r.x + r.width,
            r.y,
            r.x,
            r.y + r.height,
            r.x,
            r.y + r.height,
            r.x + r.width,
            r.y,
            r.x + r.width,
            r.y + r.height
          ]);
          t.bindBuffer(t.ARRAY_BUFFER, this.positionBuffer), t.bufferData(t.ARRAY_BUFFER, d, t.DYNAMIC_DRAW), t.bindTexture(t.TEXTURE_2D, r.texture), t.drawArrays(t.TRIANGLES, 0, 6);
        }
      } else {
        if (i && s && this.image) {
          const o = Math.max(this.image.width, 1), r = Math.max(this.image.height, 1);
          t.uniform2f(
            s,
            D / o,
            D / r
          );
        }
        t.bindTexture(t.TEXTURE_2D, this.texture), t.drawArrays(t.TRIANGLES, 0, 6);
      }
      const a = t.getError();
      a !== t.NO_ERROR && console.error("WebGL rendering error:", a);
    } catch (e) {
      console.error("Error during rendering:", e);
    }
  }
  updateAnimation() {
    if (!this.animation) return;
    const e = Date.now() - this.animation.startTime, i = Math.min(e / this.animation.duration, 1);
    if (i >= 1) {
      this.transform = { ...this.animation.targetTransform }, this.animation = null, this.animationId && (cancelAnimationFrame(this.animationId), this.animationId = null), this.emitZoomChange(), this.emitTransformChange();
      return;
    }
    const s = this.animation.easing(i), { startTransform: a, targetTransform: o } = this.animation;
    this.transform = {
      scale: a.scale + (o.scale - a.scale) * s,
      translateX: a.translateX + (o.translateX - a.translateX) * s,
      translateY: a.translateY + (o.translateY - a.translateY) * s
    }, this.emitTransformChange(), this.animationId = requestAnimationFrame(() => this.render());
  }
  animateTo(t, e = this.config.animationTime) {
    this.animationId && (cancelAnimationFrame(this.animationId), this.animationId = null), this.animation = {
      startTime: Date.now(),
      duration: e,
      startTransform: { ...this.transform },
      targetTransform: t,
      easing: Z.easeOutQuart
    }, this.render();
  }
  // 事件处理器
  handleMouseDown(t) {
    this.config.panningDisabled || (this.isDragging = true, this.lastMousePos = { x: t.clientX, y: t.clientY }, this.canvas.style.cursor = "grabbing", (void 0).addEventListener("mouseup", this.boundHandleMouseUp), (void 0).addEventListener("mousemove", this.boundHandleMouseMove), t.preventDefault());
  }
  handleMouseMove(t) {
    if (!this.isDragging || !this.lastMousePos || this.config.panningDisabled)
      return;
    const e = (void 0).devicePixelRatio || 1, i = (t.clientX - this.lastMousePos.x) * e, s = (t.clientY - this.lastMousePos.y) * e;
    this.transform.translateX += i, this.transform.translateY += s, this.constrainToBounds(), this.lastMousePos = { x: t.clientX, y: t.clientY }, this.emitTransformChange(), this.throttledRender(), t.preventDefault();
  }
  handleMouseUp() {
    this.isDragging = false, this.lastMousePos = null, this.canvas.style.cursor = "grab", (void 0).removeEventListener("mouseup", this.boundHandleMouseUp), (void 0).removeEventListener("mousemove", this.boundHandleMouseMove);
  }
  handleMouseLeave() {
    this.isDragging && (this.isDragging = false, this.lastMousePos = null, this.canvas.style.cursor = "grab", (void 0).removeEventListener("mouseup", this.boundHandleMouseUp), (void 0).removeEventListener("mousemove", this.boundHandleMouseMove));
  }
  handleWheel(t) {
    if (this.config.wheelDisabled) return;
    t.preventDefault();
    const e = this.canvas.getBoundingClientRect(), i = (void 0).devicePixelRatio || 1, s = (t.clientX - e.left) * i, a = (t.clientY - e.top) * i, o = t.deltaY < 0 ? 1 + this.config.wheelStep : 1 - this.config.wheelStep;
    this.zoomAtPoint(s, a, o);
  }
  handleClick(t) {
    if (this.config.doubleClickDisabled) return;
    const e = Date.now();
    if (e - this.lastClickTime < _.DOUBLE_CLICK_DELAY) {
      const i = this.canvas.getBoundingClientRect(), s = (void 0).devicePixelRatio || 1, a = (t.clientX - i.left) * s, o = (t.clientY - i.top) * s;
      this.config.doubleClickMode === "toggle" ? this.transform.scale > this.initialScale * 1.1 ? this.resetView() : this.zoomAtPoint(a, o, this.config.doubleClickStep, true) : this.zoomAtPoint(a, o, this.config.doubleClickStep, true);
    }
    this.lastClickTime = e;
  }
  handleTouchStart(t) {
    t.preventDefault();
    const e = k(t.touches);
    if (e.length === 1 && e[0])
      this.hasMoved = false, this.config.panningDisabled || (this.isDragging = true, this.lastMousePos = e[0]);
    else if (e.length === 2 && e[0] && e[1] && !this.config.pinchDisabled) {
      const i = B(e[0], e[1]), s = P(e);
      this.touchState = {
        touches: Array.from(t.touches),
        lastDistance: i,
        lastCenter: s
      };
    }
  }
  handleTouchMove(t) {
    t.preventDefault();
    const e = k(t.touches);
    if (e.length === 1 && this.isDragging && this.lastMousePos && e[0]) {
      const i = (void 0).devicePixelRatio || 1, s = (e[0].x - this.lastMousePos.x) * i, a = (e[0].y - this.lastMousePos.y) * i;
      (Math.abs(s) > 5 * i || Math.abs(a) > 5 * i) && (this.hasMoved = true), this.transform.translateX += s, this.transform.translateY += a, this.constrainToBounds(), this.lastMousePos = e[0], this.emitTransformChange(), this.throttledRender();
    } else if (e.length === 2 && this.touchState && e[0] && e[1]) {
      if (this.config.pinchDisabled) return;
      const i = B(e[0], e[1]), s = P(e), a = i / this.touchState.lastDistance, o = this.canvas.getBoundingClientRect(), r = (void 0).devicePixelRatio || 1, d = (s.x - o.left) * r, c2 = (s.y - o.top) * r;
      this.zoomAtPoint(d, c2, a), this.touchState.lastDistance = i, this.touchState.lastCenter = s;
    }
  }
  handleTouchEnd(t) {
    const e = Date.now();
    if (t.touches.length === 0 && this.lastMousePos && !this.hasMoved && !this.config.doubleClickDisabled) {
      const i = this.lastMousePos;
      if (this.lastTouchTime > 0 && e - this.lastTouchTime < _.DOUBLE_CLICK_DELAY && this.lastTouchPosition && this.isNearPosition(i, this.lastTouchPosition, 50)) {
        const s = this.canvas.getBoundingClientRect(), a = (void 0).devicePixelRatio || 1, o = (i.x - s.left) * a, r = (i.y - s.top) * a;
        this.config.doubleClickMode === "toggle" ? this.transform.scale > this.initialScale * 1.1 ? this.resetView() : this.zoomAtPoint(
          o,
          r,
          this.config.doubleClickStep,
          true
        ) : this.zoomAtPoint(o, r, this.config.doubleClickStep, true), this.lastTouchTime = 0, this.lastTouchPosition = null;
      } else
        this.lastTouchTime = e, this.lastTouchPosition = i;
    } else
      this.lastTouchTime = 0, this.lastTouchPosition = null;
    this.isDragging = false, this.lastMousePos = null, this.touchState = null, this.hasMoved = false;
  }
  isNearPosition(t, e, i) {
    return Math.sqrt(
      Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)
    ) <= i;
  }
  // WebGL 上下文事件处理
  handleContextLost(t) {
    t.preventDefault(), console.warn("WebGL context lost"), this.animationId && (cancelAnimationFrame(this.animationId), this.animationId = null), this.animation = null, this.isDragging = false, this.lastMousePos = null, this.touchState = null;
  }
  handleContextRestored() {
    console.log("WebGL context restored");
    try {
      if (this.setupWebGL(), this.image) {
        let t = this.useTiles;
        t ? this.createTiles(this.image) || (this.createTexture(this.image), t = false) : this.createTexture(this.image), this.useTiles = t && this.tiles.length > 0, this.useTiles && this.updatePositionBuffer(), this.render();
      }
    } catch (t) {
      console.error("Failed to restore WebGL context:", t);
    }
  }
  // 公共方法
  zoomIn(t = false) {
    const e = this.canvas.getBoundingClientRect(), i = (void 0).devicePixelRatio || 1, s = e.width / 2 * i, a = e.height / 2 * i;
    this.zoomAtPoint(s, a, 1 + this.config.wheelStep, t);
  }
  zoomOut(t = false) {
    const e = this.canvas.getBoundingClientRect(), i = (void 0).devicePixelRatio || 1, s = e.width / 2 * i, a = e.height / 2 * i;
    this.zoomAtPoint(s, a, 1 - this.config.wheelStep, t);
  }
  resetView() {
    if (!this.image) return;
    const t = this.calculateCenterTransform();
    this.animateTo(t);
  }
  calculateCenterTransform() {
    if (!this.image || this.image.width <= 0 || this.image.height <= 0)
      return { ...this.transform };
    const t = this.canvas.width / this.canvas.height, e = this.image.width / this.image.height;
    if (this.canvas.width <= 0 || this.canvas.height <= 0)
      return { ...this.transform };
    let i;
    e > t ? i = this.canvas.width / this.image.width : i = this.canvas.height / this.image.height, this.initialScale = i;
    const s = this.clampScale(i), a = this.image.width * s, o = this.image.height * s;
    return {
      scale: s,
      translateX: (this.canvas.width - a) / 2,
      translateY: (this.canvas.height - o) / 2
    };
  }
  getScale() {
    return this.transform.scale;
  }
  getRelativeScale() {
    return this.transform.scale / this.initialScale;
  }
  zoomAtPoint(t, e, i, s = false) {
    if (!isFinite(i) || i <= 0 || !isFinite(t) || !isFinite(e)) return;
    const a = this.clampScale(this.transform.scale * i);
    if (a === this.transform.scale || !isFinite(a)) return;
    const o = (t - this.transform.translateX) / this.transform.scale, r = (e - this.transform.translateY) / this.transform.scale, d = t - o * a, c2 = e - r * a;
    if (!isFinite(d) || !isFinite(c2)) return;
    const m = {
      scale: a,
      translateX: d,
      translateY: c2
    }, f = this.transform;
    this.transform = m, this.constrainToBounds();
    const v = { ...this.transform };
    this.transform = f, s ? this.animateTo(v) : (this.transform = v, this.throttledRender(), this.emitZoomChange(), this.emitTransformChange());
  }
  emitZoomChange() {
    if (this.onZoomChange) {
      const t = this.transform.scale / this.initialScale;
      this.onZoomChange(this.transform.scale, t);
    }
  }
  emitTransformChange() {
    this.onTransformChange && this.onTransformChange({ ...this.transform });
  }
  getDebugInfo() {
    if (!this.image) return null;
    const t = this.useTiles ? this.getVisibleTiles() : [], e = "src" in this.image && typeof this.image.src == "string" ? this.image.src : "";
    return {
      scale: this.transform.scale,
      relativeScale: this.transform.scale / this.initialScale,
      translateX: this.transform.translateX,
      translateY: this.transform.translateY,
      canvasWidth: this.canvas.width,
      canvasHeight: this.canvas.height,
      imageWidth: this.image.width,
      imageHeight: this.image.height,
      devicePixelRatio: (void 0).devicePixelRatio || 1,
      maxTextureSize: S(this.gl),
      isLoading: this.isLoadingTexture,
      loadingState: this.currentLoadingState,
      currentQuality: this.currentQuality,
      imageSrc: e,
      tileEnabled: this.config.tileEnabled,
      useTiles: this.useTiles,
      totalTiles: this.tiles.length,
      visibleTiles: t.length,
      tileSize: this.config.tileSize
    };
  }
  setCallbacks(t) {
    this.onZoomChange = t.onZoomChange, this.onImageCopied = t.onImageCopied, this.onLoadingStateChange = t.onLoadingStateChange, this.onTransformChange = t.onTransformChange;
  }
  async copyOriginalImageToClipboard() {
    if (!this.image)
      throw new Error("No image loaded");
    try {
      const t = (void 0).createElement("canvas"), e = t.getContext("2d");
      if (!e)
        throw new Error("Failed to get 2D context");
      t.width = this.image.width, t.height = this.image.height, e.drawImage(this.image, 0, 0);
      const i = await new Promise((s) => {
        t.toBlob(s, "image/png");
      });
      if (!i)
        throw new Error("Failed to create blob");
      await (void 0).clipboard.write([
        new ClipboardItem({ "image/png": i })
      ]), this.onImageCopied?.();
    } catch (t) {
      throw console.error("Failed to copy image to clipboard:", t), t;
    }
  }
  destroy() {
    this.animationId && (cancelAnimationFrame(this.animationId), this.animationId = null);
    const { gl: t } = this;
    this.texture && (t.deleteTexture(this.texture), this.texture = null), this.cleanupTiles(), this.useTiles = false, this.positionBuffer && (t.deleteBuffer(this.positionBuffer), this.positionBuffer = null), this.texCoordBuffer && (t.deleteBuffer(this.texCoordBuffer), this.texCoordBuffer = null), this.program && (t.deleteProgram(this.program), this.program = null), this.canvas.removeEventListener(
      "mousedown",
      this.handleMouseDown.bind(this)
    ), this.canvas.removeEventListener("mouseleave", this.boundHandleMouseLeave), this.canvas.removeEventListener("wheel", this.handleWheel.bind(this)), this.canvas.removeEventListener("click", this.handleClick.bind(this)), this.canvas.removeEventListener(
      "touchstart",
      this.handleTouchStart.bind(this)
    ), this.canvas.removeEventListener(
      "touchmove",
      this.handleTouchMove.bind(this)
    ), this.canvas.removeEventListener("touchend", this.handleTouchEnd.bind(this)), this.canvas.removeEventListener(
      "webglcontextlost",
      this.handleContextLost.bind(this)
    ), this.canvas.removeEventListener(
      "webglcontextrestored",
      this.handleContextRestored.bind(this)
    ), this.canvas.removeEventListener("contextmenu", (e) => e.preventDefault()), (void 0).removeEventListener("mouseup", this.boundHandleMouseUp), (void 0).removeEventListener("mousemove", this.boundHandleMouseMove), this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null), this.animation = null, this.isDragging = false, this.lastMousePos = null, this.touchState = null, this.lastTouchTime = 0, this.lastTouchPosition = null, this.hasMoved = false, this.image = null, this.onZoomChange = void 0, this.onImageCopied = void 0, this.worker && (this.worker.terminate(), this.worker = null);
  }
}
const nt = { class: "webgl-debug-info" }, at = { class: "debug-section" }, ot = { class: "debug-section" }, rt = { class: "debug-section" }, lt = { class: "debug-section" }, ht = { class: "debug-section" }, ct = { class: "debug-section" }, dt = { class: "debug-section" }, ut = {
  key: 0,
  class: "image-src"
}, gt = /* @__PURE__ */ defineComponent({
  __name: "DebugInfo",
  props: {
    debugInfo: {}
  },
  setup(n) {
    const t = (s) => ({
      idle: "空闲",
      "image-loading": "图片加载中",
      "texture-loading": "纹理加载中",
      "tile-loading": "瓦片加载中",
      complete: "加载完成",
      error: "加载错误"
    })[s] || s, e = (s) => ({
      high: "高",
      medium: "中",
      low: "低",
      unknown: "未知"
    })[s] || s, i = (s) => s.length <= 30 ? s : s.slice(0, 27) + "...";
    return (s, a) => (openBlock(), createElementBlock("div", nt, [
      createElementVNode("div", at, [
        a[0] || (a[0] = createElementVNode("h4", null, "缩放信息", -1)),
        createElementVNode("div", null, "缩放比例: " + toDisplayString$1(n.debugInfo.scale.toFixed(3)), 1),
        createElementVNode("div", null, "相对比例: " + toDisplayString$1(n.debugInfo.relativeScale.toFixed(3)), 1)
      ]),
      createElementVNode("div", ot, [
        a[1] || (a[1] = createElementVNode("h4", null, "位置信息", -1)),
        createElementVNode("div", null, "X轴平移: " + toDisplayString$1(n.debugInfo.translateX.toFixed(2)), 1),
        createElementVNode("div", null, "Y轴平移: " + toDisplayString$1(n.debugInfo.translateY.toFixed(2)), 1)
      ]),
      createElementVNode("div", rt, [
        a[2] || (a[2] = createElementVNode("h4", null, "Canvas信息", -1)),
        createElementVNode("div", null, "宽度: " + toDisplayString$1(n.debugInfo.canvasWidth), 1),
        createElementVNode("div", null, "高度: " + toDisplayString$1(n.debugInfo.canvasHeight), 1),
        createElementVNode("div", null, "设备像素比: " + toDisplayString$1(n.debugInfo.devicePixelRatio), 1)
      ]),
      createElementVNode("div", lt, [
        a[3] || (a[3] = createElementVNode("h4", null, "图像信息", -1)),
        createElementVNode("div", null, "原始宽度: " + toDisplayString$1(n.debugInfo.imageWidth), 1),
        createElementVNode("div", null, "原始高度: " + toDisplayString$1(n.debugInfo.imageHeight), 1)
      ]),
      createElementVNode("div", ht, [
        a[4] || (a[4] = createElementVNode("h4", null, "瓦片信息", -1)),
        createElementVNode("div", null, "启用瓦片: " + toDisplayString$1(n.debugInfo.tileEnabled ? "是" : "否"), 1),
        createElementVNode("div", null, "使用瓦片渲染: " + toDisplayString$1(n.debugInfo.useTiles ? "是" : "否"), 1),
        createElementVNode("div", null, "总瓦片数: " + toDisplayString$1(n.debugInfo.totalTiles), 1),
        createElementVNode("div", null, "可见瓦片数: " + toDisplayString$1(n.debugInfo.visibleTiles), 1),
        createElementVNode("div", null, "配置瓦片尺寸: " + toDisplayString$1(n.debugInfo.tileSize), 1)
      ]),
      createElementVNode("div", ct, [
        a[5] || (a[5] = createElementVNode("h4", null, "WebGL信息", -1)),
        createElementVNode("div", null, "最大纹理尺寸: " + toDisplayString$1(n.debugInfo.maxTextureSize), 1)
      ]),
      createElementVNode("div", dt, [
        a[6] || (a[6] = createElementVNode("h4", null, "加载状态", -1)),
        createElementVNode("div", null, "正在加载: " + toDisplayString$1(n.debugInfo.isLoading ? "是" : "否"), 1),
        createElementVNode("div", null, "加载状态: " + toDisplayString$1(t(n.debugInfo.loadingState)), 1),
        createElementVNode("div", null, "当前质量: " + toDisplayString$1(e(n.debugInfo.currentQuality)), 1),
        n.debugInfo.imageSrc ? (openBlock(), createElementBlock("div", ut, " 图片源: " + toDisplayString$1(i(n.debugInfo.imageSrc)), 1)) : createCommentVNode("", true)
      ])
    ]));
  }
}), W = (n, t) => {
  const e = n.__vccOpts || n;
  for (const [i, s] of t)
    e[i] = s;
  return e;
}, mt = /* @__PURE__ */ W(gt, [["__scopeId", "data-v-07457215"]]), ft = /* @__PURE__ */ defineComponent({
  __name: "WebGLImageViewer",
  props: {
    src: {},
    class: {},
    width: {},
    height: {},
    initialScale: { default: 1 },
    minScale: { default: 0.1 },
    maxScale: { default: 10 },
    centerOnInit: { type: Boolean, default: true },
    debug: { type: Boolean, default: false },
    limitToBounds: { type: Boolean, default: true },
    smooth: { type: Boolean, default: true },
    wheel: { default: () => ({ step: 0.1 }) },
    pinch: { default: () => ({ step: 0.5 }) },
    doubleClick: { default: () => ({
      step: 2,
      mode: "toggle",
      animationTime: 200
    }) },
    panning: { default: () => ({ velocityDisabled: true }) },
    alignmentAnimation: { default: () => ({
      duration: 300,
      easing: (n) => 1 - Math.pow(1 - n, 4)
      // easeOutQuart
    }) },
    velocityAnimation: { default: () => ({
      duration: 400,
      easing: (n) => 1 - Math.pow(1 - n, 3)
      // easeOutCubic
    }) },
    tile: { default: () => ({
      enabled: true,
      size: g.tileSize
    }) }
  },
  emits: ["zoomChange", "imageCopied", "loadingStateChange"],
  setup(n, { expose: t, emit: e }) {
    const i = n, s = e, a = ref(), o = ref(), r = ref(null), d = ref(""), c2 = computed(() => ({
      ...g,
      initialScale: i.initialScale,
      minScale: i.minScale,
      maxScale: i.maxScale,
      centerOnInit: i.centerOnInit,
      debug: i.debug,
      limitToBounds: i.limitToBounds,
      smooth: i.smooth,
      wheelStep: i.wheel?.step ?? g.wheelStep,
      wheelDisabled: i.wheel?.wheelDisabled ?? g.wheelDisabled,
      touchPadDisabled: i.wheel?.touchPadDisabled ?? g.touchPadDisabled,
      pinchStep: i.pinch?.step ?? g.pinchStep,
      pinchDisabled: i.pinch?.disabled ?? g.pinchDisabled,
      doubleClickStep: i.doubleClick?.step ?? g.doubleClickStep,
      doubleClickMode: i.doubleClick?.mode ?? g.doubleClickMode,
      doubleClickDisabled: i.doubleClick?.disabled ?? g.doubleClickDisabled,
      animationTime: i.doubleClick?.animationTime ?? g.animationTime,
      panningDisabled: i.panning?.disabled ?? g.panningDisabled,
      velocityDisabled: i.panning?.velocityDisabled ?? g.velocityDisabled,
      tileEnabled: i.tile?.enabled ?? g.tileEnabled,
      tileSize: i.tile?.size ?? g.tileSize,
      alignmentAnimation: {
        ...g.alignmentAnimation,
        ...i.alignmentAnimation
      },
      velocityAnimation: {
        ...g.velocityAnimation,
        ...i.velocityAnimation
      }
    })), m = async () => {
      if (!a.value)
        throw new Error("Canvas not available");
      if (!q())
        throw new Error("WebGL not supported");
      try {
        o.value = new st(a.value, c2.value), o.value.setCallbacks({
          onZoomChange: (h2, p) => {
            s("zoomChange", h2, p), c2.value.debug && f();
          },
          onImageCopied: () => {
            s("imageCopied");
          },
          onLoadingStateChange: (h2, p, O) => {
            s("loadingStateChange", h2, p, O);
          },
          onTransformChange: (h2) => {
            c2.value.debug && f();
          }
        }), i.src && (await o.value.loadImage(i.src), c2.value.debug && f());
      } catch (h2) {
        throw console.error("Failed to initialize WebGL engine:", h2), d.value = h2 instanceof Error ? h2.message : "Unknown error", h2;
      }
    }, f = () => {
      o.value && (r.value = o.value.getDebugInfo());
    }, v = (h2) => {
      console.error("Canvas error:", h2), d.value = "Canvas error occurred";
    }, x = (h2 = false) => {
      o.value?.zoomIn(h2);
    }, E2 = (h2 = false) => {
      o.value?.zoomOut(h2);
    }, L = () => {
      o.value?.resetView();
    }, b = () => o.value?.getScale() ?? 1, T = () => o.value?.getRelativeScale() ?? 1, C = async () => {
      if (!o.value)
        throw new Error("Engine not initialized");
      return o.value.copyOriginalImageToClipboard();
    };
    return watch(
      () => i.src,
      async (h2) => {
        if (h2 && o.value)
          try {
            await o.value.loadImage(h2), c2.value.debug && f();
          } catch (p) {
            console.error("Failed to load new image:", p), d.value = p instanceof Error ? p.message : "Failed to load image";
          }
      }
    ), watch(
      c2,
      (h2) => {
        o.value && (o.value.destroy(), m().catch(console.error));
      },
      { deep: true }
    ), t({
      zoomIn: x,
      zoomOut: E2,
      resetView: L,
      getScale: b,
      getRelativeScale: T,
      copyToClipboard: C
    }), (h2, p) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["webgl-image-viewer", i.class])
    }, [
      createElementVNode("canvas", {
        ref_key: "canvasRef",
        ref: a,
        class: "webgl-canvas",
        onError: v
      }, null, 544),
      c2.value.debug && r.value ? (openBlock(), createBlock(mt, {
        key: 0,
        "debug-info": r.value
      }, null, 8, ["debug-info"])) : createCommentVNode("", true)
    ], 2));
  }
}), Ct = /* @__PURE__ */ W(ft, [["__scopeId", "data-v-c839b956"]]);
const chrono_webgl_image_WYtbqTd1EZ3b1oYMQfEsPtI5GGYQUcGfjJLpGPsRslo = /* @__PURE__ */ defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.component("WebGLImageViewer", Ct);
});
const vue_masonry_wall_BeGSXOcSex_9jLvYqIQO_43gxbfd8xAKzvENeXYB5nY = /* @__PURE__ */ defineNuxtPlugin((nuxtApp) => {
  nuxtApp.vueApp.use(MasonryWall);
});
const ssg_detect_OC7cEAqOT7f74_dDYi93BFCmr2Fq0DxFk_FBvb_RTtE = /* @__PURE__ */ defineNuxtPlugin({
  name: "i18n:plugin:ssg-detect",
  dependsOn: ["i18n:plugin", "i18n:plugin:route-locale-detect"],
  enforce: "post",
  setup(_nuxt) {
    return;
  }
});
const plugins = [
  payloadPlugin,
  unhead_sebKWs0qLgaCoVBpeFlwbClqUS4Q6vQHhZO_zjRanO0,
  plugin$1,
  _0_siteConfig_i_yMjQUHdfsOan08JUMmAzex_7VXFWXiLqCwSqKsDW0,
  session_server_5_UxeDlpXA9IUgHZ_wiQRaJOs4O21k3HKzLLCcMjq9s,
  revive_payload_server_JGXiAkjgWmbeaRgEi0NNUhu6ZGpdJCIpUkB9KVT32cI,
  plugin,
  components_plugin_4kY4pyzJIYX99vmMAAIorFf3CnAaptHitJgf7JxiED8,
  og_image_canonical_urls_server__SJeLZ8IhvQn4NsLhTaSDpX_JsYyby10BokME_5_Ixw,
  route_rule_og_image_server_fMUHedIg6IJyGlkb3J1ti72d0MoUU_RE87zkn2NS9gA,
  i18n_sNLfHumFZpeSKAqN31zGP6UN5uEbL7CZMNGvEiTqVUU,
  switch_locale_path_ssr_Dze1NTXfrlXHhwAF_2CPZW1RISIQ5nyVFa0AHzdg25U,
  route_locale_detect_2J0uY6yg03Fl3HcWrCmbdaA0_d2jkpgnfFSLwIVDjGM,
  preload_gcC1VaCwF_vIh4_YThnEj2iARUbOWQ_7HmzWTQ7k2QI,
  i18n_9VvcYVujdwTF_eqLEvU7W5fit2iS7KZYn9D_F7xJTck,
  plugin_9_EpKXPMHOpyihxvImx0aIXN6zBuUpKODx_p4SQZ7jU,
  plugin_xOlP7bygCPMvfAMNVzJMTA1dWEVSX3FRDAocIaN5oYs,
  colors_bE0YZl93PIqdfvWM0aF3q3gOe_ktYfgf7_Jcz_ItiYo,
  plugin_server_1VsdcVlQN2tv6RG6Fy0EvkojZKbQX61TrTVJeEFBIfo,
  chrono_webgl_image_WYtbqTd1EZ3b1oYMQfEsPtI5GGYQUcGfjJLpGPsRslo,
  vue_masonry_wall_BeGSXOcSex_9jLvYqIQO_43gxbfd8xAKzvENeXYB5nY,
  ssg_detect_OC7cEAqOT7f74_dDYi93BFCmr2Fq0DxFk_FBvb_RTtE
];
function createContext$1(providerComponentName, contextName) {
  const symbolDescription = typeof providerComponentName === "string" && !contextName ? `${providerComponentName}Context` : contextName;
  const injectionKey = Symbol(symbolDescription);
  const injectContext = (fallback) => {
    const context = inject(injectionKey, fallback);
    if (context) return context;
    if (context === null) return context;
    throw new Error(`Injection \`${injectionKey.toString()}\` not found. Component must be used within ${Array.isArray(providerComponentName) ? `one of the following components: ${providerComponentName.join(", ")}` : `\`${providerComponentName}\``}`);
  };
  const provideContext = (contextValue) => {
    provide(injectionKey, contextValue);
    return contextValue;
  };
  return [injectContext, provideContext];
}
function getActiveElement() {
  let activeElement = (void 0).activeElement;
  if (activeElement == null) return null;
  while (activeElement != null && activeElement.shadowRoot != null && activeElement.shadowRoot.activeElement != null) activeElement = activeElement.shadowRoot.activeElement;
  return activeElement;
}
function isNullish$1(value) {
  return value === null || value === void 0;
}
function renderSlotFragments$1(children) {
  if (!children) return [];
  return children.flatMap((child) => {
    if (child.type === Fragment) return renderSlotFragments$1(child.children);
    return [child];
  });
}
const [injectConfigProviderContext, provideConfigProviderContext] = createContext$1("ConfigProvider");
var ConfigProvider_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  inheritAttrs: false,
  __name: "ConfigProvider",
  props: {
    dir: {
      type: String,
      required: false,
      default: "ltr"
    },
    locale: {
      type: String,
      required: false,
      default: "en"
    },
    scrollBody: {
      type: [Boolean, Object],
      required: false,
      default: true
    },
    nonce: {
      type: String,
      required: false,
      default: void 0
    },
    useId: {
      type: Function,
      required: false,
      default: void 0
    }
  },
  setup(__props) {
    const props = __props;
    const { dir, locale, scrollBody, nonce } = toRefs(props);
    provideConfigProviderContext({
      dir,
      locale,
      scrollBody,
      nonce,
      useId: props.useId
    });
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});
var ConfigProvider_default = ConfigProvider_vue_vue_type_script_setup_true_lang_default;
function computedEager(fn, options) {
  var _a;
  const result = shallowRef();
  watchEffect(() => {
    result.value = fn();
  }, {
    ...options,
    flush: (_a = void 0) != null ? _a : "sync"
  });
  return readonly(result);
}
function computedWithControl(source, fn) {
  let v = void 0;
  let track;
  let trigger;
  const dirty = shallowRef(true);
  const update = () => {
    dirty.value = true;
    trigger();
  };
  watch(source, update, { flush: "sync" });
  const get2 = typeof fn === "function" ? fn : fn.get;
  const set2 = typeof fn === "function" ? void 0 : fn.set;
  const result = customRef((_track, _trigger) => {
    track = _track;
    trigger = _trigger;
    return {
      get() {
        if (dirty.value) {
          v = get2(v);
          dirty.value = false;
        }
        track();
        return v;
      },
      set(v2) {
        set2 == null ? void 0 : set2(v2);
      }
    };
  });
  if (Object.isExtensible(result))
    result.trigger = update;
  return result;
}
function tryOnScopeDispose$1(fn) {
  if (getCurrentScope()) {
    onScopeDispose(fn);
    return true;
  }
  return false;
}
function createEventHook() {
  const fns = /* @__PURE__ */ new Set();
  const off = (fn) => {
    fns.delete(fn);
  };
  const clear = () => {
    fns.clear();
  };
  const on = (fn) => {
    fns.add(fn);
    const offFn = () => off(fn);
    tryOnScopeDispose$1(offFn);
    return {
      off: offFn
    };
  };
  const trigger = (...args) => {
    return Promise.all(Array.from(fns).map((fn) => fn(...args)));
  };
  return {
    on,
    off,
    trigger,
    clear
  };
}
function createGlobalState(stateFactory) {
  let initialized = false;
  let state2;
  const scope = effectScope(true);
  return (...args) => {
    if (!initialized) {
      state2 = scope.run(() => stateFactory(...args));
      initialized = true;
    }
    return state2;
  };
}
function createSharedComposable$1(composable) {
  let subscribers = 0;
  let state2;
  let scope;
  const dispose = () => {
    subscribers -= 1;
    if (scope && subscribers <= 0) {
      scope.stop();
      state2 = void 0;
      scope = void 0;
    }
  };
  return (...args) => {
    subscribers += 1;
    if (!scope) {
      scope = effectScope(true);
      state2 = scope.run(() => composable(...args));
    }
    tryOnScopeDispose$1(dispose);
    return state2;
  };
}
function toReactive$1(objectRef) {
  if (!isRef(objectRef))
    return reactive(objectRef);
  const proxy = new Proxy({}, {
    get(_2, p, receiver) {
      return unref(Reflect.get(objectRef.value, p, receiver));
    },
    set(_2, p, value) {
      if (isRef(objectRef.value[p]) && !isRef(value))
        objectRef.value[p].value = value;
      else
        objectRef.value[p] = value;
      return true;
    },
    deleteProperty(_2, p) {
      return Reflect.deleteProperty(objectRef.value, p);
    },
    has(_2, p) {
      return Reflect.has(objectRef.value, p);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  });
  return reactive(proxy);
}
function reactiveComputed$1(fn) {
  return toReactive$1(computed(fn));
}
function reactiveOmit$1(obj, ...keys) {
  const flatKeys = keys.flat();
  const predicate = flatKeys[0];
  return reactiveComputed$1(() => typeof predicate === "function" ? Object.fromEntries(Object.entries(toRefs(obj)).filter(([k2, v]) => !predicate(toValue(v), k2))) : Object.fromEntries(Object.entries(toRefs(obj)).filter((e) => !flatKeys.includes(e[0]))));
}
const isClient = false;
typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const isDef$1 = (val) => typeof val !== "undefined";
const notNullish$1 = (val) => val != null;
const toString$1 = Object.prototype.toString;
const isObject$2 = (val) => toString$1.call(val) === "[object Object]";
const noop$2 = () => {
};
function createFilterWrapper$1(filter2, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter2(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
const bypassFilter$1 = (invoke2) => {
  return invoke2();
};
function debounceFilter$1(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop$2;
  const _clearTimeout = (timer2) => {
    clearTimeout(timer2);
    lastRejector();
    lastRejector = noop$2;
  };
  let lastInvoker;
  const filter2 = (invoke2) => {
    const duration2 = toValue(ms);
    const maxDuration = toValue(options.maxWait);
    if (timer)
      _clearTimeout(timer);
    if (duration2 <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = null;
      }
      return Promise.resolve(invoke2());
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      lastInvoker = invoke2;
      if (maxDuration && !maxTimer) {
        maxTimer = setTimeout(() => {
          if (timer)
            _clearTimeout(timer);
          maxTimer = null;
          resolve(lastInvoker());
        }, maxDuration);
      }
      timer = setTimeout(() => {
        if (maxTimer)
          _clearTimeout(maxTimer);
        maxTimer = null;
        resolve(invoke2());
      }, duration2);
    });
  };
  return filter2;
}
function pausableFilter$1(extendFilter = bypassFilter$1, options = {}) {
  const {
    initialState = "active"
  } = options;
  const isActive = toRef$1(initialState === "active");
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive: readonly(isActive), pause, resume, eventFilter };
}
function getLifeCycleTarget$1(target) {
  return getCurrentInstance$1();
}
function toArray$1(value) {
  return Array.isArray(value) ? value : [value];
}
function toRef$1(...args) {
  if (args.length !== 1)
    return toRef$2(...args);
  const r = args[0];
  return typeof r === "function" ? readonly(customRef(() => ({ get: r, set: noop$2 }))) : ref(r);
}
function refAutoReset(defaultValue, afterMs = 1e4) {
  return customRef((track, trigger) => {
    let value = toValue(defaultValue);
    let timer;
    const resetAfter = () => setTimeout(() => {
      value = toValue(defaultValue);
      trigger();
    }, toValue(afterMs));
    tryOnScopeDispose$1(() => {
      clearTimeout(timer);
    });
    return {
      get() {
        track();
        return value;
      },
      set(newValue) {
        value = newValue;
        trigger();
        clearTimeout(timer);
        timer = resetAfter();
      }
    };
  });
}
function useDebounceFn$1(fn, ms = 200, options = {}) {
  return createFilterWrapper$1(
    debounceFilter$1(ms, options),
    fn
  );
}
function watchWithFilter$1(source, cb, options = {}) {
  const {
    eventFilter = bypassFilter$1,
    ...watchOptions
  } = options;
  return watch(
    source,
    createFilterWrapper$1(
      eventFilter,
      cb
    ),
    watchOptions
  );
}
function watchPausable$1(source, cb, options = {}) {
  const {
    eventFilter: filter2,
    initialState = "active",
    ...watchOptions
  } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter$1(filter2, { initialState });
  const stop = watchWithFilter$1(
    source,
    cb,
    {
      ...watchOptions,
      eventFilter
    }
  );
  return { stop, pause, resume, isActive };
}
function syncRef(left, right, ...[options]) {
  const {
    flush = "sync",
    deep = false,
    immediate = true,
    direction = "both",
    transform: transform2 = {}
  } = options || {};
  const watchers = [];
  const transformLTR = "ltr" in transform2 && transform2.ltr || ((v) => v);
  const transformRTL = "rtl" in transform2 && transform2.rtl || ((v) => v);
  if (direction === "both" || direction === "ltr") {
    watchers.push(watchPausable$1(
      left,
      (newValue) => {
        watchers.forEach((w) => w.pause());
        right.value = transformLTR(newValue);
        watchers.forEach((w) => w.resume());
      },
      { flush, deep, immediate }
    ));
  }
  if (direction === "both" || direction === "rtl") {
    watchers.push(watchPausable$1(
      right,
      (newValue) => {
        watchers.forEach((w) => w.pause());
        left.value = transformRTL(newValue);
        watchers.forEach((w) => w.resume());
      },
      { flush, deep, immediate }
    ));
  }
  const stop = () => {
    watchers.forEach((w) => w.stop());
  };
  return stop;
}
function tryOnBeforeUnmount(fn, target) {
  getLifeCycleTarget$1();
}
function tryOnMounted$1(fn, sync = true, target) {
  const instance = getLifeCycleTarget$1();
  if (instance)
    ;
  else if (sync)
    fn();
  else
    nextTick(fn);
}
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true,
    immediateCallback = false
  } = options;
  const isPending = shallowRef(false);
  let timer = null;
  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop() {
    isPending.value = false;
    clear();
  }
  function start(...args) {
    if (immediateCallback)
      cb();
    clear();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, toValue(interval));
  }
  if (immediate) {
    isPending.value = true;
  }
  tryOnScopeDispose$1(stop);
  return {
    isPending: readonly(isPending),
    start,
    stop
  };
}
function useTimeout(interval = 1e3, options = {}) {
  const {
    controls: exposeControls = false,
    callback
  } = options;
  const controls = useTimeoutFn(
    callback != null ? callback : noop$2,
    interval,
    options
  );
  const ready = computed(() => !controls.isPending.value);
  if (exposeControls) {
    return {
      ready,
      ...controls
    };
  } else {
    return ready;
  }
}
function watchImmediate$1(source, cb, options) {
  return watch(
    source,
    cb,
    {
      ...options,
      immediate: true
    }
  );
}
const defaultWindow$1 = void 0;
function unrefElement$1(elRef) {
  var _a;
  const plain = toValue(elRef);
  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
}
function useEventListener$1(...args) {
  const cleanups = [];
  const cleanup = () => {
    cleanups.forEach((fn) => fn());
    cleanups.length = 0;
  };
  const register = (el, event, listener, options) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const firstParamTargets = computed(() => {
    const test2 = toArray$1(toValue(args[0])).filter((e) => e != null);
    return test2.every((e) => typeof e !== "string") ? test2 : void 0;
  });
  const stopWatch = watchImmediate$1(
    () => {
      var _a, _b;
      return [
        (_b = (_a = firstParamTargets.value) == null ? void 0 : _a.map((e) => unrefElement$1(e))) != null ? _b : [defaultWindow$1].filter((e) => e != null),
        toArray$1(toValue(firstParamTargets.value ? args[1] : args[0])),
        toArray$1(unref(firstParamTargets.value ? args[2] : args[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue(firstParamTargets.value ? args[3] : args[2])
      ];
    },
    ([raw_targets, raw_events, raw_listeners, raw_options]) => {
      cleanup();
      if (!(raw_targets == null ? void 0 : raw_targets.length) || !(raw_events == null ? void 0 : raw_events.length) || !(raw_listeners == null ? void 0 : raw_listeners.length))
        return;
      const optionsClone = isObject$2(raw_options) ? { ...raw_options } : raw_options;
      cleanups.push(
        ...raw_targets.flatMap(
          (el) => raw_events.flatMap(
            (event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))
          )
        )
      );
    },
    { flush: "post" }
  );
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose$1(cleanup);
  return stop;
}
function useMounted$1() {
  const isMounted = shallowRef(false);
  getCurrentInstance$1();
  return isMounted;
}
function useSupported$1(callback) {
  const isMounted = useMounted$1();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useMutationObserver$1(target, callback, options = {}) {
  const { window: window2 = defaultWindow$1, ...mutationOptions } = options;
  let observer;
  const isSupported = useSupported$1(() => window2 && "MutationObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => {
    const value = toValue(target);
    const items = toArray$1(value).map(unrefElement$1).filter(notNullish$1);
    return new Set(items);
  });
  const stopWatch = watch(
    () => targets.value,
    (targets2) => {
      cleanup();
      if (isSupported.value && targets2.size) {
        observer = new MutationObserver(callback);
        targets2.forEach((el) => observer.observe(el, mutationOptions));
      }
    },
    { immediate: true, flush: "post" }
  );
  const takeRecords = () => {
    return observer == null ? void 0 : observer.takeRecords();
  };
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose$1(stop);
  return {
    isSupported,
    stop,
    takeRecords
  };
}
function onElementRemoval$1(target, callback, options = {}) {
  const {
    window: window2 = defaultWindow$1,
    document: document2 = window2 == null ? void 0 : window2.document,
    flush = "sync"
  } = options;
  if (!window2 || !document2)
    return noop$2;
  let stopFn;
  const cleanupAndUpdate = (fn) => {
    stopFn == null ? void 0 : stopFn();
    stopFn = fn;
  };
  const stopWatch = watchEffect(() => {
    const el = unrefElement$1(target);
    if (el) {
      const { stop } = useMutationObserver$1(
        document2,
        (mutationsList) => {
          const targetRemoved = mutationsList.map((mutation) => [...mutation.removedNodes]).flat().some((node) => node === el || node.contains(el));
          if (targetRemoved) {
            callback(mutationsList);
          }
        },
        {
          window: window2,
          childList: true,
          subtree: true
        }
      );
      cleanupAndUpdate(stop);
    }
  }, { flush });
  const stopHandle = () => {
    stopWatch();
    cleanupAndUpdate();
  };
  tryOnScopeDispose$1(stopHandle);
  return stopHandle;
}
function createKeyPredicate(keyFilter) {
  if (typeof keyFilter === "function")
    return keyFilter;
  else if (typeof keyFilter === "string")
    return (event) => event.key === keyFilter;
  else if (Array.isArray(keyFilter))
    return (event) => keyFilter.includes(event.key);
  return () => true;
}
function onKeyStroke(...args) {
  let key;
  let handler;
  let options = {};
  if (args.length === 3) {
    key = args[0];
    handler = args[1];
    options = args[2];
  } else if (args.length === 2) {
    if (typeof args[1] === "object") {
      key = true;
      handler = args[0];
      options = args[1];
    } else {
      key = args[0];
      handler = args[1];
    }
  } else {
    key = true;
    handler = args[0];
  }
  const {
    target = defaultWindow$1,
    eventName = "keydown",
    passive = false,
    dedupe = false
  } = options;
  const predicate = createKeyPredicate(key);
  const listener = (e) => {
    if (e.repeat && toValue(dedupe))
      return;
    if (predicate(e))
      handler(e);
  };
  return useEventListener$1(target, eventName, listener, passive);
}
function useActiveElement$1(options = {}) {
  var _a;
  const {
    window: window2 = defaultWindow$1,
    deep = true,
    triggerOnRemoval = false
  } = options;
  const document2 = (_a = options.document) != null ? _a : window2 == null ? void 0 : window2.document;
  const getDeepActiveElement = () => {
    var _a2;
    let element = document2 == null ? void 0 : document2.activeElement;
    if (deep) {
      while (element == null ? void 0 : element.shadowRoot)
        element = (_a2 = element == null ? void 0 : element.shadowRoot) == null ? void 0 : _a2.activeElement;
    }
    return element;
  };
  const activeElement = shallowRef();
  const trigger = () => {
    activeElement.value = getDeepActiveElement();
  };
  if (window2) {
    const listenerOptions = {
      capture: true,
      passive: true
    };
    useEventListener$1(
      window2,
      "blur",
      (event) => {
        if (event.relatedTarget !== null)
          return;
        trigger();
      },
      listenerOptions
    );
    useEventListener$1(
      window2,
      "focus",
      trigger,
      listenerOptions
    );
  }
  if (triggerOnRemoval) {
    onElementRemoval$1(activeElement, trigger, { document: document2 });
  }
  trigger();
  return activeElement;
}
function useRafFn(fn, options = {}) {
  const {
    immediate = true,
    fpsLimit = void 0,
    window: window2 = defaultWindow$1,
    once = false
  } = options;
  const isActive = shallowRef(false);
  const intervalLimit = computed(() => {
    return fpsLimit ? 1e3 / toValue(fpsLimit) : null;
  });
  let previousFrameTimestamp = 0;
  let rafId = null;
  function loop(timestamp2) {
    if (!isActive.value || !window2)
      return;
    if (!previousFrameTimestamp)
      previousFrameTimestamp = timestamp2;
    const delta = timestamp2 - previousFrameTimestamp;
    if (intervalLimit.value && delta < intervalLimit.value) {
      rafId = window2.requestAnimationFrame(loop);
      return;
    }
    previousFrameTimestamp = timestamp2;
    fn({ delta, timestamp: timestamp2 });
    if (once) {
      isActive.value = false;
      rafId = null;
      return;
    }
    rafId = window2.requestAnimationFrame(loop);
  }
  function resume() {
    if (!isActive.value && window2) {
      isActive.value = true;
      previousFrameTimestamp = 0;
      rafId = window2.requestAnimationFrame(loop);
    }
  }
  function pause() {
    isActive.value = false;
    if (rafId != null && window2) {
      window2.cancelAnimationFrame(rafId);
      rafId = null;
    }
  }
  if (immediate)
    resume();
  tryOnScopeDispose$1(pause);
  return {
    isActive: readonly(isActive),
    pause,
    resume
  };
}
function cloneFnJSON$1(source) {
  return JSON.parse(JSON.stringify(source));
}
function useCurrentElement(rootComponent) {
  const vm = getCurrentInstance$1();
  const currentElement = computedWithControl(
    () => null,
    () => vm.proxy.$el
  );
  return currentElement;
}
function useResizeObserver(target, callback, options = {}) {
  const { window: window2 = defaultWindow$1, ...observerOptions } = options;
  let observer;
  const isSupported = useSupported$1(() => window2 && "ResizeObserver" in window2);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const targets = computed(() => {
    const _targets = toValue(target);
    return Array.isArray(_targets) ? _targets.map((el) => unrefElement$1(el)) : [unrefElement$1(_targets)];
  });
  const stopWatch = watch(
    targets,
    (els) => {
      cleanup();
      if (isSupported.value && window2) {
        observer = new ResizeObserver(callback);
        for (const _el of els) {
          if (_el)
            observer.observe(_el, observerOptions);
        }
      }
    },
    { immediate: true, flush: "post" }
  );
  const stop = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose$1(stop);
  return {
    isSupported,
    stop
  };
}
const EVENT_FOCUS_IN = "focusin";
const EVENT_FOCUS_OUT = "focusout";
const PSEUDO_CLASS_FOCUS_WITHIN = ":focus-within";
function useFocusWithin(target, options = {}) {
  const { window: window2 = defaultWindow$1 } = options;
  const targetElement = computed(() => unrefElement$1(target));
  const _focused = shallowRef(false);
  const focused = computed(() => _focused.value);
  const activeElement = useActiveElement$1(options);
  if (!window2 || !activeElement.value) {
    return { focused };
  }
  const listenerOptions = { passive: true };
  useEventListener$1(targetElement, EVENT_FOCUS_IN, () => _focused.value = true, listenerOptions);
  useEventListener$1(targetElement, EVENT_FOCUS_OUT, () => {
    var _a, _b, _c;
    return _focused.value = (_c = (_b = (_a = targetElement.value) == null ? void 0 : _a.matches) == null ? void 0 : _b.call(_a, PSEUDO_CLASS_FOCUS_WITHIN)) != null ? _c : false;
  }, listenerOptions);
  return { focused };
}
function useParentElement(element = useCurrentElement()) {
  const parentElement = shallowRef();
  const update = () => {
    const el = unrefElement$1(element);
    if (el)
      parentElement.value = el.parentElement;
  };
  tryOnMounted$1(update);
  watch(() => toValue(element), update);
  return parentElement;
}
function useVModel$1(props, key, emit, options = {}) {
  var _a, _b, _c;
  const {
    clone = false,
    passive = false,
    eventName,
    deep = false,
    defaultValue,
    shouldEmit
  } = options;
  const vm = getCurrentInstance$1();
  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));
  let event = eventName;
  if (!key) {
    key = "modelValue";
  }
  event = event || `update:${key.toString()}`;
  const cloneFn = (val) => !clone ? val : typeof clone === "function" ? clone(val) : cloneFnJSON$1(val);
  const getValue2 = () => isDef$1(props[key]) ? cloneFn(props[key]) : defaultValue;
  const triggerEmit = (value) => {
    if (shouldEmit) {
      if (shouldEmit(value))
        _emit(event, value);
    } else {
      _emit(event, value);
    }
  };
  if (passive) {
    const initialValue = getValue2();
    const proxy = ref(initialValue);
    let isUpdating = false;
    watch(
      () => props[key],
      (v) => {
        if (!isUpdating) {
          isUpdating = true;
          proxy.value = cloneFn(v);
          nextTick(() => isUpdating = false);
        }
      }
    );
    watch(
      proxy,
      (v) => {
        if (!isUpdating && (v !== props[key] || deep))
          triggerEmit(v);
      },
      { deep }
    );
    return proxy;
  } else {
    return computed({
      get() {
        return getValue2();
      },
      set(value) {
        triggerEmit(value);
      }
    });
  }
}
function useEmitAsProps(emit) {
  const vm = getCurrentInstance$1();
  const events2 = vm?.type.emits;
  const result = {};
  if (!events2?.length) console.warn(`No emitted event found. Please check component: ${vm?.type.__name}`);
  events2?.forEach((ev) => {
    result[toHandlerKey(camelize$1(ev))] = (...arg) => emit(ev, ...arg);
  });
  return result;
}
function useForwardExpose() {
  const instance = getCurrentInstance$1();
  const currentRef = ref();
  const currentElement = computed(() => {
    return ["#text", "#comment"].includes(currentRef.value?.$el.nodeName) ? currentRef.value?.$el.nextElementSibling : unrefElement$1(currentRef);
  });
  const localExpose = Object.assign({}, instance.exposed);
  const ret = {};
  for (const key in instance.props) Object.defineProperty(ret, key, {
    enumerable: true,
    configurable: true,
    get: () => instance.props[key]
  });
  if (Object.keys(localExpose).length > 0) for (const key in localExpose) Object.defineProperty(ret, key, {
    enumerable: true,
    configurable: true,
    get: () => localExpose[key]
  });
  Object.defineProperty(ret, "$el", {
    enumerable: true,
    configurable: true,
    get: () => instance.vnode.el
  });
  instance.exposed = ret;
  function forwardRef(ref$1) {
    currentRef.value = ref$1;
    if (!ref$1) return;
    Object.defineProperty(ret, "$el", {
      enumerable: true,
      configurable: true,
      get: () => ref$1 instanceof Element ? ref$1 : ref$1.$el
    });
    instance.exposed = ret;
  }
  return {
    forwardRef,
    currentRef,
    currentElement
  };
}
function useForwardProps(props) {
  const vm = getCurrentInstance$1();
  const defaultProps = Object.keys(vm?.type.props ?? {}).reduce((prev, curr) => {
    const defaultValue = (vm?.type.props[curr]).default;
    if (defaultValue !== void 0) prev[curr] = defaultValue;
    return prev;
  }, {});
  const refProps = toRef$2(props);
  return computed(() => {
    const preservedProps = {};
    const assignedProps = vm?.vnode.props ?? {};
    Object.keys(assignedProps).forEach((key) => {
      preservedProps[camelize$1(key)] = assignedProps[key];
    });
    return Object.keys({
      ...defaultProps,
      ...preservedProps
    }).reduce((prev, curr) => {
      if (refProps.value[curr] !== void 0) prev[curr] = refProps.value[curr];
      return prev;
    }, {});
  });
}
function useForwardPropsEmits(props, emit) {
  const parsedProps = useForwardProps(props);
  const emitsAsProps = emit ? useEmitAsProps(emit) : {};
  return computed(() => ({
    ...parsedProps.value,
    ...emitsAsProps
  }));
}
function useStateMachine(initialState, machine) {
  const state2 = ref(initialState);
  function reducer(event) {
    const nextState = machine[state2.value][event];
    return nextState ?? state2.value;
  }
  const dispatch = (event) => {
    state2.value = reducer(event);
  };
  return {
    state: state2,
    dispatch
  };
}
function usePresence(present, node) {
  const stylesRef = ref({});
  const prevAnimationNameRef = ref("none");
  const prevPresentRef = ref(present);
  const initialState = present.value ? "mounted" : "unmounted";
  let timeoutId;
  const ownerWindow = node.value?.ownerDocument.defaultView ?? defaultWindow$1;
  const { state: state2, dispatch } = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: { MOUNT: "mounted" }
  });
  watch(present, async (currentPresent, prevPresent) => {
    const hasPresentChanged = prevPresent !== currentPresent;
    await nextTick();
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.value;
      const currentAnimationName = getAnimationName(node.value);
      if (currentPresent) {
        dispatch("MOUNT");
      } else if (currentAnimationName === "none" || currentAnimationName === "undefined" || stylesRef.value?.display === "none") {
        dispatch("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (prevPresent && isAnimating) {
          dispatch("ANIMATION_OUT");
        } else {
          dispatch("UNMOUNT");
        }
      }
    }
  }, { immediate: true });
  const handleAnimationEnd = (event) => {
    const currentAnimationName = getAnimationName(node.value);
    const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
    state2.value === "mounted" ? "enter" : "leave";
    if (event.target === node.value && isCurrentAnimation) {
      dispatch("ANIMATION_END");
      if (!prevPresentRef.value) {
        const currentFillMode = node.value.style.animationFillMode;
        node.value.style.animationFillMode = "forwards";
        timeoutId = ownerWindow?.setTimeout(() => {
          if (node.value?.style.animationFillMode === "forwards") node.value.style.animationFillMode = currentFillMode;
        });
      }
    }
    if (event.target === node.value && currentAnimationName === "none") dispatch("ANIMATION_END");
  };
  const handleAnimationStart = (event) => {
    if (event.target === node.value) prevAnimationNameRef.value = getAnimationName(node.value);
  };
  watch(node, (newNode, oldNode) => {
    if (newNode) {
      stylesRef.value = getComputedStyle(newNode);
      newNode.addEventListener("animationstart", handleAnimationStart);
      newNode.addEventListener("animationcancel", handleAnimationEnd);
      newNode.addEventListener("animationend", handleAnimationEnd);
    } else {
      dispatch("ANIMATION_END");
      if (timeoutId !== void 0) ownerWindow?.clearTimeout(timeoutId);
      oldNode?.removeEventListener("animationstart", handleAnimationStart);
      oldNode?.removeEventListener("animationcancel", handleAnimationEnd);
      oldNode?.removeEventListener("animationend", handleAnimationEnd);
    }
  }, { immediate: true });
  watch(state2, () => {
    const currentAnimationName = getAnimationName(node.value);
    prevAnimationNameRef.value = state2.value === "mounted" ? currentAnimationName : "none";
  });
  const isPresent2 = computed(() => ["mounted", "unmountSuspended"].includes(state2.value));
  return { isPresent: isPresent2 };
}
function getAnimationName(node) {
  return node ? getComputedStyle(node).animationName || "none" : "none";
}
var Presence_default = defineComponent({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: true
    },
    forceMount: { type: Boolean }
  },
  slots: {},
  setup(props, { slots, expose }) {
    const { present, forceMount } = toRefs(props);
    const node = ref();
    const { isPresent: isPresent2 } = usePresence(present, node);
    expose({ present: isPresent2 });
    let children = slots.default({ present: isPresent2.value });
    children = renderSlotFragments$1(children || []);
    const instance = getCurrentInstance$1();
    if (children && children?.length > 1) {
      const componentName = instance?.parent?.type.name ? `<${instance.parent.type.name} />` : "component";
      throw new Error([
        `Detected an invalid children for \`${componentName}\` for  \`Presence\` component.`,
        "",
        "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
        "You can apply a few solutions:",
        ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map((line) => `  - ${line}`).join("\n")
      ].join("\n"));
    }
    return () => {
      if (forceMount.value || present.value || isPresent2.value) return h(slots.default({ present: isPresent2.value })[0], { ref: (v) => {
        const el = unrefElement$1(v);
        if (typeof el?.hasAttribute === "undefined") return el;
        if (el?.hasAttribute("data-reka-popper-content-wrapper")) node.value = el.firstElementChild;
        else node.value = el;
        return el;
      } });
      else return null;
    };
  }
});
const Slot = defineComponent({
  name: "PrimitiveSlot",
  inheritAttrs: false,
  setup(_2, { attrs, slots }) {
    return () => {
      if (!slots.default) return null;
      const children = renderSlotFragments$1(slots.default());
      const firstNonCommentChildrenIndex = children.findIndex((child) => child.type !== Comment);
      if (firstNonCommentChildrenIndex === -1) return children;
      const firstNonCommentChildren = children[firstNonCommentChildrenIndex];
      delete firstNonCommentChildren.props?.ref;
      const mergedProps = firstNonCommentChildren.props ? mergeProps(attrs, firstNonCommentChildren.props) : attrs;
      const cloned = cloneVNode({
        ...firstNonCommentChildren,
        props: {}
      }, mergedProps);
      if (children.length === 1) return cloned;
      children[firstNonCommentChildrenIndex] = cloned;
      return children;
    };
  }
});
const SELF_CLOSING_TAGS$1 = [
  "area",
  "img",
  "input"
];
const Primitive = defineComponent({
  name: "Primitive",
  inheritAttrs: false,
  props: {
    asChild: {
      type: Boolean,
      default: false
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(props, { attrs, slots }) {
    const asTag = props.asChild ? "template" : props.as;
    if (typeof asTag === "string" && SELF_CLOSING_TAGS$1.includes(asTag)) return () => h(asTag, attrs);
    if (asTag !== "template") return () => h(props.as, attrs, { default: slots.default });
    return () => h(Slot, attrs, { default: slots.default });
  }
});
function usePrimitiveElement() {
  const primitiveElement = ref();
  const currentElement = computed(() => ["#text", "#comment"].includes(primitiveElement.value?.$el.nodeName) ? primitiveElement.value?.$el.nextElementSibling : unrefElement$1(primitiveElement));
  return {
    primitiveElement,
    currentElement
  };
}
var DismissableLayerBranch_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  __name: "DismissableLayerBranch",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props = __props;
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), mergeProps({ ref: unref(forwardRef) }, props), {
        default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var DismissableLayerBranch_default = DismissableLayerBranch_vue_vue_type_script_setup_true_lang_default;
const AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
const AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
const EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = getActiveElement();
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (getActiveElement() !== previouslyFocusedElement) return true;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = (void 0).createTreeWalker(container, NodeFilter.SHOW_ELEMENT, { acceptNode: (node) => {
    const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
    if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
    return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
  } });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) if (!isHidden(element, { upTo: container })) return element;
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = getActiveElement();
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select) element.select();
  }
}
var Teleport_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  __name: "Teleport",
  props: {
    to: {
      type: null,
      required: false,
      default: "body"
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const isMounted = useMounted$1();
    return (_ctx, _cache) => {
      return unref(isMounted) || _ctx.forceMount ? (openBlock(), createBlock(Teleport, {
        key: 0,
        to: _ctx.to,
        disabled: _ctx.disabled,
        defer: _ctx.defer
      }, [renderSlot(_ctx.$slots, "default")], 8, [
        "to",
        "disabled",
        "defer"
      ])) : createCommentVNode("v-if", true);
    };
  }
});
var Teleport_default = Teleport_vue_vue_type_script_setup_true_lang_default;
const ITEM_DATA_ATTR = "data-reka-collection-item";
function useCollection(options = {}) {
  const { key = "", isProvider = false } = options;
  const injectionKey = `${key}CollectionProvider`;
  let context;
  if (isProvider) {
    const itemMap = ref(/* @__PURE__ */ new Map());
    const collectionRef = ref();
    context = {
      collectionRef,
      itemMap
    };
    provide(injectionKey, context);
  } else context = inject(injectionKey);
  const getItems = (includeDisabledItem = false) => {
    const collectionNode = context.collectionRef.value;
    if (!collectionNode) return [];
    const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
    const items = Array.from(context.itemMap.value.values());
    const orderedItems = items.sort((a, b) => orderedNodes.indexOf(a.ref) - orderedNodes.indexOf(b.ref));
    if (includeDisabledItem) return orderedItems;
    else return orderedItems.filter((i) => i.ref.dataset.disabled !== "");
  };
  const CollectionSlot = defineComponent({
    name: "CollectionSlot",
    setup(_2, { slots }) {
      const { primitiveElement, currentElement } = usePrimitiveElement();
      watch(currentElement, () => {
        context.collectionRef.value = currentElement.value;
      });
      return () => h(Slot, { ref: primitiveElement }, slots);
    }
  });
  const CollectionItem = defineComponent({
    name: "CollectionItem",
    inheritAttrs: false,
    props: { value: { validator: () => true } },
    setup(props, { slots, attrs }) {
      const { primitiveElement, currentElement } = usePrimitiveElement();
      watchEffect((cleanupFn) => {
        if (currentElement.value) {
          const key$1 = markRaw(currentElement.value);
          context.itemMap.value.set(key$1, {
            ref: currentElement.value,
            value: props.value
          });
          cleanupFn(() => context.itemMap.value.delete(key$1));
        }
      });
      return () => h(Slot, {
        ...attrs,
        [ITEM_DATA_ATTR]: "",
        ref: primitiveElement
      }, slots);
    }
  });
  const reactiveItems = computed(() => Array.from(context.itemMap.value.values()));
  const itemMapSize = computed(() => context.itemMap.value.size);
  return {
    getItems,
    reactiveItems,
    itemMapSize,
    CollectionSlot,
    CollectionItem
  };
}
var VisuallyHidden_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  __name: "VisuallyHidden",
  props: {
    feature: {
      type: String,
      required: false,
      default: "focusable"
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "span"
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "aria-hidden": _ctx.feature === "focusable" ? "true" : void 0,
        "data-hidden": _ctx.feature === "fully-hidden" ? "" : void 0,
        tabindex: _ctx.feature === "fully-hidden" ? "-1" : void 0,
        style: {
          position: "absolute",
          border: 0,
          width: "1px",
          height: "1px",
          padding: 0,
          margin: "-1px",
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          clipPath: "inset(50%)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          top: "-1px",
          left: "-1px"
        }
      }, {
        default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "aria-hidden",
        "data-hidden",
        "tabindex"
      ]);
    };
  }
});
var VisuallyHidden_default = VisuallyHidden_vue_vue_type_script_setup_true_lang_default;
const DEFAULT_MAX = 100;
const [injectProgressRootContext, provideProgressRootContext] = createContext$1("ProgressRoot");
const isNumber$2 = (v) => typeof v === "number";
function validateValue(value, max) {
  const isValidValueError = isNullish$1(value) || isNumber$2(value) && !Number.isNaN(value) && value <= max && value >= 0;
  if (isValidValueError) return value;
  console.error(`Invalid prop \`value\` of value \`${value}\` supplied to \`ProgressRoot\`. The \`value\` prop must be:
  - a positive number
  - less than the value passed to \`max\` (or ${DEFAULT_MAX} if no \`max\` prop is set)
  - \`null\`  or \`undefined\` if the progress is indeterminate.

Defaulting to \`null\`.`);
  return null;
}
function validateMax(max) {
  const isValidMaxError = isNumber$2(max) && !Number.isNaN(max) && max > 0;
  if (isValidMaxError) return max;
  console.error(`Invalid prop \`max\` of value \`${max}\` supplied to \`ProgressRoot\`. Only numbers greater than 0 are valid max values. Defaulting to \`${DEFAULT_MAX}\`.`);
  return DEFAULT_MAX;
}
var ProgressRoot_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  __name: "ProgressRoot",
  props: {
    modelValue: {
      type: [Number, null],
      required: false
    },
    max: {
      type: Number,
      required: false,
      default: DEFAULT_MAX
    },
    getValueLabel: {
      type: Function,
      required: false,
      default: (value, max) => isNumber$2(value) ? `${Math.round(value / max * DEFAULT_MAX)}%` : void 0
    },
    getValueText: {
      type: Function,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  emits: ["update:modelValue", "update:max"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    useForwardExpose();
    const modelValue = useVModel$1(props, "modelValue", emit, { passive: props.modelValue === void 0 });
    const max = useVModel$1(props, "max", emit, { passive: props.max === void 0 });
    watch(() => modelValue.value, async (value) => {
      const correctedValue = validateValue(value, props.max);
      if (correctedValue !== value) {
        await nextTick();
        modelValue.value = correctedValue;
      }
    }, { immediate: true });
    watch(() => props.max, (newMax) => {
      const correctedMax = validateMax(props.max);
      if (correctedMax !== newMax) max.value = correctedMax;
    }, { immediate: true });
    const progressState = computed(() => {
      if (isNullish$1(modelValue.value)) return "indeterminate";
      if (modelValue.value === max.value) return "complete";
      return "loading";
    });
    provideProgressRootContext({
      modelValue,
      max,
      progressState
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        "as-child": _ctx.asChild,
        as: _ctx.as,
        "aria-valuemax": unref(max),
        "aria-valuemin": 0,
        "aria-valuenow": isNumber$2(unref(modelValue)) ? unref(modelValue) : void 0,
        "aria-valuetext": _ctx.getValueText?.(unref(modelValue), unref(max)),
        "aria-label": _ctx.getValueLabel(unref(modelValue), unref(max)),
        role: "progressbar",
        "data-state": progressState.value,
        "data-value": unref(modelValue) ?? void 0,
        "data-max": unref(max)
      }, {
        default: withCtx(() => [renderSlot(_ctx.$slots, "default", { modelValue: unref(modelValue) })]),
        _: 3
      }, 8, [
        "as-child",
        "as",
        "aria-valuemax",
        "aria-valuenow",
        "aria-valuetext",
        "aria-label",
        "data-state",
        "data-value",
        "data-max"
      ]);
    };
  }
});
var ProgressRoot_default = ProgressRoot_vue_vue_type_script_setup_true_lang_default;
var ProgressIndicator_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  __name: "ProgressIndicator",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props = __props;
    const rootContext = injectProgressRootContext();
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), mergeProps(props, {
        "data-state": unref(rootContext).progressState.value,
        "data-value": unref(rootContext).modelValue?.value ?? void 0,
        "data-max": unref(rootContext).max.value
      }), {
        default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
        _: 3
      }, 16, [
        "data-state",
        "data-value",
        "data-max"
      ]);
    };
  }
});
var ProgressIndicator_default = ProgressIndicator_vue_vue_type_script_setup_true_lang_default;
var ToastAnnounceExclude_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  __name: "ToastAnnounceExclude",
  props: {
    altText: {
      type: String,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), {
        as: _ctx.as,
        "as-child": _ctx.asChild,
        "data-reka-toast-announce-exclude": "",
        "data-reka-toast-announce-alt": _ctx.altText || void 0
      }, {
        default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
        _: 3
      }, 8, [
        "as",
        "as-child",
        "data-reka-toast-announce-alt"
      ]);
    };
  }
});
var ToastAnnounceExclude_default = ToastAnnounceExclude_vue_vue_type_script_setup_true_lang_default;
const [injectToastProviderContext, provideToastProviderContext] = createContext$1("ToastProvider");
var ToastProvider_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  inheritAttrs: false,
  __name: "ToastProvider",
  props: {
    label: {
      type: String,
      required: false,
      default: "Notification"
    },
    duration: {
      type: Number,
      required: false,
      default: 5e3
    },
    disableSwipe: {
      type: Boolean,
      required: false
    },
    swipeDirection: {
      type: String,
      required: false,
      default: "right"
    },
    swipeThreshold: {
      type: Number,
      required: false,
      default: 50
    }
  },
  setup(__props) {
    const props = __props;
    const { label, duration: duration2, disableSwipe, swipeDirection, swipeThreshold } = toRefs(props);
    useCollection({ isProvider: true });
    const viewport = ref();
    const toastCount = ref(0);
    const isFocusedToastEscapeKeyDownRef = ref(false);
    const isClosePausedRef = ref(false);
    if (props.label && typeof props.label === "string" && !props.label.trim()) {
      const error = "Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`.";
      throw new Error(error);
    }
    provideToastProviderContext({
      label,
      duration: duration2,
      disableSwipe,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport,
      onViewportChange(el) {
        viewport.value = el;
      },
      onToastAdd() {
        toastCount.value++;
      },
      onToastRemove() {
        toastCount.value--;
      },
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef
    });
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});
var ToastProvider_default = ToastProvider_vue_vue_type_script_setup_true_lang_default;
var ToastAnnounce_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  __name: "ToastAnnounce",
  setup(__props) {
    const providerContext = injectToastProviderContext();
    const isAnnounced = useTimeout(1e3);
    const renderAnnounceText = ref(false);
    useRafFn(() => {
      renderAnnounceText.value = true;
    });
    return (_ctx, _cache) => {
      return unref(isAnnounced) || renderAnnounceText.value ? (openBlock(), createBlock(unref(VisuallyHidden_default), { key: 0 }, {
        default: withCtx(() => [createTextVNode(toDisplayString$1(unref(providerContext).label.value) + " ", 1), renderSlot(_ctx.$slots, "default")]),
        _: 3
      })) : createCommentVNode("v-if", true);
    };
  }
});
var ToastAnnounce_default = ToastAnnounce_vue_vue_type_script_setup_true_lang_default;
const TOAST_SWIPE_START = "toast.swipeStart";
const TOAST_SWIPE_MOVE = "toast.swipeMove";
const TOAST_SWIPE_CANCEL = "toast.swipeCancel";
const TOAST_SWIPE_END = "toast.swipeEnd";
const VIEWPORT_PAUSE = "toast.viewportPause";
const VIEWPORT_RESUME = "toast.viewportResume";
function handleAndDispatchCustomEvent(name2, handler, detail) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name2, {
    bubbles: false,
    cancelable: true,
    detail
  });
  if (handler) currentTarget.addEventListener(name2, handler, { once: true });
  currentTarget.dispatchEvent(event);
}
function isDeltaInDirection(delta, direction, threshold = 0) {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") return isDeltaX && deltaX > threshold;
  else return !isDeltaX && deltaY > threshold;
}
function isHTMLElement$2(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
    if (isHTMLElement$2(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.rekaToastAnnounceExclude === "";
      if (!isHidden2) if (isExcluded) {
        const altText = node.dataset.rekaToastAnnounceAlt;
        if (altText) textContent.push(altText);
      } else textContent.push(...getAnnounceTextContent(node));
    }
  });
  return textContent;
}
const [injectToastRootContext, provideToastRootContext] = createContext$1("ToastRoot");
var ToastRootImpl_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  inheritAttrs: false,
  __name: "ToastRootImpl",
  props: {
    type: {
      type: String,
      required: false
    },
    open: {
      type: Boolean,
      required: false,
      default: false
    },
    duration: {
      type: Number,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "li"
    }
  },
  emits: [
    "close",
    "escapeKeyDown",
    "pause",
    "resume",
    "swipeStart",
    "swipeMove",
    "swipeCancel",
    "swipeEnd"
  ],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { forwardRef, currentElement } = useForwardExpose();
    const { CollectionItem } = useCollection();
    const providerContext = injectToastProviderContext();
    const pointerStartRef = ref(null);
    const swipeDeltaRef = ref(null);
    const duration2 = computed(() => typeof props.duration === "number" ? props.duration : providerContext.duration.value);
    const closeTimerStartTimeRef = ref(0);
    const closeTimerRemainingTimeRef = ref(duration2.value);
    const closeTimerRef = ref(0);
    const remainingTime = ref(duration2.value);
    const remainingRaf = useRafFn(() => {
      const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.value;
      remainingTime.value = Math.max(closeTimerRemainingTimeRef.value - elapsedTime, 0);
    }, { fpsLimit: 60 });
    function startTimer(duration$1) {
      if (duration$1 <= 0 || duration$1 === Number.POSITIVE_INFINITY) return;
      return;
    }
    function handleClose(event) {
      const isNonPointerEvent = event?.pointerType === "";
      const isFocusInToast = currentElement.value?.contains(getActiveElement());
      if (isFocusInToast && isNonPointerEvent) providerContext.viewport.value?.focus();
      if (isNonPointerEvent) providerContext.isClosePausedRef.value = false;
      emits("close");
    }
    const announceTextContent = computed(() => currentElement.value ? getAnnounceTextContent(currentElement.value) : null);
    if (props.type && !["foreground", "background"].includes(props.type)) {
      const error = "Invalid prop `type` supplied to `Toast`. Expected `foreground | background`.";
      throw new Error(error);
    }
    watchEffect((cleanupFn) => {
      const viewport = providerContext.viewport.value;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.value);
          remainingRaf.resume();
          emits("resume");
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.value;
          closeTimerRemainingTimeRef.value = closeTimerRemainingTimeRef.value - elapsedTime;
          (void 0).clearTimeout(closeTimerRef.value);
          remainingRaf.pause();
          emits("pause");
        };
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    });
    watch(() => [props.open, duration2.value], () => {
      closeTimerRemainingTimeRef.value = duration2.value;
      if (props.open && !providerContext.isClosePausedRef.value) startTimer(duration2.value);
    }, { immediate: true });
    onKeyStroke("Escape", (event) => {
      emits("escapeKeyDown", event);
      if (!event.defaultPrevented) {
        providerContext.isFocusedToastEscapeKeyDownRef.value = true;
        handleClose();
      }
    });
    provideToastRootContext({ onClose: handleClose });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [announceTextContent.value ? (openBlock(), createBlock(ToastAnnounce_default, {
        key: 0,
        role: "alert",
        "aria-live": _ctx.type === "foreground" ? "assertive" : "polite",
        "aria-atomic": "true"
      }, {
        default: withCtx(() => [createTextVNode(toDisplayString$1(announceTextContent.value), 1)]),
        _: 1
      }, 8, ["aria-live"])) : createCommentVNode("v-if", true), unref(providerContext).viewport.value ? (openBlock(), createBlock(Teleport, {
        key: 1,
        to: unref(providerContext).viewport.value
      }, [createVNode(unref(CollectionItem), null, {
        default: withCtx(() => [createVNode(unref(Primitive), mergeProps({
          ref: unref(forwardRef),
          role: "alert",
          "aria-live": "off",
          "aria-atomic": "true",
          tabindex: "0"
        }, _ctx.$attrs, {
          as: _ctx.as,
          "as-child": _ctx.asChild,
          "data-state": _ctx.open ? "open" : "closed",
          "data-swipe-direction": unref(providerContext).swipeDirection.value,
          style: unref(providerContext).disableSwipe.value ? void 0 : {
            userSelect: "none",
            touchAction: "none"
          },
          onPointerdown: _cache[0] || (_cache[0] = withModifiers((event) => {
            if (unref(providerContext).disableSwipe.value) return;
            pointerStartRef.value = {
              x: event.clientX,
              y: event.clientY
            };
          }, ["left"])),
          onPointermove: _cache[1] || (_cache[1] = (event) => {
            if (unref(providerContext).disableSwipe.value || !pointerStartRef.value) return;
            const x = event.clientX - pointerStartRef.value.x;
            const y = event.clientY - pointerStartRef.value.y;
            const hasSwipeMoveStarted = Boolean(swipeDeltaRef.value);
            const isHorizontalSwipe = ["left", "right"].includes(unref(providerContext).swipeDirection.value);
            const clamp2 = ["left", "up"].includes(unref(providerContext).swipeDirection.value) ? Math.min : Math.max;
            const clampedX = isHorizontalSwipe ? clamp2(0, x) : 0;
            const clampedY = !isHorizontalSwipe ? clamp2(0, y) : 0;
            const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
            const delta = {
              x: clampedX,
              y: clampedY
            };
            const eventDetail = {
              originalEvent: event,
              delta
            };
            if (hasSwipeMoveStarted) {
              swipeDeltaRef.value = delta;
              unref(handleAndDispatchCustomEvent)(unref(TOAST_SWIPE_MOVE), (ev) => emits("swipeMove", ev), eventDetail);
            } else if (unref(isDeltaInDirection)(delta, unref(providerContext).swipeDirection.value, moveStartBuffer)) {
              swipeDeltaRef.value = delta;
              unref(handleAndDispatchCustomEvent)(unref(TOAST_SWIPE_START), (ev) => emits("swipeStart", ev), eventDetail);
              event.target.setPointerCapture(event.pointerId);
            } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) pointerStartRef.value = null;
          }),
          onPointerup: _cache[2] || (_cache[2] = (event) => {
            if (unref(providerContext).disableSwipe.value) return;
            const delta = swipeDeltaRef.value;
            const target = event.target;
            if (target.hasPointerCapture(event.pointerId)) target.releasePointerCapture(event.pointerId);
            swipeDeltaRef.value = null;
            pointerStartRef.value = null;
            if (delta) {
              const toast = event.currentTarget;
              const eventDetail = {
                originalEvent: event,
                delta
              };
              if (unref(isDeltaInDirection)(delta, unref(providerContext).swipeDirection.value, unref(providerContext).swipeThreshold.value)) unref(handleAndDispatchCustomEvent)(unref(TOAST_SWIPE_END), (ev) => emits("swipeEnd", ev), eventDetail);
              else unref(handleAndDispatchCustomEvent)(unref(TOAST_SWIPE_CANCEL), (ev) => emits("swipeCancel", ev), eventDetail);
              toast?.addEventListener("click", (event$1) => event$1.preventDefault(), { once: true });
            }
          })
        }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default", {
            remaining: remainingTime.value,
            duration: duration2.value
          })]),
          _: 3
        }, 16, [
          "as",
          "as-child",
          "data-state",
          "data-swipe-direction",
          "style"
        ])]),
        _: 3
      })], 8, ["to"])) : createCommentVNode("v-if", true)], 64);
    };
  }
});
var ToastRootImpl_default = ToastRootImpl_vue_vue_type_script_setup_true_lang_default;
var ToastClose_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  __name: "ToastClose",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "button"
    }
  },
  setup(__props) {
    const props = __props;
    const rootContext = injectToastRootContext();
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(ToastAnnounceExclude_default, { "as-child": "" }, {
        default: withCtx(() => [createVNode(unref(Primitive), mergeProps(props, {
          ref: unref(forwardRef),
          type: _ctx.as === "button" ? "button" : void 0,
          onClick: unref(rootContext).onClose
        }), {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 16, ["type", "onClick"])]),
        _: 3
      });
    };
  }
});
var ToastClose_default = ToastClose_vue_vue_type_script_setup_true_lang_default;
var ToastAction_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  __name: "ToastAction",
  props: {
    altText: {
      type: String,
      required: true
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props = __props;
    if (!props.altText) throw new Error("Missing prop `altText` expected on `ToastAction`");
    const { forwardRef } = useForwardExpose();
    return (_ctx, _cache) => {
      return _ctx.altText ? (openBlock(), createBlock(ToastAnnounceExclude_default, {
        key: 0,
        "alt-text": _ctx.altText,
        "as-child": ""
      }, {
        default: withCtx(() => [createVNode(ToastClose_default, {
          ref: unref(forwardRef),
          as: _ctx.as,
          "as-child": _ctx.asChild
        }, {
          default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
          _: 3
        }, 8, ["as", "as-child"])]),
        _: 3
      }, 8, ["alt-text"])) : createCommentVNode("v-if", true);
    };
  }
});
var ToastAction_default = ToastAction_vue_vue_type_script_setup_true_lang_default;
var ToastDescription_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  __name: "ToastDescription",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ToastDescription_default = ToastDescription_vue_vue_type_script_setup_true_lang_default;
var ToastPortal_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  __name: "ToastPortal",
  props: {
    to: {
      type: null,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    defer: {
      type: Boolean,
      required: false
    },
    forceMount: {
      type: Boolean,
      required: false
    }
  },
  setup(__props) {
    const props = __props;
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Teleport_default), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ToastPortal_default = ToastPortal_vue_vue_type_script_setup_true_lang_default;
var ToastRoot_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  __name: "ToastRoot",
  props: {
    defaultOpen: {
      type: Boolean,
      required: false,
      default: true
    },
    forceMount: {
      type: Boolean,
      required: false
    },
    type: {
      type: String,
      required: false,
      default: "foreground"
    },
    open: {
      type: Boolean,
      required: false,
      default: void 0
    },
    duration: {
      type: Number,
      required: false
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "li"
    }
  },
  emits: [
    "escapeKeyDown",
    "pause",
    "resume",
    "swipeStart",
    "swipeMove",
    "swipeCancel",
    "swipeEnd",
    "update:open"
  ],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { forwardRef } = useForwardExpose();
    const open = useVModel$1(props, "open", emits, {
      defaultValue: props.defaultOpen,
      passive: props.open === void 0
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Presence_default), { present: _ctx.forceMount || unref(open) }, {
        default: withCtx(() => [createVNode(ToastRootImpl_default, mergeProps({
          ref: unref(forwardRef),
          open: unref(open),
          type: _ctx.type,
          as: _ctx.as,
          "as-child": _ctx.asChild,
          duration: _ctx.duration
        }, _ctx.$attrs, {
          onClose: _cache[0] || (_cache[0] = ($event) => open.value = false),
          onPause: _cache[1] || (_cache[1] = ($event) => emits("pause")),
          onResume: _cache[2] || (_cache[2] = ($event) => emits("resume")),
          onEscapeKeyDown: _cache[3] || (_cache[3] = ($event) => emits("escapeKeyDown", $event)),
          onSwipeStart: _cache[4] || (_cache[4] = (event) => {
            emits("swipeStart", event);
            if (!event.defaultPrevented) event.currentTarget.setAttribute("data-swipe", "start");
          }),
          onSwipeMove: _cache[5] || (_cache[5] = (event) => {
            emits("swipeMove", event);
            if (!event.defaultPrevented) {
              const { x, y } = event.detail.delta;
              const target = event.currentTarget;
              target.setAttribute("data-swipe", "move");
              target.style.setProperty("--reka-toast-swipe-move-x", `${x}px`);
              target.style.setProperty("--reka-toast-swipe-move-y", `${y}px`);
            }
          }),
          onSwipeCancel: _cache[6] || (_cache[6] = (event) => {
            emits("swipeCancel", event);
            if (!event.defaultPrevented) {
              const target = event.currentTarget;
              target.setAttribute("data-swipe", "cancel");
              target.style.removeProperty("--reka-toast-swipe-move-x");
              target.style.removeProperty("--reka-toast-swipe-move-y");
              target.style.removeProperty("--reka-toast-swipe-end-x");
              target.style.removeProperty("--reka-toast-swipe-end-y");
            }
          }),
          onSwipeEnd: _cache[7] || (_cache[7] = (event) => {
            emits("swipeEnd", event);
            if (!event.defaultPrevented) {
              const { x, y } = event.detail.delta;
              const target = event.currentTarget;
              target.setAttribute("data-swipe", "end");
              target.style.removeProperty("--reka-toast-swipe-move-x");
              target.style.removeProperty("--reka-toast-swipe-move-y");
              target.style.setProperty("--reka-toast-swipe-end-x", `${x}px`);
              target.style.setProperty("--reka-toast-swipe-end-y", `${y}px`);
              open.value = false;
            }
          })
        }), {
          default: withCtx(({ remaining, duration: _duration }) => [renderSlot(_ctx.$slots, "default", {
            remaining,
            duration: _duration,
            open: unref(open)
          })]),
          _: 3
        }, 16, [
          "open",
          "type",
          "as",
          "as-child",
          "duration"
        ])]),
        _: 3
      }, 8, ["present"]);
    };
  }
});
var ToastRoot_default = ToastRoot_vue_vue_type_script_setup_true_lang_default;
var ToastTitle_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  __name: "ToastTitle",
  props: {
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false
    }
  },
  setup(__props) {
    const props = __props;
    useForwardExpose();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(props)), {
        default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
        _: 3
      }, 16);
    };
  }
});
var ToastTitle_default = ToastTitle_vue_vue_type_script_setup_true_lang_default;
var FocusProxy_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  __name: "FocusProxy",
  emits: ["focusFromOutsideViewport"],
  setup(__props, { emit: __emit }) {
    const emits = __emit;
    const providerContext = injectToastProviderContext();
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(VisuallyHidden_default), {
        "aria-hidden": "true",
        tabindex: "0",
        style: { "position": "fixed" },
        onFocus: _cache[0] || (_cache[0] = (event) => {
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !unref(providerContext).viewport.value?.contains(prevFocusedElement);
          if (isFocusFromOutsideViewport) emits("focusFromOutsideViewport");
        })
      }, {
        default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
        _: 3
      });
    };
  }
});
var FocusProxy_default = FocusProxy_vue_vue_type_script_setup_true_lang_default;
var ToastViewport_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  inheritAttrs: false,
  __name: "ToastViewport",
  props: {
    hotkey: {
      type: Array,
      required: false,
      default: () => ["F8"]
    },
    label: {
      type: [String, Function],
      required: false,
      default: "Notifications ({hotkey})"
    },
    asChild: {
      type: Boolean,
      required: false
    },
    as: {
      type: null,
      required: false,
      default: "ol"
    }
  },
  setup(__props) {
    const props = __props;
    const { hotkey, label } = toRefs(props);
    const { forwardRef, currentElement } = useForwardExpose();
    const { CollectionSlot, getItems } = useCollection();
    const providerContext = injectToastProviderContext();
    const hasToasts = computed(() => providerContext.toastCount.value > 0);
    const headFocusProxyRef = ref();
    const tailFocusProxyRef = ref();
    const hotkeyMessage = computed(() => hotkey.value.join("+").replace(/Key/g, "").replace(/Digit/g, ""));
    onKeyStroke(hotkey.value, () => {
      currentElement.value.focus();
    });
    watchEffect((cleanupFn) => {
      const viewport = currentElement.value;
      if (hasToasts.value && viewport) {
        const handlePause = () => {
          if (!providerContext.isClosePausedRef.value) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            providerContext.isClosePausedRef.value = true;
          }
        };
        const handleResume = () => {
          if (providerContext.isClosePausedRef.value) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            providerContext.isClosePausedRef.value = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !viewport.contains(event.relatedTarget);
          if (isFocusMovingOutside) handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = viewport.contains(getActiveElement());
          if (!isFocusInside) handleResume();
        };
        const handleKeyDown = (event) => {
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = getActiveElement();
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              headFocusProxyRef.value?.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst(sortedCandidates.slice(index2 + 1))) event.preventDefault();
            else isTabbingBackwards ? headFocusProxyRef.value?.focus() : tailFocusProxyRef.value?.focus();
          }
        };
        viewport.addEventListener("focusin", handlePause);
        viewport.addEventListener("focusout", handleFocusOutResume);
        viewport.addEventListener("pointermove", handlePause);
        viewport.addEventListener("pointerleave", handlePointerLeaveResume);
        viewport.addEventListener("keydown", handleKeyDown);
        (void 0).addEventListener("blur", handlePause);
        (void 0).addEventListener("focus", handleResume);
        cleanupFn(() => {
          viewport.removeEventListener("focusin", handlePause);
          viewport.removeEventListener("focusout", handleFocusOutResume);
          viewport.removeEventListener("pointermove", handlePause);
          viewport.removeEventListener("pointerleave", handlePointerLeaveResume);
          viewport.removeEventListener("keydown", handleKeyDown);
          (void 0).removeEventListener("blur", handlePause);
          (void 0).removeEventListener("focus", handleResume);
        });
      }
    });
    function getSortedTabbableCandidates({ tabbingDirection }) {
      const toastItems = getItems().map((i) => i.ref);
      const tabbableCandidates = toastItems.map((toastNode) => {
        const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
        return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
      });
      return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
    }
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(DismissableLayerBranch_default), {
        role: "region",
        "aria-label": typeof unref(label) === "string" ? unref(label).replace("{hotkey}", hotkeyMessage.value) : unref(label)(hotkeyMessage.value),
        tabindex: "-1",
        style: normalizeStyle({ pointerEvents: hasToasts.value ? void 0 : "none" })
      }, {
        default: withCtx(() => [
          hasToasts.value ? (openBlock(), createBlock(FocusProxy_default, {
            key: 0,
            ref: (node) => {
              headFocusProxyRef.value = unref(unrefElement$1)(node);
              return void 0;
            },
            onFocusFromOutsideViewport: _cache[0] || (_cache[0] = () => {
              const tabbableCandidates = getSortedTabbableCandidates({ tabbingDirection: "forwards" });
              unref(focusFirst)(tabbableCandidates);
            })
          }, null, 512)) : createCommentVNode("v-if", true),
          createVNode(unref(CollectionSlot), null, {
            default: withCtx(() => [createVNode(unref(Primitive), mergeProps({
              ref: unref(forwardRef),
              tabindex: "-1",
              as: _ctx.as,
              "as-child": _ctx.asChild
            }, _ctx.$attrs), {
              default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
              _: 3
            }, 16, ["as", "as-child"])]),
            _: 3
          }),
          hasToasts.value ? (openBlock(), createBlock(FocusProxy_default, {
            key: 1,
            ref: (node) => {
              tailFocusProxyRef.value = unref(unrefElement$1)(node);
              return void 0;
            },
            onFocusFromOutsideViewport: _cache[1] || (_cache[1] = () => {
              const tabbableCandidates = getSortedTabbableCandidates({ tabbingDirection: "backwards" });
              unref(focusFirst)(tabbableCandidates);
            })
          }, null, 512)) : createCommentVNode("v-if", true)
        ]),
        _: 3
      }, 8, ["aria-label", "style"]);
    };
  }
});
var ToastViewport_default = ToastViewport_vue_vue_type_script_setup_true_lang_default;
const [injectTooltipProviderContext, provideTooltipProviderContext] = createContext$1("TooltipProvider");
var TooltipProvider_vue_vue_type_script_setup_true_lang_default = /* @__PURE__ */ defineComponent({
  inheritAttrs: false,
  __name: "TooltipProvider",
  props: {
    delayDuration: {
      type: Number,
      required: false,
      default: 700
    },
    skipDelayDuration: {
      type: Number,
      required: false,
      default: 300
    },
    disableHoverableContent: {
      type: Boolean,
      required: false,
      default: false
    },
    disableClosingTrigger: {
      type: Boolean,
      required: false
    },
    disabled: {
      type: Boolean,
      required: false
    },
    ignoreNonKeyboardFocus: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  setup(__props) {
    const props = __props;
    const { delayDuration, skipDelayDuration, disableHoverableContent, disableClosingTrigger, ignoreNonKeyboardFocus, disabled } = toRefs(props);
    useForwardExpose();
    const isOpenDelayed = ref(true);
    const isPointerInTransitRef = ref(false);
    const { start: startTimer, stop: clearTimer } = useTimeoutFn(() => {
      isOpenDelayed.value = true;
    }, skipDelayDuration, { immediate: false });
    provideTooltipProviderContext({
      isOpenDelayed,
      delayDuration,
      onOpen() {
        clearTimer();
        isOpenDelayed.value = false;
      },
      onClose() {
        startTimer();
      },
      isPointerInTransitRef,
      disableHoverableContent,
      disableClosingTrigger,
      disabled,
      ignoreNonKeyboardFocus
    });
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
});
var TooltipProvider_default = TooltipProvider_vue_vue_type_script_setup_true_lang_default;
function tryOnScopeDispose(fn, failSilently) {
  if (getCurrentScope()) {
    onScopeDispose(fn, failSilently);
    return true;
  }
  return false;
}
const localProvidedStateMap = /* @__PURE__ */ new WeakMap();
const injectLocal = /* @__NO_SIDE_EFFECTS__ */ (...args) => {
  var _getCurrentInstance;
  const key = args[0];
  const instance = (_getCurrentInstance = getCurrentInstance$1()) === null || _getCurrentInstance === void 0 ? void 0 : _getCurrentInstance.proxy;
  const owner2 = instance !== null && instance !== void 0 ? instance : getCurrentScope();
  if (owner2 == null && !hasInjectionContext()) throw new Error("injectLocal must be called in setup");
  if (owner2 && localProvidedStateMap.has(owner2) && key in localProvidedStateMap.get(owner2)) return localProvidedStateMap.get(owner2)[key];
  return inject(...args);
};
typeof WorkerGlobalScope !== "undefined" && globalThis instanceof WorkerGlobalScope;
const isDef = (val) => typeof val !== "undefined";
const notNullish = (val) => val != null;
const toString = Object.prototype.toString;
const isObject$1 = (val) => toString.call(val) === "[object Object]";
const noop$1 = () => {
};
function toRef(...args) {
  if (args.length !== 1) return toRef$2(...args);
  const r = args[0];
  return typeof r === "function" ? readonly(customRef(() => ({
    get: r,
    set: noop$1
  }))) : ref(r);
}
function createFilterWrapper(filter2, fn) {
  function wrapper(...args) {
    return new Promise((resolve, reject) => {
      Promise.resolve(filter2(() => fn.apply(this, args), {
        fn,
        thisArg: this,
        args
      })).then(resolve).catch(reject);
    });
  }
  return wrapper;
}
const bypassFilter = (invoke$1) => {
  return invoke$1();
};
function debounceFilter(ms, options = {}) {
  let timer;
  let maxTimer;
  let lastRejector = noop$1;
  const _clearTimeout = (timer$1) => {
    clearTimeout(timer$1);
    lastRejector();
    lastRejector = noop$1;
  };
  let lastInvoker;
  const filter2 = (invoke$1) => {
    const duration2 = toValue(ms);
    const maxDuration = toValue(options.maxWait);
    if (timer) _clearTimeout(timer);
    if (duration2 <= 0 || maxDuration !== void 0 && maxDuration <= 0) {
      if (maxTimer) {
        _clearTimeout(maxTimer);
        maxTimer = void 0;
      }
      return Promise.resolve(invoke$1());
    }
    return new Promise((resolve, reject) => {
      lastRejector = options.rejectOnCancel ? reject : resolve;
      lastInvoker = invoke$1;
      if (maxDuration && !maxTimer) maxTimer = setTimeout(() => {
        if (timer) _clearTimeout(timer);
        maxTimer = void 0;
        resolve(lastInvoker());
      }, maxDuration);
      timer = setTimeout(() => {
        if (maxTimer) _clearTimeout(maxTimer);
        maxTimer = void 0;
        resolve(invoke$1());
      }, duration2);
    });
  };
  return filter2;
}
function throttleFilter(...args) {
  let lastExec = 0;
  let timer;
  let isLeading = true;
  let lastRejector = noop$1;
  let lastValue;
  let ms;
  let trailing;
  let leading;
  let rejectOnCancel;
  if (!isRef(args[0]) && typeof args[0] === "object") ({ delay: ms, trailing = true, leading = true, rejectOnCancel = false } = args[0]);
  else [ms, trailing = true, leading = true, rejectOnCancel = false] = args;
  const clear = () => {
    if (timer) {
      clearTimeout(timer);
      timer = void 0;
      lastRejector();
      lastRejector = noop$1;
    }
  };
  const filter2 = (_invoke) => {
    const duration2 = toValue(ms);
    const elapsed = Date.now() - lastExec;
    const invoke$1 = () => {
      return lastValue = _invoke();
    };
    clear();
    if (duration2 <= 0) {
      lastExec = Date.now();
      return invoke$1();
    }
    if (elapsed > duration2) {
      lastExec = Date.now();
      if (leading || !isLeading) invoke$1();
    } else if (trailing) lastValue = new Promise((resolve, reject) => {
      lastRejector = rejectOnCancel ? reject : resolve;
      timer = setTimeout(() => {
        lastExec = Date.now();
        isLeading = true;
        resolve(invoke$1());
        clear();
      }, Math.max(0, duration2 - elapsed));
    });
    if (!leading && !timer) timer = setTimeout(() => isLeading = true, duration2);
    isLeading = false;
    return lastValue;
  };
  return filter2;
}
function pausableFilter(extendFilter = bypassFilter, options = {}) {
  const { initialState = "active" } = options;
  const isActive = toRef(initialState === "active");
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value) extendFilter(...args);
  };
  return {
    isActive: readonly(isActive),
    pause,
    resume,
    eventFilter
  };
}
function pxValue(px2) {
  return px2.endsWith("rem") ? Number.parseFloat(px2) * 16 : Number.parseFloat(px2);
}
function toArray(value) {
  return Array.isArray(value) ? value : [value];
}
function cacheStringFunction(fn) {
  const cache2 = /* @__PURE__ */ Object.create(null);
  return ((str) => {
    return cache2[str] || (cache2[str] = fn(str));
  });
}
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
function getLifeCycleTarget(target) {
  return getCurrentInstance$1();
}
// @__NO_SIDE_EFFECTS__
function createSharedComposable(composable) {
  return composable;
}
// @__NO_SIDE_EFFECTS__
function makeDestructurable(obj, arr) {
  if (typeof Symbol !== "undefined") {
    const clone = { ...obj };
    Object.defineProperty(clone, Symbol.iterator, {
      enumerable: false,
      value() {
        let index2 = 0;
        return { next: () => ({
          value: arr[index2++],
          done: index2 > arr.length
        }) };
      }
    });
    return clone;
  } else return Object.assign([...arr], obj);
}
function toReactive(objectRef) {
  if (!isRef(objectRef)) return reactive(objectRef);
  return reactive(new Proxy({}, {
    get(_2, p, receiver) {
      return unref(Reflect.get(objectRef.value, p, receiver));
    },
    set(_2, p, value) {
      if (isRef(objectRef.value[p]) && !isRef(value)) objectRef.value[p].value = value;
      else objectRef.value[p] = value;
      return true;
    },
    deleteProperty(_2, p) {
      return Reflect.deleteProperty(objectRef.value, p);
    },
    has(_2, p) {
      return Reflect.has(objectRef.value, p);
    },
    ownKeys() {
      return Object.keys(objectRef.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: true,
        configurable: true
      };
    }
  }));
}
function reactiveComputed(fn) {
  return toReactive(computed(fn));
}
function reactiveOmit(obj, ...keys) {
  const flatKeys = keys.flat();
  const predicate = flatKeys[0];
  return reactiveComputed(() => typeof predicate === "function" ? Object.fromEntries(Object.entries(toRefs(obj)).filter(([k2, v]) => !predicate(toValue(v), k2))) : Object.fromEntries(Object.entries(toRefs(obj)).filter((e) => !flatKeys.includes(e[0]))));
}
function reactivePick(obj, ...keys) {
  const flatKeys = keys.flat();
  const predicate = flatKeys[0];
  return reactiveComputed(() => typeof predicate === "function" ? Object.fromEntries(Object.entries(toRefs(obj)).filter(([k2, v]) => predicate(toValue(v), k2))) : Object.fromEntries(flatKeys.map((k2) => [k2, toRef(obj, k2)])));
}
// @__NO_SIDE_EFFECTS__
function useDebounceFn(fn, ms = 200, options = {}) {
  return createFilterWrapper(debounceFilter(ms, options), fn);
}
// @__NO_SIDE_EFFECTS__
function useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {
  return createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn);
}
function watchWithFilter(source, cb, options = {}) {
  const { eventFilter = bypassFilter, ...watchOptions } = options;
  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
function watchPausable(source, cb, options = {}) {
  const { eventFilter: filter2, initialState = "active", ...watchOptions } = options;
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter2, { initialState });
  return {
    stop: watchWithFilter(source, cb, {
      ...watchOptions,
      eventFilter
    }),
    pause,
    resume,
    isActive
  };
}
const pausableWatch = watchPausable;
function tryOnMounted(fn, sync = true, target) {
  if (getLifeCycleTarget()) ;
  else if (sync) fn();
  else nextTick(fn);
}
function watchImmediate(source, cb, options) {
  return watch(source, cb, {
    ...options,
    immediate: true
  });
}
// @__NO_SIDE_EFFECTS__
function createReusableTemplate(options = {}) {
  const { inheritAttrs = true } = options;
  const render2 = shallowRef();
  const define = defineComponent({ setup(_2, { slots }) {
    return () => {
      render2.value = slots.default;
    };
  } });
  const reuse = defineComponent({
    inheritAttrs,
    props: options.props,
    setup(props, { attrs, slots }) {
      return () => {
        var _render$value;
        if (!render2.value && true) throw new Error("[VueUse] Failed to find the definition of reusable template");
        const vnode = (_render$value = render2.value) === null || _render$value === void 0 ? void 0 : _render$value.call(render2, {
          ...options.props == null ? keysToCamelKebabCase(attrs) : props,
          $slots: slots
        });
        return inheritAttrs && (vnode === null || vnode === void 0 ? void 0 : vnode.length) === 1 ? vnode[0] : vnode;
      };
    }
  });
  return /* @__PURE__ */ makeDestructurable({
    define,
    reuse
  }, [define, reuse]);
}
function keysToCamelKebabCase(obj) {
  const newObj = {};
  for (const key in obj) newObj[camelize(key)] = obj[key];
  return newObj;
}
const defaultWindow = void 0;
function unrefElement(elRef) {
  var _$el;
  const plain = toValue(elRef);
  return (_$el = plain === null || plain === void 0 ? void 0 : plain.$el) !== null && _$el !== void 0 ? _$el : plain;
}
function useEventListener(...args) {
  const register = (el, event, listener, options) => {
    el.addEventListener(event, listener, options);
    return () => el.removeEventListener(event, listener, options);
  };
  const firstParamTargets = computed(() => {
    const test2 = toArray(toValue(args[0])).filter((e) => e != null);
    return test2.every((e) => typeof e !== "string") ? test2 : void 0;
  });
  return watchImmediate(() => {
    var _firstParamTargets$va, _firstParamTargets$va2;
    return [
      (_firstParamTargets$va = (_firstParamTargets$va2 = firstParamTargets.value) === null || _firstParamTargets$va2 === void 0 ? void 0 : _firstParamTargets$va2.map((e) => unrefElement(e))) !== null && _firstParamTargets$va !== void 0 ? _firstParamTargets$va : [defaultWindow].filter((e) => e != null),
      toArray(toValue(firstParamTargets.value ? args[1] : args[0])),
      toArray(unref(firstParamTargets.value ? args[2] : args[1])),
      toValue(firstParamTargets.value ? args[3] : args[2])
    ];
  }, ([raw_targets, raw_events, raw_listeners, raw_options], _2, onCleanup) => {
    if (!(raw_targets === null || raw_targets === void 0 ? void 0 : raw_targets.length) || !(raw_events === null || raw_events === void 0 ? void 0 : raw_events.length) || !(raw_listeners === null || raw_listeners === void 0 ? void 0 : raw_listeners.length)) return;
    const optionsClone = isObject$1(raw_options) ? { ...raw_options } : raw_options;
    const cleanups = raw_targets.flatMap((el) => raw_events.flatMap((event) => raw_listeners.map((listener) => register(el, event, listener, optionsClone))));
    onCleanup(() => {
      cleanups.forEach((fn) => fn());
    });
  }, { flush: "post" });
}
function onClickOutside(target, handler, options = {}) {
  const { window: window$1 = defaultWindow, ignore = [], capture = true, detectIframe = false, controls = false } = options;
  if (!window$1) return controls ? {
    stop: noop$1,
    cancel: noop$1,
    trigger: noop$1
  } : noop$1;
  let shouldListen = true;
  const shouldIgnore = (event) => {
    return toValue(ignore).some((target$1) => {
      if (typeof target$1 === "string") return Array.from(window$1.document.querySelectorAll(target$1)).some((el) => el === event.target || event.composedPath().includes(el));
      else {
        const el = unrefElement(target$1);
        return el && (event.target === el || event.composedPath().includes(el));
      }
    });
  };
  function hasMultipleRoots(target$1) {
    const vm = toValue(target$1);
    return vm && vm.$.subTree.shapeFlag === 16;
  }
  function checkMultipleRoots(target$1, event) {
    const vm = toValue(target$1);
    const children = vm.$.subTree && vm.$.subTree.children;
    if (children == null || !Array.isArray(children)) return false;
    return children.some((child) => child.el === event.target || event.composedPath().includes(child.el));
  }
  const listener = (event) => {
    const el = unrefElement(target);
    if (event.target == null) return;
    if (!(el instanceof Element) && hasMultipleRoots(target) && checkMultipleRoots(target, event)) return;
    if (!el || el === event.target || event.composedPath().includes(el)) return;
    if ("detail" in event && event.detail === 0) shouldListen = !shouldIgnore(event);
    if (!shouldListen) {
      shouldListen = true;
      return;
    }
    handler(event);
  };
  let isProcessingClick = false;
  const cleanup = [
    useEventListener(window$1, "click", (event) => {
      if (!isProcessingClick) {
        isProcessingClick = true;
        setTimeout(() => {
          isProcessingClick = false;
        }, 0);
        listener(event);
      }
    }, {
      passive: true,
      capture
    }),
    useEventListener(window$1, "pointerdown", (e) => {
      const el = unrefElement(target);
      shouldListen = !shouldIgnore(e) && !!(el && !e.composedPath().includes(el));
    }, { passive: true }),
    detectIframe && useEventListener(window$1, "blur", (event) => {
      setTimeout(() => {
        var _window$document$acti;
        const el = unrefElement(target);
        if (((_window$document$acti = window$1.document.activeElement) === null || _window$document$acti === void 0 ? void 0 : _window$document$acti.tagName) === "IFRAME" && !(el === null || el === void 0 ? void 0 : el.contains(window$1.document.activeElement))) handler(event);
      }, 0);
    }, { passive: true })
  ].filter(Boolean);
  const stop = () => cleanup.forEach((fn) => fn());
  if (controls) return {
    stop,
    cancel: () => {
      shouldListen = false;
    },
    trigger: (event) => {
      shouldListen = true;
      listener(event);
      shouldListen = false;
    }
  };
  return stop;
}
// @__NO_SIDE_EFFECTS__
function useMounted() {
  const isMounted = shallowRef(false);
  getCurrentInstance$1();
  return isMounted;
}
// @__NO_SIDE_EFFECTS__
function useSupported(callback) {
  const isMounted = /* @__PURE__ */ useMounted();
  return computed(() => {
    isMounted.value;
    return Boolean(callback());
  });
}
function useMutationObserver(target, callback, options = {}) {
  const { window: window$1 = defaultWindow, ...mutationOptions } = options;
  let observer;
  const isSupported = /* @__PURE__ */ useSupported(() => window$1 && "MutationObserver" in window$1);
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(computed(() => {
    const items = toArray(toValue(target)).map(unrefElement).filter(notNullish);
    return new Set(items);
  }), (newTargets) => {
    cleanup();
    if (isSupported.value && newTargets.size) {
      observer = new MutationObserver(callback);
      newTargets.forEach((el) => observer.observe(el, mutationOptions));
    }
  }, {
    immediate: true,
    flush: "post"
  });
  const takeRecords = () => {
    return observer === null || observer === void 0 ? void 0 : observer.takeRecords();
  };
  const stop = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    stop,
    takeRecords
  };
}
function onElementRemoval(target, callback, options = {}) {
  const { window: window$1 = defaultWindow, document: document$1 = window$1 === null || window$1 === void 0 ? void 0 : window$1.document, flush = "sync" } = options;
  if (!window$1 || !document$1) return noop$1;
  let stopFn;
  const cleanupAndUpdate = (fn) => {
    stopFn === null || stopFn === void 0 || stopFn();
    stopFn = fn;
  };
  const stopWatch = watchEffect(() => {
    const el = unrefElement(target);
    if (el) {
      const { stop } = useMutationObserver(document$1, (mutationsList) => {
        if (mutationsList.map((mutation) => [...mutation.removedNodes]).flat().some((node) => node === el || node.contains(el))) callback(mutationsList);
      }, {
        window: window$1,
        childList: true,
        subtree: true
      });
      cleanupAndUpdate(stop);
    }
  }, { flush });
  const stopHandle = () => {
    stopWatch();
    cleanupAndUpdate();
  };
  tryOnScopeDispose(stopHandle);
  return stopHandle;
}
// @__NO_SIDE_EFFECTS__
function useActiveElement(options = {}) {
  var _options$document;
  const { window: window$1 = defaultWindow, deep = true, triggerOnRemoval = false } = options;
  const document$1 = (_options$document = options.document) !== null && _options$document !== void 0 ? _options$document : window$1 === null || window$1 === void 0 ? void 0 : window$1.document;
  const getDeepActiveElement = () => {
    let element = document$1 === null || document$1 === void 0 ? void 0 : document$1.activeElement;
    if (deep) {
      var _element$shadowRoot;
      while (element === null || element === void 0 ? void 0 : element.shadowRoot) element = element === null || element === void 0 || (_element$shadowRoot = element.shadowRoot) === null || _element$shadowRoot === void 0 ? void 0 : _element$shadowRoot.activeElement;
    }
    return element;
  };
  const activeElement = shallowRef();
  const trigger = () => {
    activeElement.value = getDeepActiveElement();
  };
  if (window$1) {
    const listenerOptions = {
      capture: true,
      passive: true
    };
    useEventListener(window$1, "blur", (event) => {
      if (event.relatedTarget !== null) return;
      trigger();
    }, listenerOptions);
    useEventListener(window$1, "focus", trigger, listenerOptions);
  }
  if (triggerOnRemoval) onElementRemoval(activeElement, trigger, { document: document$1 });
  trigger();
  return activeElement;
}
const ssrWidthSymbol = /* @__PURE__ */ Symbol("vueuse-ssr-width");
// @__NO_SIDE_EFFECTS__
function useSSRWidth() {
  const ssrWidth = hasInjectionContext() ? /* @__PURE__ */ injectLocal(ssrWidthSymbol, null) : null;
  return typeof ssrWidth === "number" ? ssrWidth : void 0;
}
function useMediaQuery(query, options = {}) {
  const { window: window$1 = defaultWindow, ssrWidth = /* @__PURE__ */ useSSRWidth() } = options;
  const isSupported = /* @__PURE__ */ useSupported(() => window$1 && "matchMedia" in window$1 && typeof window$1.matchMedia === "function");
  const ssrSupport = shallowRef(typeof ssrWidth === "number");
  const mediaQuery = shallowRef();
  const matches = shallowRef(false);
  const handler = (event) => {
    matches.value = event.matches;
  };
  watchEffect(() => {
    if (ssrSupport.value) {
      ssrSupport.value = !isSupported.value;
      matches.value = toValue(query).split(",").some((queryString) => {
        const not = queryString.includes("not all");
        const minWidth = queryString.match(/\(\s*min-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        const maxWidth = queryString.match(/\(\s*max-width:\s*(-?\d+(?:\.\d*)?[a-z]+\s*)\)/);
        let res = Boolean(minWidth || maxWidth);
        if (minWidth && res) res = ssrWidth >= pxValue(minWidth[1]);
        if (maxWidth && res) res = ssrWidth <= pxValue(maxWidth[1]);
        return not ? !res : res;
      });
      return;
    }
    if (!isSupported.value) return;
    mediaQuery.value = window$1.matchMedia(toValue(query));
    matches.value = mediaQuery.value.matches;
  });
  useEventListener(mediaQuery, "change", handler, { passive: true });
  return computed(() => matches.value);
}
function cloneFnJSON(source) {
  return JSON.parse(JSON.stringify(source));
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
const handlers = /* @__PURE__ */ getHandlers();
function getHandlers() {
  if (!(globalKey in _global)) _global[globalKey] = _global[globalKey] || {};
  return _global[globalKey];
}
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
  boolean: {
    read: (v) => v === "true",
    write: (v) => String(v)
  },
  object: {
    read: (v) => JSON.parse(v),
    write: (v) => JSON.stringify(v)
  },
  number: {
    read: (v) => Number.parseFloat(v),
    write: (v) => String(v)
  },
  any: {
    read: (v) => v,
    write: (v) => String(v)
  },
  string: {
    read: (v) => v,
    write: (v) => String(v)
  },
  map: {
    read: (v) => new Map(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v.entries()))
  },
  set: {
    read: (v) => new Set(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v))
  },
  date: {
    read: (v) => new Date(v),
    write: (v) => v.toISOString()
  }
};
const customStorageEventName = "vueuse-storage";
function useStorage(key, defaults$1, storage2, options = {}) {
  var _options$serializer;
  const { flush = "pre", deep = true, listenToStorageChanges = true, writeDefaults = true, mergeDefaults = false, shallow, window: window$1 = defaultWindow, eventFilter, onError = (e) => {
    console.error(e);
  }, initOnMounted } = options;
  const data = (shallow ? shallowRef : ref)(typeof defaults$1 === "function" ? defaults$1() : defaults$1);
  const keyComputed = computed(() => toValue(key));
  if (!storage2) try {
    storage2 = getSSRHandler("getDefaultStorage", () => defaultWindow === null || defaultWindow === void 0 ? void 0 : defaultWindow.localStorage)();
  } catch (e) {
    onError(e);
  }
  if (!storage2) return data;
  const rawInit = toValue(defaults$1);
  const type = guessSerializerType(rawInit);
  const serializer = (_options$serializer = options.serializer) !== null && _options$serializer !== void 0 ? _options$serializer : StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(data, (newValue) => write(newValue), {
    flush,
    deep,
    eventFilter
  });
  watch(keyComputed, () => update(), { flush });
  let firstMounted = false;
  const onStorageEvent = (ev) => {
    if (initOnMounted && !firstMounted) return;
    update(ev);
  };
  const onStorageCustomEvent = (ev) => {
    if (initOnMounted && !firstMounted) return;
    updateFromCustomEvent(ev);
  };
  if (window$1 && listenToStorageChanges) if (storage2 instanceof Storage) useEventListener(window$1, "storage", onStorageEvent, { passive: true });
  else useEventListener(window$1, customStorageEventName, onStorageCustomEvent);
  if (initOnMounted) tryOnMounted(() => {
    firstMounted = true;
    update();
  });
  else update();
  function dispatchWriteEvent(oldValue, newValue) {
    if (window$1) {
      const payload = {
        key: keyComputed.value,
        oldValue,
        newValue,
        storageArea: storage2
      };
      window$1.dispatchEvent(storage2 instanceof Storage ? new StorageEvent("storage", payload) : new CustomEvent(customStorageEventName, { detail: payload }));
    }
  }
  function write(v) {
    try {
      const oldValue = storage2.getItem(keyComputed.value);
      if (v == null) {
        dispatchWriteEvent(oldValue, null);
        storage2.removeItem(keyComputed.value);
      } else {
        const serialized = serializer.write(v);
        if (oldValue !== serialized) {
          storage2.setItem(keyComputed.value, serialized);
          dispatchWriteEvent(oldValue, serialized);
        }
      }
    } catch (e) {
      onError(e);
    }
  }
  function read(event) {
    const rawValue = event ? event.newValue : storage2.getItem(keyComputed.value);
    if (rawValue == null) {
      if (writeDefaults && rawInit != null) storage2.setItem(keyComputed.value, serializer.write(rawInit));
      return rawInit;
    } else if (!event && mergeDefaults) {
      const value = serializer.read(rawValue);
      if (typeof mergeDefaults === "function") return mergeDefaults(value, rawInit);
      else if (type === "object" && !Array.isArray(value)) return {
        ...rawInit,
        ...value
      };
      return value;
    } else if (typeof rawValue !== "string") return rawValue;
    else return serializer.read(rawValue);
  }
  function update(event) {
    if (event && event.storageArea !== storage2) return;
    if (event && event.key == null) {
      data.value = rawInit;
      return;
    }
    if (event && event.key !== keyComputed.value) return;
    pauseWatch();
    try {
      const serializedData = serializer.write(data.value);
      if (event === void 0 || (event === null || event === void 0 ? void 0 : event.newValue) !== serializedData) data.value = read(event);
    } catch (e) {
      onError(e);
    } finally {
      if (event) nextTick(resumeWatch);
      else resumeWatch();
    }
  }
  function updateFromCustomEvent(event) {
    update(event.detail);
  }
  return data;
}
function useIntersectionObserver(target, callback, options = {}) {
  const { root, rootMargin = "0px", threshold = 0, window: window$1 = defaultWindow, immediate = true } = options;
  const isSupported = /* @__PURE__ */ useSupported(() => window$1 && "IntersectionObserver" in window$1);
  const targets = computed(() => {
    return toArray(toValue(target)).map(unrefElement).filter(notNullish);
  });
  let cleanup = noop$1;
  const isActive = shallowRef(immediate);
  const stopWatch = isSupported.value ? watch(() => [
    targets.value,
    unrefElement(root),
    isActive.value
  ], ([targets$1, root$1]) => {
    cleanup();
    if (!isActive.value) return;
    if (!targets$1.length) return;
    const observer = new IntersectionObserver(callback, {
      root: unrefElement(root$1),
      rootMargin,
      threshold
    });
    targets$1.forEach((el) => el && observer.observe(el));
    cleanup = () => {
      observer.disconnect();
      cleanup = noop$1;
    };
  }, {
    immediate,
    flush: "post"
  }) : noop$1;
  const stop = () => {
    cleanup();
    stopWatch();
    isActive.value = false;
  };
  tryOnScopeDispose(stop);
  return {
    isSupported,
    isActive,
    pause() {
      cleanup();
      isActive.value = false;
    },
    resume() {
      isActive.value = true;
    },
    stop
  };
}
const events = /* @__PURE__ */ new Map();
// @__NO_SIDE_EFFECTS__
function useEventBus(key) {
  const scope = getCurrentScope();
  function on(listener) {
    var _scope$cleanups;
    const listeners = events.get(key) || /* @__PURE__ */ new Set();
    listeners.add(listener);
    events.set(key, listeners);
    const _off = () => off(listener);
    scope === null || scope === void 0 || (_scope$cleanups = scope.cleanups) === null || _scope$cleanups === void 0 || _scope$cleanups.push(_off);
    return _off;
  }
  function once(listener) {
    function _listener(...args) {
      off(_listener);
      listener(...args);
    }
    return on(_listener);
  }
  function off(listener) {
    const listeners = events.get(key);
    if (!listeners) return;
    listeners.delete(listener);
    if (!listeners.size) reset();
  }
  function reset() {
    events.delete(key);
  }
  function emit(event, payload) {
    var _events$get;
    (_events$get = events.get(key)) === null || _events$get === void 0 || _events$get.forEach((v) => v(event, payload));
  }
  return {
    on,
    once,
    off,
    emit,
    reset
  };
}
function useLocalStorage(key, initialValue, options = {}) {
  const { window: window$1 = defaultWindow } = options;
  return useStorage(key, initialValue, window$1 === null || window$1 === void 0 ? void 0 : window$1.localStorage, options);
}
// @__NO_SIDE_EFFECTS__
function useVModel(props, key, emit, options = {}) {
  var _vm$$emit, _vm$proxy;
  const { clone = false, passive = false, eventName, deep = false, defaultValue, shouldEmit } = options;
  const vm = getCurrentInstance$1();
  const _emit = emit || (vm === null || vm === void 0 ? void 0 : vm.emit) || (vm === null || vm === void 0 || (_vm$$emit = vm.$emit) === null || _vm$$emit === void 0 ? void 0 : _vm$$emit.bind(vm)) || (vm === null || vm === void 0 || (_vm$proxy = vm.proxy) === null || _vm$proxy === void 0 || (_vm$proxy = _vm$proxy.$emit) === null || _vm$proxy === void 0 ? void 0 : _vm$proxy.bind(vm === null || vm === void 0 ? void 0 : vm.proxy));
  let event = eventName;
  event = event || `update:${key.toString()}`;
  const cloneFn = (val) => !clone ? val : typeof clone === "function" ? clone(val) : cloneFnJSON(val);
  const getValue$1 = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;
  const triggerEmit = (value) => {
    if (shouldEmit) {
      if (shouldEmit(value)) _emit(event, value);
    } else _emit(event, value);
  };
  if (passive) {
    const proxy = ref(getValue$1());
    let isUpdating = false;
    watch(() => props[key], (v) => {
      if (!isUpdating) {
        isUpdating = true;
        proxy.value = cloneFn(v);
        nextTick(() => isUpdating = false);
      }
    });
    watch(proxy, (v) => {
      if (!isUpdating && (v !== props[key] || deep)) triggerEmit(v);
    }, { deep });
    return proxy;
  } else return computed({
    get() {
      return getValue$1();
    },
    set(value) {
      triggerEmit(value);
    }
  });
}
function serialize(o) {
  return typeof o == "string" ? `'${o}'` : new c().serialize(o);
}
const c = /* @__PURE__ */ (function() {
  class o {
    #t = /* @__PURE__ */ new Map();
    compare(t, r) {
      const e = typeof t, n = typeof r;
      return e === "string" && n === "string" ? t.localeCompare(r) : e === "number" && n === "number" ? t - r : String.prototype.localeCompare.call(this.serialize(t, true), this.serialize(r, true));
    }
    serialize(t, r) {
      if (t === null) return "null";
      switch (typeof t) {
        case "string":
          return r ? t : `'${t}'`;
        case "bigint":
          return `${t}n`;
        case "object":
          return this.$object(t);
        case "function":
          return this.$function(t);
      }
      return String(t);
    }
    serializeObject(t) {
      const r = Object.prototype.toString.call(t);
      if (r !== "[object Object]") return this.serializeBuiltInType(r.length < 10 ? `unknown:${r}` : r.slice(8, -1), t);
      const e = t.constructor, n = e === Object || e === void 0 ? "" : e.name;
      if (n !== "" && globalThis[n] === e) return this.serializeBuiltInType(n, t);
      if (typeof t.toJSON == "function") {
        const i = t.toJSON();
        return n + (i !== null && typeof i == "object" ? this.$object(i) : `(${this.serialize(i)})`);
      }
      return this.serializeObjectEntries(n, Object.entries(t));
    }
    serializeBuiltInType(t, r) {
      const e = this["$" + t];
      if (e) return e.call(this, r);
      if (typeof r?.entries == "function") return this.serializeObjectEntries(t, r.entries());
      throw new Error(`Cannot serialize ${t}`);
    }
    serializeObjectEntries(t, r) {
      const e = Array.from(r).sort((i, a) => this.compare(i[0], a[0]));
      let n = `${t}{`;
      for (let i = 0; i < e.length; i++) {
        const [a, l] = e[i];
        n += `${this.serialize(a, true)}:${this.serialize(l)}`, i < e.length - 1 && (n += ",");
      }
      return n + "}";
    }
    $object(t) {
      let r = this.#t.get(t);
      return r === void 0 && (this.#t.set(t, `#${this.#t.size}`), r = this.serializeObject(t), this.#t.set(t, r)), r;
    }
    $function(t) {
      const r = Function.prototype.toString.call(t);
      return r.slice(-15) === "[native code] }" ? `${t.name || ""}()[native]` : `${t.name}(${t.length})${r.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(t) {
      let r = "[";
      for (let e = 0; e < t.length; e++) r += this.serialize(t[e]), e < t.length - 1 && (r += ",");
      return r + "]";
    }
    $Date(t) {
      try {
        return `Date(${t.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(t) {
      return `ArrayBuffer[${new Uint8Array(t).join(",")}]`;
    }
    $Set(t) {
      return `Set${this.$Array(Array.from(t).sort((r, e) => this.compare(r, e)))}`;
    }
    $Map(t) {
      return this.serializeObjectEntries("Map", t.entries());
    }
  }
  for (const s of ["Error", "RegExp", "URL"]) o.prototype["$" + s] = function(t) {
    return `${s}(${t})`;
  };
  for (const s of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) o.prototype["$" + s] = function(t) {
    return `${s}[${t.join(",")}]`;
  };
  for (const s of ["BigInt64Array", "BigUint64Array"]) o.prototype["$" + s] = function(t) {
    return `${s}[${t.join("n,")}${t.length > 0 ? "n" : ""}]`;
  };
  return o;
})();
function isEqual$1(object1, object2) {
  if (object1 === object2) {
    return true;
  }
  if (serialize(object1) === serialize(object2)) {
    return true;
  }
  return false;
}
function diff(obj1, obj2) {
  const h1 = _toHashedObject(obj1);
  const h2 = _toHashedObject(obj2);
  return _diff(h1, h2);
}
function _diff(h1, h2) {
  const diffs = [];
  const allProps = /* @__PURE__ */ new Set([
    ...Object.keys(h1.props || {}),
    ...Object.keys(h2.props || {})
  ]);
  if (h1.props && h2.props) {
    for (const prop of allProps) {
      const p1 = h1.props[prop];
      const p2 = h2.props[prop];
      if (p1 && p2) {
        diffs.push(..._diff(h1.props?.[prop], h2.props?.[prop]));
      } else if (p1 || p2) {
        diffs.push(
          new DiffEntry((p2 || p1).key, p1 ? "removed" : "added", p2, p1)
        );
      }
    }
  }
  if (allProps.size === 0 && h1.hash !== h2.hash) {
    diffs.push(new DiffEntry((h2 || h1).key, "changed", h2, h1));
  }
  return diffs;
}
function _toHashedObject(obj, key = "") {
  if (obj && typeof obj !== "object") {
    return new DiffHashedObject(key, obj, serialize(obj));
  }
  const props = {};
  const hashes = [];
  for (const _key in obj) {
    props[_key] = _toHashedObject(obj[_key], key ? `${key}.${_key}` : _key);
    hashes.push(props[_key].hash);
  }
  return new DiffHashedObject(key, obj, `{${hashes.join(":")}}`, props);
}
class DiffEntry {
  constructor(key, type, newValue, oldValue) {
    this.key = key;
    this.type = type;
    this.newValue = newValue;
    this.oldValue = oldValue;
  }
  toString() {
    return this.toJSON();
  }
  toJSON() {
    switch (this.type) {
      case "added": {
        return `Added   \`${this.key}\``;
      }
      case "removed": {
        return `Removed \`${this.key}\``;
      }
      case "changed": {
        return `Changed \`${this.key}\` from \`${this.oldValue?.toString() || "-"}\` to \`${this.newValue.toString()}\``;
      }
    }
  }
}
class DiffHashedObject {
  constructor(key, value, hash2, props) {
    this.key = key;
    this.value = value;
    this.hash = hash2;
    this.props = props;
  }
  toString() {
    if (this.props) {
      return `{${Object.keys(this.props).join(",")}}`;
    } else {
      return JSON.stringify(this.value);
    }
  }
  toJSON() {
    const k2 = this.key || ".";
    if (this.props) {
      return `${k2}({${Object.keys(this.props).join(",")}})`;
    }
    return `${k2}(${this.value})`;
  }
}
function omit(data, keys) {
  const result = { ...data };
  for (const key of keys) {
    delete result[key];
  }
  return result;
}
function get(object, path, defaultValue) {
  if (typeof path === "string") {
    path = path.split(".").map((key) => {
      const numKey = Number(key);
      return Number.isNaN(numKey) ? key : numKey;
    });
  }
  let result = object;
  for (const key of path) {
    if (result === void 0 || result === null) {
      return defaultValue;
    }
    result = result[key];
  }
  return result !== void 0 ? result : defaultValue;
}
function looseToNumber(val) {
  const n = Number.parseFloat(val);
  return Number.isNaN(n) ? val : n;
}
function compare(value, currentValue, comparator) {
  if (value === void 0 || currentValue === void 0) {
    return false;
  }
  if (typeof value === "string") {
    return value === currentValue;
  }
  if (typeof comparator === "function") {
    return comparator(value, currentValue);
  }
  if (typeof comparator === "string") {
    return get(value, comparator) === get(currentValue, comparator);
  }
  return isEqual$1(value, currentValue);
}
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (typeof value === "boolean" || typeof value === "number") {
    return false;
  }
  if (typeof value === "string") {
    return value.trim().length === 0;
  }
  if (Array.isArray(value)) {
    return value.length === 0;
  }
  if (value instanceof Map || value instanceof Set) {
    return value.size === 0;
  }
  if (value instanceof Date || value instanceof RegExp || typeof value === "function") {
    return false;
  }
  if (typeof value === "object") {
    for (const _2 in value) {
      if (Object.prototype.hasOwnProperty.call(value, _2)) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function getDisplayValue(items, value, options = {}) {
  const { valueKey, labelKey } = options;
  const foundItem = items.find((item) => {
    const itemValue = typeof item === "object" && item !== null && valueKey ? get(item, valueKey) : item;
    return compare(itemValue, value);
  });
  if (isEmpty(value) && foundItem) {
    return labelKey ? get(foundItem, labelKey) : void 0;
  }
  if (isEmpty(value)) {
    return void 0;
  }
  const source = foundItem ?? value;
  if (source === null || source === void 0) {
    return void 0;
  }
  if (typeof source === "object") {
    return labelKey ? get(source, labelKey) : void 0;
  }
  return String(source);
}
function isArrayOfArray(item) {
  return Array.isArray(item[0]);
}
function mergeClasses(appConfigClass, propClass) {
  if (!appConfigClass && !propClass) {
    return "";
  }
  return [
    ...Array.isArray(appConfigClass) ? appConfigClass : [appConfigClass],
    propClass
  ].filter(Boolean);
}
function buildTranslator(locale) {
  return (path, option) => translate(path, option, unref(locale));
}
function translate(path, option, locale) {
  const prop = get(locale, `messages.${path}`, path);
  return prop.replace(
    /\{(\w+)\}/g,
    (_2, key) => `${option?.[key] ?? `{${key}}`}`
  );
}
function buildLocaleContext(locale) {
  const lang = computed(() => unref(locale).name);
  const code = computed(() => unref(locale).code);
  const dir = computed(() => unref(locale).dir);
  const localeRef = isRef(locale) ? locale : ref(locale);
  return {
    lang,
    code,
    dir,
    locale: localeRef,
    t: buildTranslator(locale)
  };
}
// @__NO_SIDE_EFFECTS__
function defineLocale(options) {
  return defu(options, { dir: "ltr" });
}
const en = /* @__PURE__ */ defineLocale({
  name: "English",
  code: "en",
  messages: {
    alert: {
      close: "Close"
    },
    authForm: {
      hidePassword: "Hide password",
      showPassword: "Show password",
      submit: "Continue"
    },
    banner: {
      close: "Close"
    },
    calendar: {
      nextMonth: "Next month",
      nextYear: "Next year",
      prevMonth: "Previous month",
      prevYear: "Previous year"
    },
    carousel: {
      dots: "Choose slide to display",
      goto: "Go to slide {slide}",
      next: "Next",
      prev: "Prev"
    },
    chatPrompt: {
      placeholder: "Type your message here…"
    },
    chatPromptSubmit: {
      label: "Send prompt"
    },
    colorMode: {
      dark: "Dark",
      light: "Light",
      switchToDark: "Switch to dark mode",
      switchToLight: "Switch to light mode",
      system: "System"
    },
    commandPalette: {
      back: "Back",
      close: "Close",
      noData: "No data",
      noMatch: "No matching data",
      placeholder: "Type a command or search…"
    },
    contentSearch: {
      links: "Links",
      theme: "Theme"
    },
    contentSearchButton: {
      label: "Search…"
    },
    contentToc: {
      title: "On this page"
    },
    dashboardSearch: {
      theme: "Theme"
    },
    dashboardSearchButton: {
      label: "Search…"
    },
    dashboardSidebarCollapse: {
      collapse: "Collapse sidebar",
      expand: "Expand sidebar"
    },
    dashboardSidebarToggle: {
      close: "Close sidebar",
      open: "Open sidebar"
    },
    error: {
      clear: "Back to home"
    },
    fileUpload: {
      removeFile: "Remove {filename}"
    },
    header: {
      close: "Close menu",
      open: "Open menu"
    },
    inputMenu: {
      create: 'Create "{label}"',
      noData: "No data",
      noMatch: "No matching data"
    },
    inputNumber: {
      decrement: "Decrement",
      increment: "Increment"
    },
    modal: {
      close: "Close"
    },
    pricingTable: {
      caption: "Pricing plan comparison"
    },
    prose: {
      codeCollapse: {
        closeText: "Collapse",
        name: "code",
        openText: "Expand"
      },
      collapsible: {
        closeText: "Hide",
        name: "properties",
        openText: "Show"
      },
      pre: {
        copy: "Copy code to clipboard"
      }
    },
    selectMenu: {
      create: 'Create "{label}"',
      noData: "No data",
      noMatch: "No matching data",
      search: "Search…"
    },
    slideover: {
      close: "Close"
    },
    table: {
      noData: "No data"
    },
    toast: {
      close: "Close"
    }
  }
});
const localeContextInjectionKey = /* @__PURE__ */ Symbol.for("nuxt-ui.locale-context");
const _useLocale = (localeOverrides) => {
  const locale = localeOverrides || toRef$2(inject(localeContextInjectionKey, en));
  return buildLocaleContext(computed(() => locale.value || en));
};
const useLocale = _useLocale;
const portalTargetInjectionKey = /* @__PURE__ */ Symbol("nuxt-ui.portal-target");
function usePortal(portal) {
  const globalPortal = inject(portalTargetInjectionKey, void 0);
  const value = computed(() => portal.value === true ? globalPortal?.value : portal.value);
  const disabled = computed(() => typeof value.value === "boolean" ? !value.value : false);
  const to = computed(() => typeof value.value === "boolean" ? "body" : value.value);
  return computed(() => ({
    to: to.value,
    disabled: disabled.value
  }));
}
const toastMaxInjectionKey = /* @__PURE__ */ Symbol("nuxt-ui.toast-max");
function useToast() {
  const toasts = useState("toasts", () => []);
  const max = inject(toastMaxInjectionKey, void 0);
  const running = ref(false);
  const queue = [];
  const generateId = () => `${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
  async function processQueue() {
    if (running.value || queue.length === 0) {
      return;
    }
    running.value = true;
    while (queue.length > 0) {
      const toast = queue.shift();
      await nextTick();
      toasts.value = [...toasts.value, toast].slice(-(max?.value ?? 5));
    }
    running.value = false;
  }
  function add(toast) {
    const body = {
      id: generateId(),
      open: true,
      ...toast
    };
    queue.push(body);
    processQueue();
    return body;
  }
  function update(id2, toast) {
    const index2 = toasts.value.findIndex((t) => t.id === id2);
    if (index2 !== -1) {
      toasts.value[index2] = {
        ...toasts.value[index2],
        ...toast
      };
    }
  }
  function remove(id2) {
    const index2 = toasts.value.findIndex((t) => t.id === id2);
    if (index2 !== -1) {
      toasts.value[index2] = {
        ...toasts.value[index2],
        open: false
      };
    }
    setTimeout(() => {
      toasts.value = toasts.value.filter((t) => t.id !== id2);
    }, 200);
  }
  function clear() {
    toasts.value = [];
  }
  return {
    toasts,
    add,
    update,
    remove,
    clear
  };
}
var SPACE_REGEX = /\s+/g;
var removeExtraSpaces = (str) => {
  if (typeof str !== "string" || !str) return str;
  return str.replace(SPACE_REGEX, " ").trim();
};
var cx = (...classnames) => {
  const classList = [];
  const buildClassString = (input) => {
    if (!input && input !== 0 && input !== 0n) return;
    if (Array.isArray(input)) {
      for (let i = 0, len = input.length; i < len; i++) buildClassString(input[i]);
      return;
    }
    const type = typeof input;
    if (type === "string" || type === "number" || type === "bigint") {
      if (type === "number" && input !== input) return;
      classList.push(String(input));
    } else if (type === "object") {
      const keys = Object.keys(input);
      for (let i = 0, len = keys.length; i < len; i++) {
        const key = keys[i];
        if (input[key]) classList.push(key);
      }
    }
  };
  for (let i = 0, len = classnames.length; i < len; i++) {
    const c2 = classnames[i];
    if (c2 !== null && c2 !== void 0) buildClassString(c2);
  }
  return classList.length > 0 ? removeExtraSpaces(classList.join(" ")) : void 0;
};
var falsyToString = (value) => value === false ? "false" : value === true ? "true" : value === 0 ? "0" : value;
var isEmptyObject = (obj) => {
  if (!obj || typeof obj !== "object") return true;
  for (const _2 in obj) return false;
  return true;
};
var isEqual = (obj1, obj2) => {
  if (obj1 === obj2) return true;
  if (!obj1 || !obj2) return false;
  const keys1 = Object.keys(obj1);
  const keys2 = Object.keys(obj2);
  if (keys1.length !== keys2.length) return false;
  for (let i = 0; i < keys1.length; i++) {
    const key = keys1[i];
    if (!keys2.includes(key)) return false;
    if (obj1[key] !== obj2[key]) return false;
  }
  return true;
};
var joinObjects = (obj1, obj2) => {
  for (const key in obj2) {
    if (Object.prototype.hasOwnProperty.call(obj2, key)) {
      const val2 = obj2[key];
      if (key in obj1) {
        obj1[key] = cx(obj1[key], val2);
      } else {
        obj1[key] = val2;
      }
    }
  }
  return obj1;
};
var flat = (arr, target) => {
  for (let i = 0; i < arr.length; i++) {
    const el = arr[i];
    if (Array.isArray(el)) flat(el, target);
    else if (el) target.push(el);
  }
};
var flatMergeArrays = (...arrays) => {
  const result = [];
  flat(arrays, result);
  const filtered = [];
  for (let i = 0; i < result.length; i++) {
    if (result[i]) filtered.push(result[i]);
  }
  return filtered;
};
var mergeObjects = (obj1, obj2) => {
  const result = {};
  for (const key in obj1) {
    const val1 = obj1[key];
    if (key in obj2) {
      const val2 = obj2[key];
      if (Array.isArray(val1) || Array.isArray(val2)) {
        result[key] = flatMergeArrays(val2, val1);
      } else if (typeof val1 === "object" && typeof val2 === "object" && val1 && val2) {
        result[key] = mergeObjects(val1, val2);
      } else {
        result[key] = val2 + " " + val1;
      }
    } else {
      result[key] = val1;
    }
  }
  for (const key in obj2) {
    if (!(key in obj1)) {
      result[key] = obj2[key];
    }
  }
  return result;
};
var defaultConfig$1 = {
  twMerge: true,
  twMergeConfig: {}
};
function createState() {
  let cachedTwMerge = null;
  let cachedTwMergeConfig = {};
  let didTwMergeConfigChange = false;
  return {
    get cachedTwMerge() {
      return cachedTwMerge;
    },
    set cachedTwMerge(value) {
      cachedTwMerge = value;
    },
    get cachedTwMergeConfig() {
      return cachedTwMergeConfig;
    },
    set cachedTwMergeConfig(value) {
      cachedTwMergeConfig = value;
    },
    get didTwMergeConfigChange() {
      return didTwMergeConfigChange;
    },
    set didTwMergeConfigChange(value) {
      didTwMergeConfigChange = value;
    },
    reset() {
      cachedTwMerge = null;
      cachedTwMergeConfig = {};
      didTwMergeConfigChange = false;
    }
  };
}
var state = createState();
var getTailwindVariants = (cn) => {
  const tv2 = (options, configProp) => {
    const {
      extend = null,
      slots: slotProps = {},
      variants: variantsProps = {},
      compoundVariants: compoundVariantsProps = [],
      compoundSlots = [],
      defaultVariants: defaultVariantsProps = {}
    } = options;
    const config = { ...defaultConfig$1, ...configProp };
    const base = extend?.base ? cx(extend.base, options?.base) : options?.base;
    const variants = extend?.variants && !isEmptyObject(extend.variants) ? mergeObjects(variantsProps, extend.variants) : variantsProps;
    const defaultVariants = extend?.defaultVariants && !isEmptyObject(extend.defaultVariants) ? { ...extend.defaultVariants, ...defaultVariantsProps } : defaultVariantsProps;
    if (!isEmptyObject(config.twMergeConfig) && !isEqual(config.twMergeConfig, state.cachedTwMergeConfig)) {
      state.didTwMergeConfigChange = true;
      state.cachedTwMergeConfig = config.twMergeConfig;
    }
    const isExtendedSlotsEmpty = isEmptyObject(extend?.slots);
    const componentSlots = !isEmptyObject(slotProps) ? {
      // add "base" to the slots object
      base: cx(options?.base, isExtendedSlotsEmpty && extend?.base),
      ...slotProps
    } : {};
    const slots = isExtendedSlotsEmpty ? componentSlots : joinObjects(
      { ...extend?.slots },
      isEmptyObject(componentSlots) ? { base: options?.base } : componentSlots
    );
    const compoundVariants = isEmptyObject(extend?.compoundVariants) ? compoundVariantsProps : flatMergeArrays(extend?.compoundVariants, compoundVariantsProps);
    const component = (props) => {
      if (isEmptyObject(variants) && isEmptyObject(slotProps) && isExtendedSlotsEmpty) {
        return cn(base, props?.class, props?.className)(config);
      }
      if (compoundVariants && !Array.isArray(compoundVariants)) {
        throw new TypeError(
          `The "compoundVariants" prop must be an array. Received: ${typeof compoundVariants}`
        );
      }
      if (compoundSlots && !Array.isArray(compoundSlots)) {
        throw new TypeError(
          `The "compoundSlots" prop must be an array. Received: ${typeof compoundSlots}`
        );
      }
      const getVariantValue = (variant, vrs = variants, _slotKey = null, slotProps2 = null) => {
        const variantObj = vrs[variant];
        if (!variantObj || isEmptyObject(variantObj)) {
          return null;
        }
        const variantProp = slotProps2?.[variant] ?? props?.[variant];
        if (variantProp === null) return null;
        const variantKey = falsyToString(variantProp);
        if (typeof variantKey === "object") {
          return null;
        }
        const defaultVariantProp = defaultVariants?.[variant];
        const key = variantKey != null ? variantKey : falsyToString(defaultVariantProp);
        const value = variantObj[key || "false"];
        return value;
      };
      const getVariantClassNames = () => {
        if (!variants) return null;
        const keys = Object.keys(variants);
        const result = [];
        for (let i = 0; i < keys.length; i++) {
          const value = getVariantValue(keys[i], variants);
          if (value) result.push(value);
        }
        return result;
      };
      const getVariantClassNamesBySlotKey = (slotKey, slotProps2) => {
        if (!variants || typeof variants !== "object") return null;
        const result = [];
        for (const variant in variants) {
          const variantValue = getVariantValue(variant, variants, slotKey, slotProps2);
          const value = slotKey === "base" && typeof variantValue === "string" ? variantValue : variantValue && variantValue[slotKey];
          if (value) result.push(value);
        }
        return result;
      };
      const propsWithoutUndefined = {};
      for (const prop in props) {
        const value = props[prop];
        if (value !== void 0) propsWithoutUndefined[prop] = value;
      }
      const getCompleteProps = (key, slotProps2) => {
        const initialProp = typeof props?.[key] === "object" ? {
          [key]: props[key]?.initial
        } : {};
        return {
          ...defaultVariants,
          ...propsWithoutUndefined,
          ...initialProp,
          ...slotProps2
        };
      };
      const getCompoundVariantsValue = (cv = [], slotProps2) => {
        const result = [];
        const cvLength = cv.length;
        for (let i = 0; i < cvLength; i++) {
          const { class: tvClass, className: tvClassName, ...compoundVariantOptions } = cv[i];
          let isValid = true;
          const completeProps = getCompleteProps(null, slotProps2);
          for (const key in compoundVariantOptions) {
            const value = compoundVariantOptions[key];
            const completePropsValue = completeProps[key];
            if (Array.isArray(value)) {
              if (!value.includes(completePropsValue)) {
                isValid = false;
                break;
              }
            } else {
              if ((value == null || value === false) && (completePropsValue == null || completePropsValue === false))
                continue;
              if (completePropsValue !== value) {
                isValid = false;
                break;
              }
            }
          }
          if (isValid) {
            if (tvClass) result.push(tvClass);
            if (tvClassName) result.push(tvClassName);
          }
        }
        return result;
      };
      const getCompoundVariantClassNamesBySlot = (slotProps2) => {
        const compoundClassNames = getCompoundVariantsValue(compoundVariants, slotProps2);
        if (!Array.isArray(compoundClassNames)) return compoundClassNames;
        const result = {};
        const cnFn = cn;
        for (let i = 0; i < compoundClassNames.length; i++) {
          const className = compoundClassNames[i];
          if (typeof className === "string") {
            result.base = cnFn(result.base, className)(config);
          } else if (typeof className === "object") {
            for (const slot in className) {
              result[slot] = cnFn(result[slot], className[slot])(config);
            }
          }
        }
        return result;
      };
      const getCompoundSlotClassNameBySlot = (slotProps2) => {
        if (compoundSlots.length < 1) return null;
        const result = {};
        const completeProps = getCompleteProps(null, slotProps2);
        for (let i = 0; i < compoundSlots.length; i++) {
          const {
            slots: slots2 = [],
            class: slotClass,
            className: slotClassName,
            ...slotVariants
          } = compoundSlots[i];
          if (!isEmptyObject(slotVariants)) {
            let isValid = true;
            for (const key in slotVariants) {
              const completePropsValue = completeProps[key];
              const slotVariantValue = slotVariants[key];
              if (completePropsValue === void 0 || (Array.isArray(slotVariantValue) ? !slotVariantValue.includes(completePropsValue) : slotVariantValue !== completePropsValue)) {
                isValid = false;
                break;
              }
            }
            if (!isValid) continue;
          }
          for (let j2 = 0; j2 < slots2.length; j2++) {
            const slotName = slots2[j2];
            if (!result[slotName]) result[slotName] = [];
            result[slotName].push([slotClass, slotClassName]);
          }
        }
        return result;
      };
      if (!isEmptyObject(slotProps) || !isExtendedSlotsEmpty) {
        const slotsFns = {};
        if (typeof slots === "object" && !isEmptyObject(slots)) {
          const cnFn = cn;
          for (const slotKey in slots) {
            slotsFns[slotKey] = (slotProps2) => {
              const compoundVariantClasses = getCompoundVariantClassNamesBySlot(slotProps2);
              const compoundSlotClasses = getCompoundSlotClassNameBySlot(slotProps2);
              return cnFn(
                slots[slotKey],
                getVariantClassNamesBySlotKey(slotKey, slotProps2),
                compoundVariantClasses ? compoundVariantClasses[slotKey] : void 0,
                compoundSlotClasses ? compoundSlotClasses[slotKey] : void 0,
                slotProps2?.class,
                slotProps2?.className
              )(config);
            };
          }
        }
        return slotsFns;
      }
      return cn(
        base,
        getVariantClassNames(),
        getCompoundVariantsValue(compoundVariants),
        props?.class,
        props?.className
      )(config);
    };
    const getVariantKeys = () => {
      if (!variants || typeof variants !== "object") return;
      return Object.keys(variants);
    };
    component.variantKeys = getVariantKeys();
    component.extend = extend;
    component.base = base;
    component.slots = slots;
    component.variants = variants;
    component.defaultVariants = defaultVariants;
    component.compoundSlots = compoundSlots;
    component.compoundVariants = compoundVariants;
    return component;
  };
  const createTV2 = (configProp) => {
    return (options, config) => tv2(options, config ? mergeObjects(configProp, config) : configProp);
  };
  return {
    tv: tv2,
    createTV: createTV2
  };
};
var createTwMerge = (cachedTwMergeConfig) => {
  return isEmptyObject(cachedTwMergeConfig) ? twMerge : extendTailwindMerge({
    ...cachedTwMergeConfig,
    extend: {
      theme: cachedTwMergeConfig.theme,
      classGroups: cachedTwMergeConfig.classGroups,
      conflictingClassGroupModifiers: cachedTwMergeConfig.conflictingClassGroupModifiers,
      conflictingClassGroups: cachedTwMergeConfig.conflictingClassGroups,
      ...cachedTwMergeConfig.extend
    }
  });
};
var executeMerge = (classnames, config) => {
  const base = cx(classnames);
  if (!base || !(config?.twMerge ?? true)) return base;
  if (!state.cachedTwMerge || state.didTwMergeConfigChange) {
    state.didTwMergeConfigChange = false;
    state.cachedTwMerge = createTwMerge(state.cachedTwMergeConfig);
  }
  return state.cachedTwMerge(base) || void 0;
};
var cnMerge = (...classnames) => {
  return (config) => executeMerge(classnames, config);
};
var { createTV } = getTailwindVariants(cnMerge);
const appConfigTv = appConfig;
const tv = /* @__PURE__ */ createTV(appConfigTv.ui?.tv);
const defaultIconDimensions = Object.freeze({
  left: 0,
  top: 0,
  width: 16,
  height: 16
});
const defaultIconTransformations = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
const defaultIconProps = Object.freeze({
  ...defaultIconDimensions,
  ...defaultIconTransformations
});
Object.freeze({
  ...defaultIconProps,
  body: "",
  hidden: false
});
function makeViewBoxSquare(viewBox) {
  const [left, top, width, height] = viewBox;
  if (width !== height) {
    const max = Math.max(width, height);
    return [
      left - (max - width) / 2,
      top - (max - height) / 2,
      max,
      max
    ];
  }
  return viewBox;
}
const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize(size, ratio, precision) {
  if (ratio === 1) return size;
  precision = precision || 100;
  if (typeof size === "number") return Math.ceil(size * ratio * precision) / precision;
  if (typeof size !== "string") return size;
  const oldParts = size.split(unitsSplit);
  if (oldParts === null || !oldParts.length) return size;
  const newParts = [];
  let code = oldParts.shift();
  let isNumber2 = unitsTest.test(code);
  while (true) {
    if (isNumber2) {
      const num = parseFloat(code);
      if (isNaN(num)) newParts.push(code);
      else newParts.push(Math.ceil(num * ratio * precision) / precision);
    } else newParts.push(code);
    code = oldParts.shift();
    if (code === void 0) return newParts.join("");
    isNumber2 = !isNumber2;
  }
}
const defaultIconSizeCustomisations = Object.freeze({
  width: null,
  height: null
});
const defaultIconCustomisations = Object.freeze({
  ...defaultIconSizeCustomisations,
  ...defaultIconTransformations
});
function splitSVGDefs(content, tag = "defs") {
  let defs = "";
  const index2 = content.indexOf("<" + tag);
  while (index2 >= 0) {
    const start = content.indexOf(">", index2);
    const end = content.indexOf("</" + tag);
    if (start === -1 || end === -1) break;
    const endEnd = content.indexOf(">", end);
    if (endEnd === -1) break;
    defs += content.slice(start + 1, end).trim();
    content = content.slice(0, index2).trim() + content.slice(endEnd + 1);
  }
  return {
    defs,
    content
  };
}
function mergeDefsAndContent(defs, content) {
  return defs ? "<defs>" + defs + "</defs>" + content : content;
}
function wrapSVGContent(body, start, end) {
  const split = splitSVGDefs(body);
  return mergeDefsAndContent(split.defs, start + split.content + end);
}
const isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";
function iconToSVG(icon, customisations) {
  const fullIcon = {
    ...defaultIconProps,
    ...icon
  };
  const fullCustomisations = {
    ...defaultIconCustomisations,
    ...customisations
  };
  const box = {
    left: fullIcon.left,
    top: fullIcon.top,
    width: fullIcon.width,
    height: fullIcon.height
  };
  let body = fullIcon.body;
  [fullIcon, fullCustomisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation2 = props.rotate;
    if (hFlip) if (vFlip) rotation2 += 2;
    else {
      transformations.push("translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")");
      transformations.push("scale(-1 1)");
      box.top = box.left = 0;
    }
    else if (vFlip) {
      transformations.push("translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")");
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation2 < 0) rotation2 -= Math.floor(rotation2 / 4) * 4;
    rotation2 = rotation2 % 4;
    switch (rotation2) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift("rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")");
        break;
      case 2:
        transformations.unshift("rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")");
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift("rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")");
        break;
    }
    if (rotation2 % 2 === 1) {
      if (box.left !== box.top) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) body = wrapSVGContent(body, '<g transform="' + transformations.join(" ") + '">', "</g>");
  });
  const customisationsWidth = fullCustomisations.width;
  const customisationsHeight = fullCustomisations.height;
  const boxWidth = box.width;
  const boxHeight = box.height;
  let width;
  let height;
  if (customisationsWidth === null) {
    height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
    width = calculateSize(height, boxWidth / boxHeight);
  } else {
    width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
    height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
  }
  const attributes = {};
  const setAttr = (prop, value) => {
    if (!isUnsetKeyword(value)) attributes[prop] = value.toString();
  };
  setAttr("width", width);
  setAttr("height", height);
  const viewBox = [
    box.left,
    box.top,
    boxWidth,
    boxHeight
  ];
  attributes.viewBox = viewBox.join(" ");
  return {
    attributes,
    viewBox,
    body
  };
}
function encodeSVGforURL(svg) {
  return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function svgToData(svg) {
  return "data:image/svg+xml," + encodeSVGforURL(svg);
}
function svgToURL(svg) {
  return 'url("' + svgToData(svg) + '")';
}
function iconToHTML(body, attributes) {
  let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const attr in attributes) renderAttribsHTML += " " + attr + '="' + attributes[attr] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + renderAttribsHTML + ">" + body + "</svg>";
}
function getCommonCSSRules(options) {
  const result = {
    display: "inline-block",
    width: "1em",
    height: "1em"
  };
  const varName = options.varName;
  if (options.pseudoSelector) result["content"] = "''";
  switch (options.mode) {
    case "background":
      if (varName) result["background-image"] = "var(--" + varName + ")";
      result["background-repeat"] = "no-repeat";
      result["background-size"] = "100% 100%";
      break;
    case "mask":
      result["background-color"] = "currentColor";
      if (varName) result["mask-image"] = result["-webkit-mask-image"] = "var(--" + varName + ")";
      result["mask-repeat"] = result["-webkit-mask-repeat"] = "no-repeat";
      result["mask-size"] = result["-webkit-mask-size"] = "100% 100%";
      break;
  }
  return result;
}
function generateItemCSSRules(icon, options) {
  const result = {};
  const varName = options.varName;
  const buildResult = iconToSVG(icon);
  let viewBox = buildResult.viewBox;
  if (viewBox[2] !== viewBox[3]) if (options.forceSquare) viewBox = makeViewBoxSquare(viewBox);
  else result["width"] = calculateSize("1em", viewBox[2] / viewBox[3]);
  const url = svgToURL(iconToHTML(buildResult.body.replace(/currentColor/g, options.color || "black"), {
    viewBox: `${viewBox[0]} ${viewBox[1]} ${viewBox[2]} ${viewBox[3]}`,
    width: `${viewBox[2]}`,
    height: `${viewBox[3]}`
  }));
  if (varName) result["--" + varName] = url;
  else switch (options.mode) {
    case "background":
      result["background-image"] = url;
      break;
    case "mask":
      result["mask-image"] = result["-webkit-mask-image"] = url;
      break;
  }
  return result;
}
const format = {
  selectorStart: {
    compressed: "{",
    compact: " {",
    expanded: " {"
  },
  selectorEnd: {
    compressed: "}",
    compact: "; }\n",
    expanded: ";\n}\n"
  },
  rule: {
    compressed: "{key}:",
    compact: " {key}: ",
    expanded: "\n  {key}: "
  }
};
function formatCSS(data, mode = "expanded") {
  const results = [];
  for (let i = 0; i < data.length; i++) {
    const { selector, rules } = data[i];
    let entry2 = (selector instanceof Array ? selector.join(mode === "compressed" ? "," : ", ") : selector) + format.selectorStart[mode];
    let firstRule = true;
    for (const key in rules) {
      if (!firstRule) entry2 += ";";
      entry2 += format.rule[mode].replace("{key}", key) + rules[key];
      firstRule = false;
    }
    entry2 += format.selectorEnd[mode];
    results.push(entry2);
  }
  return results.join(mode === "compressed" ? "" : "\n");
}
function getIconCSS(icon, options = {}) {
  const body = options.customise ? options.customise(icon.body) : icon.body;
  const mode = options.mode || (options.color || !body.includes("currentColor") ? "background" : "mask");
  let varName = options.varName;
  if (varName === void 0 && mode === "mask") varName = "svg";
  const newOptions = {
    ...options,
    mode,
    varName
  };
  if (mode === "background") delete newOptions.varName;
  const rules = {
    ...options.rules,
    ...getCommonCSSRules(newOptions),
    ...generateItemCSSRules({
      ...defaultIconProps,
      ...icon,
      body
    }, newOptions)
  };
  return formatCSS([{
    selector: options.iconSelector || ".icon",
    rules
  }], newOptions.format);
}
let _initialized = false;
function init(addIcon2) {
  if (_initialized)
    return;
  const collections = JSON.parse('[{"prefix":"svg-spinners","icons":{"180-ring-with-bg":{"width":24,"height":24,"body":"<path fill=\\"currentColor\\" d=\\"M12,1A11,11,0,1,0,23,12,11,11,0,0,0,12,1Zm0,19a8,8,0,1,1,8-8A8,8,0,0,1,12,20Z\\" opacity=\\".25\\"/><path fill=\\"currentColor\\" d=\\"M12,4a8,8,0,0,1,7.89,6.7A1.53,1.53,0,0,0,21.38,12h0a1.5,1.5,0,0,0,1.48-1.75,11,11,0,0,0-21.72,0A1.5,1.5,0,0,0,2.62,12h0a1.53,1.53,0,0,0,1.49-1.3A8,8,0,0,1,12,4Z\\"><animateTransform attributeName=\\"transform\\" dur=\\"0.75s\\" repeatCount=\\"indefinite\\" type=\\"rotate\\" values=\\"0 12 12;360 12 12\\"/></path>"}}},{"prefix":"carbon","icons":{"iso-outline":{"width":32,"height":32,"body":"<path fill=\\"currentColor\\" d=\\"M24 21h-3a2 2 0 0 1-2-2v-6a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v6a2 2 0 0 1-2 2m-3-8v6h3v-6zm-6 8h-5v-2h5v-2h-3a2 2 0 0 1-2-2v-2a2 2 0 0 1 2-2h5v2h-5v2h3a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2M6 11h2v10H6z\\"/><path fill=\\"currentColor\\" d=\\"M28 6H4a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h24a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2M4 24V8h24v16Z\\"/>"}}},{"prefix":"tabler","icons":{"loader":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M12 6V3m4.25 4.75L18.4 5.6M18 12h3m-4.75 4.25l2.15 2.15M12 18v3m-4.25-4.75L5.6 18.4M6 12H3m4.75-4.25L5.6 5.6\\"/>"},"alert-triangle":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M12 9v4m-1.637-9.409L2.257 17.125a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636-2.87L13.637 3.59a1.914 1.914 0 0 0-3.274 0M12 16h.01\\"/>"},"dashboard":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M10 13a2 2 0 1 0 4 0a2 2 0 1 0-4 0m3.45-1.45L15.5 9.5\\"/><path d=\\"M6.4 20a9 9 0 1 1 11.2 0z\\"/></g>"},"photo-cog":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M15 8h.01M12 21H6a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v6\\"/><path d=\\"m3 16l5-5c.928-.893 2.072-.893 3 0l3 3m0 0l1-1c.48-.461 1.016-.684 1.551-.67m.45 6.67a2 2 0 1 0 4 0a2 2 0 1 0-4 0m2-3.5V17m0 4v1.5m3.031-5.25l-1.299.75m-3.463 2l-1.3.75m0-3.5l1.3.75m3.463 2l1.3.75\\"/></g>"},"album":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M4 6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2z\\"/><path d=\\"M12 4v7l2-2l2 2V4\\"/></g>"},"list-check":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M3.5 5.5L5 7l2.5-2.5m-4 7L5 13l2.5-2.5m-4 7L5 19l2.5-2.5M11 6h9m-9 6h9m-9 6h9\\"/>"},"file-text":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M14 3v4a1 1 0 0 0 1 1h4\\"/><path d=\\"M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2M9 9h1m-1 4h6m-6 4h6\\"/></g>"},"settings":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 0 0-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 0 0-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 0 0-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 0 0-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 0 0 1.066-2.573c-.94-1.543.826-3.31 2.37-2.37c1 .608 2.296.07 2.572-1.065\\"/><path d=\\"M9 12a3 3 0 1 0 6 0a3 3 0 0 0-6 0\\"/></g>"},"settings-2":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M19.875 6.27A2.23 2.23 0 0 1 21 8.218v7.284c0 .809-.443 1.555-1.158 1.948l-6.75 4.27a2.27 2.27 0 0 1-2.184 0l-6.75-4.27A2.23 2.23 0 0 1 3 15.502V8.217c0-.809.443-1.554 1.158-1.947l6.75-3.98a2.33 2.33 0 0 1 2.25 0l6.75 3.98z\\"/><path d=\\"M9 12a3 3 0 1 0 6 0a3 3 0 1 0-6 0\\"/></g>"},"database":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M4 6a8 3 0 1 0 16 0A8 3 0 1 0 4 6\\"/><path d=\\"M4 6v6a8 3 0 0 0 16 0V6\\"/><path d=\\"M4 12v6a8 3 0 0 0 16 0v-6\\"/></g>"},"map-pin":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M9 11a3 3 0 1 0 6 0a3 3 0 0 0-6 0\\"/><path d=\\"M17.657 16.657L13.414 20.9a2 2 0 0 1-2.827 0l-4.244-4.243a8 8 0 1 1 11.314 0\\"/></g>"},"cpu":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M5 6a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1z\\"/><path d=\\"M9 9h6v6H9zm-6 1h2m-2 4h2m5-11v2m4-2v2m7 5h-2m2 4h-2m-5 7v-2m-4 2v-2\\"/></g>"},"brand-github":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2c2.8-.3 5.5-1.4 5.5-6a4.6 4.6 0 0 0-1.3-3.2a4.2 4.2 0 0 0-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3 0 0 0-6.2 0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2 0 0 0-.1 3.2A4.6 4.6 0 0 0 4 9.5c0 4.6 2.7 5.7 5.5 6c-.6.6-.6 1.2-.5 2V21\\"/>"},"book":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0M3 6v13m9-13v13m9-13v13\\"/>"},"brand-discord":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M8 12a1 1 0 1 0 2 0a1 1 0 0 0-2 0m6 0a1 1 0 1 0 2 0a1 1 0 0 0-2 0\\"/><path d=\\"M15.5 17c0 1 1.5 3 2 3c1.5 0 2.833-1.667 3.5-3c.667-1.667.5-5.833-1.5-11.5c-1.457-1.015-3-1.34-4.5-1.5l-.972 1.923a11.9 11.9 0 0 0-4.053 0L9 4c-1.5.16-3.043.485-4.5 1.5c-2 5.667-2.167 9.833-1.5 11.5c.667 1.333 2 3 3.5 3c.5 0 2-2 2-3\\"/><path d=\\"M7 16.5c3.5 1 6.5 1 10 0\\"/></g>"},"user":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M8 7a4 4 0 1 0 8 0a4 4 0 0 0-8 0M6 21v-2a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v2\\"/>"},"info-circle":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M3 12a9 9 0 1 0 18 0a9 9 0 0 0-18 0m9-3h.01\\"/><path d=\\"M11 12h1v4h1\\"/></g>"},"home":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M5 12H3l9-9l9 9h-2M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-7\\"/><path d=\\"M9 21v-6a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v6\\"/></g>"},"plus":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M12 5v14m-7-7h14\\"/>"},"minus":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M5 12h14\\"/>"},"scan-position":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M4 7V6a2 2 0 0 1 2-2h2M4 17v1a2 2 0 0 0 2 2h2m8-16h2a2 2 0 0 1 2 2v1m-4 13h2a2 2 0 0 0 2-2v-1m-8 0l3-8l-8 3l3.5 1.5z\\"/>"},"map-pin-off":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M9.442 9.432a3 3 0 0 0 4.113 4.134M15 11a3 3 0 0 0-3-3\\"/><path d=\\"M17.152 17.162L13.414 20.9a2 2 0 0 1-2.827 0l-4.244-4.243a8 8 0 0 1-.476-10.794m2.18-1.82a8.003 8.003 0 0 1 10.91 10.912M3 3l18 18\\"/></g>"},"check":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"m5 12l5 5L20 7\\"/>"},"camera":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M5 7h1a2 2 0 0 0 2-2a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1a2 2 0 0 0 2 2h1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2\\"/><path d=\\"M9 13a3 3 0 1 0 6 0a3 3 0 0 0-6 0\\"/></g>"},"aperture":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M3 12a9 9 0 1 0 18 0a9 9 0 1 0-18 0m.6 3h10.55M6.551 4.938l3.26 10.034m7.221-10.336l-8.535 6.201m12.062 3.673l-8.535-6.201m.233 12.607l3.261-10.034\\"/>"},"circle-check":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M3 12a9 9 0 1 0 18 0a9 9 0 1 0-18 0\\"/><path d=\\"m9 12l2 2l4-4\\"/></g>"},"icons":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M3 6.5a3.5 3.5 0 1 0 7 0a3.5 3.5 0 1 0-7 0M2.5 21h8l-4-7zM14 3l7 7m-7 0l7-7m-7 11h7v7h-7z\\"/>"},"external-link":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M12 6H6a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-6m-7 1l9-9m-5 0h5v5\\"/>"},"calendar-week":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M4 7a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2zm12-4v4M8 3v4m-4 4h16M7 14h.013m2.997 0h.005m2.995 0h.005m3 0h.005m-3.005 3h.005m-6.01 0h.005m2.995 0h.005\\"/>"},"photo":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M15 8h.01M3 6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3z\\"/><path d=\\"m3 16l5-5c.928-.893 2.072-.893 3 0l5 5\\"/><path d=\\"m14 14l1-1c.928-.893 2.072-.893 3 0l3 3\\"/></g>"},"x":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M18 6L6 18M6 6l12 12\\"/>"},"mountain":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M3 20h18L14.079 5.388a2.3 2.3 0 0 0-4.158 0z\\"/><path d=\\"m7.5 11l2 2.5L12 11l2 3l2.5-2\\"/></g>"},"tags":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M3 8v4.172a2 2 0 0 0 .586 1.414l5.71 5.71a2.41 2.41 0 0 0 3.408 0l3.592-3.592a2.41 2.41 0 0 0 0-3.408l-5.71-5.71A2 2 0 0 0 9.172 6H5a2 2 0 0 0-2 2\\"/><path d=\\"m18 19l1.592-1.592a4.82 4.82 0 0 0 0-6.816L15 6m-8 4h-.01\\"/></g>"},"star":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"m12 17.75l-6.172 3.245l1.179-6.873l-5-4.867l6.9-1l3.086-6.253l3.086 6.253l6.9 1l-5 4.867l1.179 6.873z\\"/>"},"filter-x":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M13.758 19.414L9 21v-8.5L4.52 7.572A2 2 0 0 1 4 6.227V4h16v2.172a2 2 0 0 1-.586 1.414L15 12v1.5m7 8.5l-5-5m0 5l5-5\\"/>"},"search":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M3 10a7 7 0 1 0 14 0a7 7 0 1 0-14 0m18 11l-6-6\\"/>"},"dice-3":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M3 5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\\"/><path fill=\\"currentColor\\" d=\\"M8 8.5a.5.5 0 1 0 1 0a.5.5 0 1 0-1 0m7 7a.5.5 0 1 0 1 0a.5.5 0 1 0-1 0M11.5 12a.5.5 0 1 0 1 0a.5.5 0 1 0-1 0\\"/></g>"},"file":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M14 3v4a1 1 0 0 0 1 1h4\\"/><path d=\\"M17 21H7a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7l5 5v11a2 2 0 0 1-2 2\\"/></g>"},"dimensions":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M3 5h11m-2 2l2-2l-2-2M5 3L3 5l2 2m14 3v11m-2-2l2 2l2-2m0-7l-2-2l-2 2M3 12a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\\"/>"},"grid-dots":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M4 5a1 1 0 1 0 2 0a1 1 0 1 0-2 0m7 0a1 1 0 1 0 2 0a1 1 0 1 0-2 0m7 0a1 1 0 1 0 2 0a1 1 0 1 0-2 0M4 12a1 1 0 1 0 2 0a1 1 0 1 0-2 0m7 0a1 1 0 1 0 2 0a1 1 0 1 0-2 0m7 0a1 1 0 1 0 2 0a1 1 0 1 0-2 0M4 19a1 1 0 1 0 2 0a1 1 0 1 0-2 0m7 0a1 1 0 1 0 2 0a1 1 0 1 0-2 0m7 0a1 1 0 1 0 2 0a1 1 0 1 0-2 0\\"/>"},"calendar":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M4 7a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2zm12-4v4M8 3v4m-4 4h16m-9 4h1m0 0v3\\"/>"},"palette":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M12 21a9 9 0 0 1 0-18c4.97 0 9 3.582 9 8c0 1.06-.474 2.078-1.318 2.828S17.693 15 16.5 15H14a2 2 0 0 0-1 3.75A1.3 1.3 0 0 1 12 21\\"/><path d=\\"M7.5 10.5a1 1 0 1 0 2 0a1 1 0 1 0-2 0m4-3a1 1 0 1 0 2 0a1 1 0 1 0-2 0m4 3a1 1 0 1 0 2 0a1 1 0 1 0-2 0\\"/></g>"},"app-window":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M3 7a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2zm3 1h.01M9 8h.01\\"/>"},"world":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M3 12a9 9 0 1 0 18 0a9 9 0 0 0-18 0m.6-3h16.8M3.6 15h16.8\\"/><path d=\\"M11.5 3a17 17 0 0 0 0 18m1-18a17 17 0 0 1 0 18\\"/></g>"},"building":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M3 21h18M9 8h1m-1 4h1m-1 4h1m4-8h1m-1 4h1m-1 4h1M5 21V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16\\"/>"},"gps":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M3 12a9 9 0 1 0 18 0a9 9 0 1 0-18 0\\"/><path d=\\"m12 17l-1-4l-4-1l9-4z\\"/></g>"},"telescope":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"m6 21l6-5l6 5m-6-8v8m-8.706-7.322l.166.281c.52.88 1.624 1.265 2.605.91l14.242-5.165a1.023 1.023 0 0 0 .565-1.456l-2.62-4.705a1.087 1.087 0 0 0-1.447-.42l-.056.032l-12.694 7.618c-1.02.613-1.357 1.897-.76 2.905zM14 5l3 5.5\\"/>"},"clock":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M3 12a9 9 0 1 0 18 0a9 9 0 0 0-18 0\\"/><path d=\\"M12 7v5l3 3\\"/></g>"},"sun-electricity":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M8 12a4 4 0 0 0 4 4m0-8a4 4 0 0 0-4 4m-5 0h1m8-9v1m0 16v1M5.6 5.6l.7.7m0 11.4l-.7.7M20 7l-3 5h4l-3 5\\"/>"},"focus":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path fill=\\"currentColor\\" d=\\"M11.5 12a.5.5 0 1 0 1 0a.5.5 0 1 0-1 0\\"/><path d=\\"M3 12a9 9 0 1 0 18 0a9 9 0 1 0-18 0\\"/></g>"},"zoom-in-area":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M15 13v4m-2-2h4m-7 0a5 5 0 1 0 10 0a5 5 0 1 0-10 0m12 7l-3-3M6 18H5a2 2 0 0 1-2-2v-1m0-4v-1m0-4V5a2 2 0 0 1 2-2h1m4 0h1m4 0h1a2 2 0 0 1 2 2v1\\"/>"},"exposure":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M3.6 20.4L20.4 3.6M6 8h4M8 6v4m6 6h4M3 5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\\"/>"},"exposure-filled":{"width":24,"height":24,"body":"<path fill=\\"currentColor\\" d=\\"M19 2a3 3 0 0 1 3 3v14a3 3 0 0 1-3 3H5a3 3 0 0 1-3-3V5a3 3 0 0 1 3-3zm0 2H5a1 1 0 0 0-1 1v14c0 .29.123.55.321.732l1.61-1.584a973 973 0 0 0 6.69-6.675L19.715 4.3A1 1 0 0 0 19 4m-1 11h-4a1 1 0 0 0 0 2h4a1 1 0 0 0 0-2M8 5a1 1 0 0 1 1 1v1h1a1 1 0 0 1 .993.883L11 8a1 1 0 0 1-1 1H9v1a1 1 0 0 1-.883.993L8 11a1 1 0 0 1-1-1V9H6a1 1 0 0 1-.993-.883L5 8a1 1 0 0 1 1-1h1V6a1 1 0 0 1 .883-.993z\\"/>"},"focus-auto":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M4 8V6a2 2 0 0 1 2-2h2M4 16v2a2 2 0 0 0 2 2h2m8-16h2a2 2 0 0 1 2 2v2m-4 12h2a2 2 0 0 0 2-2v-2m-10-1v-4a2 2 0 1 1 4 0v4m-4-2h4\\"/>"},"sun":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M8 12a4 4 0 1 0 8 0a4 4 0 1 0-8 0m-5 0h1m8-9v1m8 8h1m-9 8v1M5.6 5.6l.7.7m12.1-.7l-.7.7m0 11.4l.7.7m-12.1-.7l-.7.7\\"/>"},"photo-sensor":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M17 5h2a2 2 0 0 1 2 2v2m0 6v2a2 2 0 0 1-2 2h-2M7 19H5a2 2 0 0 1-2-2v-2m0-6V7a2 2 0 0 1 2-2h2m0 5a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1v4a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1z\\"/>"},"live-photo":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M11 12a1 1 0 1 0 2 0a1 1 0 1 0-2 0\\"/><path d=\\"M7 12a5 5 0 1 0 10 0a5 5 0 1 0-10 0m8.9 8.11v.01m3.14-2.51v.01M20.77 14v.01m0-4.01v.01m-1.73-3.62v.01M15.9 3.89v.01M12 3v.01m-3.9.88v.01M4.96 6.39v.01M3.23 10v.01m0 3.99v.01m1.73 3.6v.01m3.14 2.49v.01M12 21v.01\\"/></g>"},"loader-2":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M12 3a9 9 0 1 0 9 9\\"/>"},"photo-off":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M15 8h.01M7 3h11a3 3 0 0 1 3 3v11m-.856 3.099A3 3 0 0 1 18 21H6a3 3 0 0 1-3-3V6c0-.845.349-1.608.91-2.153\\"/><path d=\\"m3 16l5-5c.928-.893 2.072-.893 3 0l5 5m.33-3.662c.574-.054 1.155.166 1.67.662l3 3M3 3l18 18\\"/></g>"},"download":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M7 11l5 5l5-5m-5-7v12\\"/>"},"brand-twitter":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M22 4.01c-1 .49-1.98.689-3 .99c-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4c0 0-4.182 7.433 4 11c-1.872 1.247-3.739 2.088-6 2c3.308 1.803 6.913 2.423 10.034 1.517c3.58-1.04 6.522-3.723 7.651-7.742a13.8 13.8 0 0 0 .497-3.753c0-.249 1.51-2.772 1.818-4.013z\\"/>"},"brand-telegram":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"m15 10l-4 4l6 6l4-16l-18 7l4 2l2 6l3-4\\"/>"},"brand-weibo":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M19 14.127C19 17.2 15.498 20 11 20c-4.126 0-8-2.224-8-5.565c0-1.78.984-3.737 2.7-5.567c2.362-2.51 5.193-3.687 6.551-2.238c.415.44.752 1.39.749 2.062c2-1.615 4.308.387 3.5 2.693c1.26.557 2.5.538 2.5 2.742M15 4h1a5 5 0 0 1 5 5v1\\"/>"},"brand-facebook":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M7 10v4h3v7h4v-7h3l1-4h-4V8a1 1 0 0 1 1-1h3V3h-3a5 5 0 0 0-5 5v2z\\"/>"},"brand-whatsapp":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"m3 21l1.65-3.8a9 9 0 1 1 3.4 2.9z\\"/><path d=\\"M9 10a.5.5 0 0 0 1 0V9a.5.5 0 0 0-1 0za5 5 0 0 0 5 5h1a.5.5 0 0 0 0-1h-1a.5.5 0 0 0 0 1\\"/></g>"},"brand-linkedin":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M8 11v5m0-8v.01M12 16v-5m4 5v-3a2 2 0 1 0-4 0\\"/><path d=\\"M3 7a4 4 0 0 1 4-4h10a4 4 0 0 1 4 4v10a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4z\\"/></g>"},"share-3":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M13 4v4C6.425 9.028 3.98 14.788 3 20c-.037.206 5.384-5.962 10-6v4l8-7z\\"/>"},"share-2":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M8 9H7a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-8a2 2 0 0 0-2-2h-1m-4 5V3M9 6l3-3l3 3\\"/>"},"copy":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M7 9.667A2.667 2.667 0 0 1 9.667 7h8.666A2.667 2.667 0 0 1 21 9.667v8.666A2.667 2.667 0 0 1 18.333 21H9.667A2.667 2.667 0 0 1 7 18.333z\\"/><path d=\\"M4.012 16.737A2 2 0 0 1 3 15V5c0-1.1.9-2 2-2h10c.75 0 1.158.385 1.5 1\\"/></g>"},"alert-circle":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M3 12a9 9 0 1 0 18 0a9 9 0 0 0-18 0m9-4v4m0 4h.01\\"/>"},"volume-off":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M15 8a5 5 0 0 1 1.912 4.934m-1.377 2.602A5 5 0 0 1 15 16m2.7-11a9 9 0 0 1 2.362 11.086m-1.676 2.299A9 9 0 0 1 17.7 19M9.069 5.054L9.5 4.5A.8.8 0 0 1 11 5v2m0 4v8a.8.8 0 0 1-1.5.5L6 15H4a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h2l1.294-1.664M3 3l18 18\\"/>"},"volume":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M15 8a5 5 0 0 1 0 8m2.7-11a9 9 0 0 1 0 14M6 15H4a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1h2l3.5-4.5A.8.8 0 0 1 11 5v14a.8.8 0 0 1-1.5.5z\\"/>"},"mood-smile":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M3 12a9 9 0 1 0 18 0a9 9 0 1 0-18 0m6-2h.01M15 10h.01\\"/><path d=\\"M9.5 15a3.5 3.5 0 0 0 5 0\\"/></g>"},"chevron-left":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"m15 6l-6 6l6 6\\"/>"},"chevron-right":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"m9 6l6 6l-6 6\\"/>"},"arrow-up":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M12 5v14m6-8l-6-6m-6 6l6-6\\"/>"},"device-floppy":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M6 4h10l4 4v10a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2\\"/><path d=\\"M10 14a2 2 0 1 0 4 0a2 2 0 1 0-4 0m4-10v4H8V4\\"/></g>"},"arrow-left":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M5 12h14M5 12l6 6m-6-6l6-6\\"/>"},"login-2":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M9 8V6a2 2 0 0 1 2-2h7a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2v-2\\"/><path d=\\"M3 12h13l-3-3m0 6l3-3\\"/></g>"},"video":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"m15 10l4.553-2.276A1 1 0 0 1 21 8.618v6.764a1 1 0 0 1-1.447.894L15 14zM3 8a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z\\"/>"},"arrow-big-right-lines":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M12 9V5.414a1 1 0 0 1 1.707-.707l6.586 6.586a1 1 0 0 1 0 1.414l-6.586 6.586A1 1 0 0 1 12 18.586V15H9V9zM3 9v6m3-6v6\\"/>"},"cancel":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M3 12a9 9 0 1 0 18 0a9 9 0 1 0-18 0m15.364-6.364L5.636 18.364\\"/>"},"clock-plus":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M20.984 12.535a9 9 0 1 0-8.468 8.45M16 19h6m-3-3v6\\"/><path d=\\"M12 7v5l3 3\\"/></g>"},"library-photo":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M7 5.667A2.667 2.667 0 0 1 9.667 3h8.666A2.667 2.667 0 0 1 21 5.667v8.666A2.667 2.667 0 0 1 18.333 17H9.667A2.667 2.667 0 0 1 7 14.333z\\"/><path d=\\"M4.012 7.26A2 2 0 0 0 3 8.997v10c0 1.1.9 2 2 2h10c.75 0 1.158-.385 1.5-1M17 7h.01\\"/><path d=\\"m7 13l3.644-3.644a1.21 1.21 0 0 1 1.712 0L16 13\\"/><path d=\\"m15 12l1.644-1.644a1.21 1.21 0 0 1 1.712 0L21 13\\"/></g>"},"arrow-right":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M5 12h14m-6 6l6-6m-6-6l6 6\\"/>"},"edit":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M7 7H6a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h9a2 2 0 0 0 2-2v-1\\"/><path d=\\"M20.385 6.585a2.1 2.1 0 0 0-2.97-2.97L9 12v3h3zM16 5l3 3\\"/></g>"},"trash":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M4 7h16m-10 4v6m4-6v6M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-12M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3\\"/>"},"photo-plus":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M15 8h.01M12.5 21H6a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v6.5\\"/><path d=\\"m3 16l5-5c.928-.893 2.072-.893 3 0l4 4\\"/><path d=\\"m14 14l1-1c.67-.644 1.45-.824 2.182-.54M16 19h6m-3-3v6\\"/></g>"},"star-filled":{"width":24,"height":24,"body":"<path fill=\\"currentColor\\" d=\\"m8.243 7.34l-6.38.925l-.113.023a1 1 0 0 0-.44 1.684l4.622 4.499l-1.09 6.355l-.013.11a1 1 0 0 0 1.464.944l5.706-3l5.693 3l.1.046a1 1 0 0 0 1.352-1.1l-1.091-6.355l4.624-4.5l.078-.085a1 1 0 0 0-.633-1.62l-6.38-.926l-2.852-5.78a1 1 0 0 0-1.794 0z\\"/>"},"upload":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M7 9l5-5l5 5m-5-5v12\\"/>"},"chevron-down":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"m6 9l6 6l6-6\\"/>"},"arrow-bar-to-down":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M4 20h16m-8-6V4m0 10l4-4m-4 4l-4-4\\"/>"},"pencil":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M4 20h4L18.5 9.5a2.828 2.828 0 1 0-4-4L4 16zm9.5-13.5l4 4\\"/>"},"refresh":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4m-4 4a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4\\"/>"},"cloud-upload":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M7 18a4.6 4.4 0 0 1 0-9a5 4.5 0 0 1 11 2h1a3.5 3.5 0 0 1 0 7h-1\\"/><path d=\\"m9 15l3-3l3 3m-3-3v9\\"/></g>"},"filter":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M4 4h16v2.172a2 2 0 0 1-.586 1.414L15 12v7l-6 2v-8.5L4.52 7.572A2 2 0 0 1 4 6.227z\\"/>"},"photo-scan":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M15 8h.01M6 13l2.644-2.644a1.21 1.21 0 0 1 1.712 0L14 14\\"/><path d=\\"m13 13l1.644-1.644a1.21 1.21 0 0 1 1.712 0L18 13M4 8V6a2 2 0 0 1 2-2h2M4 16v2a2 2 0 0 0 2 2h2m8-16h2a2 2 0 0 1 2 2v2m-4 12h2a2 2 0 0 0 2-2v-2\\"/></g>"},"columns-3":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M3 4a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1zm6-1v18m6-18v18\\"/>"},"dots-vertical":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M11 12a1 1 0 1 0 2 0a1 1 0 1 0-2 0m0 7a1 1 0 1 0 2 0a1 1 0 1 0-2 0m0-14a1 1 0 1 0 2 0a1 1 0 1 0-2 0\\"/>"},"map-off":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M8.32 4.34L9 4l6 3l6-3v13m-2.67 1.335L15 20l-6-3l-6 3V7l2.665-1.333M9 4v1m0 4v8m6-10v4m0 4v5M3 3l18 18\\"/>"},"inbox":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M4 6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2z\\"/><path d=\\"M4 13h3l3 3h4l3-3h3\\"/></g>"},"device-laptop":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M3 19h18M5 7a1 1 0 0 1 1-1h12a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1z\\"/>"},"server":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M3 7a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v2a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3m0 6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v2a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3zm4-7v.01M7 16v.01\\"/>"},"map":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"m3 7l6-3l6 3l6-3v13l-6 3l-6-3l-6 3zm6-3v13m6-10v13\\"/>"},"map-pin-2":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M12 18.5L9 17l-6 3V7l6-3l6 3l6-3v7M9 4v13m6-10v5m6.121 8.121a3 3 0 1 0-4.242 0Q17.506 20.749 19 22q1.577-1.335 2.121-1.879M19 18v.01\\"/>"},"moon":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M12 3h.393a7.5 7.5 0 0 0 7.92 12.446A9 9 0 1 1 12 2.992z\\"/>"},"logout":{"width":24,"height":24,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\"><path d=\\"M14 8V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h7a2 2 0 0 0 2-2v-2\\"/><path d=\\"M9 12h12l-3-3m0 6l3-3\\"/></g>"},"brand-aws":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M17 18.5a15.2 15.2 0 0 1-7.37 1.44A14.6 14.6 0 0 1 3 17m16.5 4c.907-1.411 1.451-3.323 1.5-5c-1.197-.773-2.577-.935-4-1M3 11V6.5a1.5 1.5 0 0 1 3 0V11M3 9h3m3-4l1.2 6L12 7l1.8 4L15 5m3 5.25c0 .414.336.75.75.75H20a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1h-1a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1h1.25a.75.75 0 0 1 .75.75\\"/>"},"cloud":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M6.657 18C4.085 18 2 15.993 2 13.517s2.085-4.482 4.657-4.482c.393-1.762 1.794-3.2 3.675-3.773c1.88-.572 3.956-.193 5.444 1c1.488 1.19 2.162 3.007 1.77 4.769h.99c1.913 0 3.464 1.56 3.464 3.486s-1.551 3.487-3.465 3.487H6.657\\"/>"},"arrows-exchange":{"width":24,"height":24,"body":"<path fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\" stroke-width=\\"2\\" d=\\"M7 10h14l-4-4m0 8H3l4 4\\"/>"}}},{"prefix":"streamline","icons":{"image-accessories-lenses-photos-camera-shutter-picture-photography-pictures-photo-lens":{"width":14,"height":14,"body":"<g fill=\\"none\\" stroke=\\"currentColor\\" stroke-linecap=\\"round\\" stroke-linejoin=\\"round\\"><circle cx=\\"7\\" cy=\\"7\\" r=\\"6.5\\"/><circle cx=\\"7\\" cy=\\"7\\" r=\\"2.5\\"/><path d=\\"M4.5 7V1M7 4.5h6M9.5 7v6M7 9.5H1\\"/></g>","hidden":true}}},{"prefix":"mdi","icons":{"white-balance-auto":{"width":24,"height":24,"body":"<path fill=\\"currentColor\\" d=\\"m10.3 16l-.7-2H6.4l-.7 2H3.8L7 7h2l3.2 9M22 7l-1.2 6.29L19.3 7h-1.6l-1.49 6.29L15 7h-.76C12.77 5.17 10.5 4 8 4a8 8 0 0 0-8 8a8 8 0 0 0 8 8c3.13 0 5.84-1.81 7.15-4.43l.1.43H17l1.5-6.1L20 16h1.75l2.05-9M6.85 12.65h2.3L8 9z\\"/>"},"github":{"width":24,"height":24,"body":"<path fill=\\"currentColor\\" d=\\"M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5c.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34c-.46-1.16-1.11-1.47-1.11-1.47c-.91-.62.07-.6.07-.6c1 .07 1.53 1.03 1.53 1.03c.87 1.52 2.34 1.07 2.91.83c.09-.65.35-1.09.63-1.34c-2.22-.25-4.55-1.11-4.55-4.92c0-1.11.38-2 1.03-2.71c-.1-.25-.45-1.29.1-2.64c0 0 .84-.27 2.75 1.02c.79-.22 1.65-.33 2.5-.33s1.71.11 2.5.33c1.91-1.29 2.75-1.02 2.75-1.02c.55 1.35.2 2.39.1 2.64c.65.71 1.03 1.6 1.03 2.71c0 3.82-2.34 4.66-4.57 4.91c.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2\\"/>"}}},{"prefix":"material-symbols","icons":{"shutter-speed":{"width":24,"height":24,"body":"<path fill=\\"currentColor\\" d=\\"M9 3V1h6v2zm3 19q-1.875 0-3.512-.712T5.625 19.35T3.7 16.487T3 13t.713-3.488T5.65 6.65t2.863-1.937T12 4q1.575 0 3 .525T17.6 6l1.45-1.45l1.4 1.4l-1.4 1.45q.9 1.175 1.425 2.6T21 13q0 1.85-.7 3.488t-1.925 2.862t-2.863 1.938T12 22m0-2q2.925 0 4.963-2.037T19 13t-2.037-4.962T12 6T7.038 8.038T5 13t2.038 4.963T12 20m0-9h5.65q-.45-1.275-1.4-2.238T14.1 7.375zm-1.725 1L13.1 7.1q-1.275-.25-2.562.075t-2.363 1.2zM6.1 14h4.175L7.45 9.1q-.875.975-1.225 2.263T6.1 14m3.8 4.625L12 15H6.35q.425 1.25 1.388 2.225t2.162 1.4m1 .275q1.425.275 2.725-.112t2.2-1.163L13.725 14zm5.65-2q.9-1.025 1.238-2.287T17.9 12h-4.175z\\"/>"},"flash-on-rounded":{"width":24,"height":24,"body":"<path fill=\\"currentColor\\" d=\\"M10.525 20.325q-.225-.075-.375-.262T10 19.6V14H9q-.825 0-1.412-.587T7 12V4q0-.825.588-1.412T9 2h5.85q.8 0 1.288.625T16.425 4L15 9h1.125q.9 0 1.338.8t-.088 1.55l-6 8.675q-.15.225-.387.3t-.463 0\\"/>"},"scene":{"width":24,"height":24,"body":"<path fill=\\"currentColor\\" d=\\"M20 22V7q0-.825-.587-1.412T18 5h-1v1.3q0 .3-.2.5t-.5.2h-5.6q-.35 0-.562-.375T10.1 5.9L12 1.8q.175-.375.513-.588T13.3 1h2.3q.6 0 1 .45T17 2.5V3h1q1.65 0 2.825 1.175T22 7v15zM5 22q-1.275 0-2.137-.862T2 19v-2.5q0-.625.438-1.062T3.5 15t1.063.438T5 16.5V19h10v-2.5q0-.625.438-1.062T16.5 15t1.063.438T18 16.5V19q0 1.275-.862 2.138T15 22zm1-4v-1.5q0-.8-.525-1.525T4 14.05V12q0-.825.587-1.413T6 10h8q.825 0 1.413.588T16 12v2.05q-.95.2-1.475.925T14 16.5V18z\\"/>"}}},{"prefix":"fluent-emoji-flat","icons":{"thumbs-up":{"width":32,"height":32,"body":"<g fill=\\"none\\"><path fill=\\"#FFC83D\\" d=\\"M12.313 5.531c0-2.9 2.124-3.583 3.312-3.562c2.413 0 3.082 2.009 3.281 3.078c.248 1.33.006 4.509-.106 5.969l-.003.041a2.3 2.3 0 0 1 .515-.057h3.858c1.56 0 2.83 1.27 2.83 2.83c0 .806-.259 1.535-.765 2.05c1.044.461 1.765 1.428 1.765 2.544c0 1.023-.463 1.92-1.364 2.418c.823.511 1.364 1.366 1.364 2.332c0 1.107-.543 2.069-1.598 2.533c.375.386.598.96.598 1.794c0 1.38-.969 2.502-2.83 2.502h-3.858q-.068 0-.134-.003h-3.131C5.609 30.172 5 23.406 5 20.656c0-5.156 2.298-6.689 4.34-8.051c.966-.644 1.875-1.25 2.457-2.183c.488-.783.515-1.5.515-4.89\\"/><path fill=\\"#D67D00\\" d=\\"M19 11c-1.02.031-4 .594-4 2.969c0 1.25.469 1.953 1.031 2.344c-.562.25-1.062 1.178-1.062 2.328c0 1.28 1.062 2.218 1.062 2.218s-1.062 1.032-1.062 2.266c0 .932.408 1.62 1.062 2.088c-.354.2-1.062.893-1.062 2.068c0 1.401 1.308 2.575 3.87 2.68c-1.248-.231-1.855-1.375-1.855-2.46c0-.358.134-.934.467-1.442H23a.5.5 0 0 0 0-1h-5.411c-.405-.53-.605-1.218-.605-1.885c0-.416.157-1.088.546-1.674H23a.5.5 0 0 0 0-1h-5.25c-.513-.55-.766-1.325-.766-2.076c0-.357.116-.905.396-1.424H23a.5.5 0 0 0 0-1h-5.173c-.564-.597-.843-1.484-.843-2.17c0-.81.443-2.6 2.016-2.81z\\"/></g>"},"red-heart":{"width":32,"height":32,"body":"<g fill=\\"none\\"><path fill=\\"#F8312F\\" d=\\"M6 6c4.665-2.332 8.5.5 10 2.5c1.5-2 5.335-4.832 10-2.5c6 3 4.5 10.5 0 15c-2.196 2.196-6.063 6.063-8.891 8.214a1.764 1.764 0 0 1-2.186-.041C12.33 27.08 8.165 23.165 6 21C1.5 16.5 0 9 6 6\\"/><path fill=\\"#CA0B4A\\" d=\\"M16 8.5v3.05c1.27-2.685 4.425-6.27 9.658-5.713c-4.51-2.03-8.195.712-9.658 2.663m-4.054-2.963C10.26 4.95 8.225 4.887 6 6C0 9 1.5 16.5 6 21c2.165 2.165 6.33 6.08 8.923 8.173a1.764 1.764 0 0 0 2.186.04q.381-.29.785-.618c-2.854-2.143-6.86-5.519-9.035-7.462c-4.957-4.431-6.61-11.815 0-14.769a9.7 9.7 0 0 1 3.087-.827\\"/><ellipse cx=\\"23.477\\" cy=\\"12.594\\" fill=\\"#F37366\\" rx=\\"2.836\\" ry=\\"4.781\\" transform=\\"rotate(30 23.477 12.594)\\"/></g>"},"smiling-face-with-heart-eyes":{"width":32,"height":32,"body":"<g fill=\\"none\\"><path fill=\\"#FFB02E\\" d=\\"M15.999 29.998c9.334 0 13.999-6.268 13.999-14c0-7.73-4.665-13.998-14-13.998C6.665 2 2 8.268 2 15.999s4.664 13.999 13.999 13.999\\"/><path fill=\\"#BB1D80\\" d=\\"M16 25c-9 0-9-9-9-9h18s0 9-9 9\\"/><path fill=\\"#fff\\" d=\\"M8 16.5V16h16v.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1\\"/><path fill=\\"#F70A8D\\" d=\\"M3.181 9.75c2.016 2.327 4.698 3.346 6.073 3.74a1.6 1.6 0 0 0 1.57-.412c1.194-1.178 3.6-3.879 4.114-6.963c.718-4.306-4.682-5.62-6.858-2.07C2.99 1.655.296 6.421 3.18 9.75m25.637.002c-2.015 2.326-4.695 3.344-6.07 3.737c-.563.162-1.154 0-1.57-.411c-1.194-1.177-3.598-3.877-4.112-6.96c-.718-4.304 4.68-5.617 6.855-2.069c5.089-2.39 7.78 2.375 4.897 5.703\\"/></g>"},"face-with-tears-of-joy":{"width":32,"height":32,"body":"<g fill=\\"none\\"><path fill=\\"#FFB02E\\" d=\\"M15.999 29.998c9.334 0 13.999-6.268 13.999-14c0-7.73-4.665-13.998-14-13.998C6.665 2 2 8.268 2 15.999s4.664 13.999 13.999 13.999\\"/><path fill=\\"#402A32\\" d=\\"M8.982 11.19c.048-.246.158-.55.367-.777c.18-.196.498-.413 1.15-.413c.643 0 .97.222 1.158.429c.218.24.323.545.358.742a1 1 0 0 0 1.97-.342a3.54 3.54 0 0 0-.85-1.747C12.563 8.452 11.696 8 10.5 8c-1.184 0-2.047.431-2.624 1.06c-.548.596-.769 1.293-.858 1.75a1 1 0 1 0 1.964.38m11 0c.048-.246.158-.55.367-.777c.18-.196.498-.413 1.151-.413c.642 0 .969.222 1.157.429c.219.24.324.545.358.742a1 1 0 0 0 1.97-.342a3.54 3.54 0 0 0-.85-1.747C23.563 8.452 22.696 8 21.5 8c-1.184 0-2.047.431-2.624 1.06c-.548.596-.769 1.293-.857 1.75a1 1 0 1 0 1.963.38\\"/><path fill=\\"#BB1D80\\" d=\\"M16 25c-9 0-9-9-9-9h18s0 9-9 9\\"/><path fill=\\"#fff\\" d=\\"M8 16.5V16h16v.5a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1\\"/><path fill=\\"#3F5FFF\\" d=\\"M4.63 20.37L8 17a2.121 2.121 0 1 0-3-3l-3.37 3.37a2.121 2.121 0 1 0 3 3m22.99 0L24.25 17a2.121 2.121 0 0 1 3-3l3.37 3.37a2.121 2.121 0 0 1-3 3\\"/></g>"},"face-with-open-mouth":{"width":32,"height":32,"body":"<g fill=\\"none\\"><path fill=\\"#FFB02E\\" d=\\"M15.999 29.998c9.334 0 13.999-6.268 13.999-14c0-7.73-4.665-13.998-14-13.998C6.665 2 2 8.268 2 15.999s4.664 13.999 13.999 13.999\\"/><path fill=\\"#fff\\" d=\\"M10.5 16a4.5 4.5 0 1 0 0-9a4.5 4.5 0 0 0 0 9m11 0a4.5 4.5 0 1 0 0-9a4.5 4.5 0 0 0 0 9\\"/><path fill=\\"#402A32\\" d=\\"M12 14a2 2 0 1 0 0-4a2 2 0 0 0 0 4m8 0a2 2 0 1 0 0-4a2 2 0 0 0 0 4\\"/><path fill=\\"#BB1D80\\" d=\\"M12 22a4 4 0 0 1 8 0v2a4 4 0 0 1-8 0z\\"/></g>"},"crying-face":{"width":32,"height":32,"body":"<g fill=\\"none\\"><path fill=\\"#FFB02E\\" d=\\"M15.999 29.998c9.334 0 13.999-6.268 13.999-14c0-7.73-4.665-13.998-14-13.998C6.665 2 2 8.268 2 15.999s4.664 13.999 13.999 13.999\\"/><path fill=\\"#fff\\" d=\\"M10.42 19.224a4.206 4.206 0 1 0 0-8.411a4.206 4.206 0 0 0 0 8.411m11.148.077a4.244 4.244 0 1 0 0-8.489a4.244 4.244 0 0 0 0 8.49\\"/><path fill=\\"#402A32\\" d=\\"M6.974 10.658c.144-.43.502-1.108 1.095-1.67C8.654 8.433 9.452 8 10.5 8a.5.5 0 0 0 0-1c-1.351 0-2.386.567-3.118 1.262c-.724.688-1.166 1.51-1.355 2.08a.5.5 0 1 0 .948.316m6.732 13.049c.28-.28 1.007-.707 2.293-.707c1.227 0 2.018.433 2.293.707a1 1 0 0 0 1.414-1.414C18.981 21.567 17.639 21 16 21c-1.714 0-2.986.572-3.707 1.293a1 1 0 0 0 1.414 1.414M23.93 8.988c.593.562.952 1.24 1.096 1.67a.5.5 0 1 0 .948-.316c-.19-.57-.631-1.392-1.355-2.08C23.887 7.567 22.852 7 21.5 7a.5.5 0 1 0 0 1c1.049 0 1.847.433 2.432.988M14 15a3 3 0 1 1-6 0a3 3 0 0 1 6 0m10 0a3 3 0 1 1-6 0a3 3 0 0 1 6 0\\"/><path fill=\\"#3F5FFF\\" d=\\"M6 21a2 2 0 1 1 4 0v3a2 2 0 1 1-4 0z\\"/></g>"},"fire":{"width":32,"height":32,"body":"<g fill=\\"none\\"><path fill=\\"#FF6723\\" d=\\"M26 19.34c0 6.1-5.05 11.005-11.15 10.641c-6.269-.374-10.56-6.403-9.752-12.705c.489-3.833 2.286-7.12 4.242-9.67c.34-.445.689 3.136 1.038 2.742c.35-.405 3.594-6.019 4.722-7.991a.694.694 0 0 1 1.028-.213C18.394 3.854 26 10.277 26 19.34\\"/><path fill=\\"#FFB02E\\" d=\\"M23 21.851c0 4.042-3.519 7.291-7.799 7.144c-4.62-.156-7.788-4.384-7.11-8.739C9.07 14.012 15.48 10 15.48 10S23 14.707 23 21.851\\"/></g>"},"sparkles":{"width":32,"height":32,"body":"<path fill=\\"#F9C23C\\" d=\\"M10.52 7.052a1.17 1.17 0 0 1-.639-.636L8.93 4.257c-.178-.343-.69-.343-.858 0l-.952 2.16a1.28 1.28 0 0 1-.638.635l-1.214.524a.462.462 0 0 0 0 .838l1.214.524c.293.121.523.353.638.636l.952 2.169c.178.343.69.343.858 0l.952-2.17c.126-.282.356-.504.638-.635l1.214-.524a.462.462 0 0 0 0-.838zm15.054 6.503a3.73 3.73 0 0 1-1.922-1.977L20.79 4.81a1.432 1.432 0 0 0-2.58 0l-2.863 6.768a3.8 3.8 0 0 1-1.921 1.977l-3.622 1.64c-1.072.53-1.072 2.08 0 2.61l3.622 1.64a3.74 3.74 0 0 1 1.922 1.977l2.862 6.768a1.432 1.432 0 0 0 2.58 0l2.863-6.768a3.8 3.8 0 0 1 1.921-1.977l3.622-1.64c1.072-.53 1.072-2.08 0-2.61zM8.281 20.33c.16.392.454.696.822.872l1.55.725a.646.646 0 0 1 0 1.146l-1.55.725c-.368.176-.661.49-.822.872l-1.228 2.977a.61.61 0 0 1-1.106 0L4.72 24.67a1.66 1.66 0 0 0-.822-.872l-1.55-.725a.646.646 0 0 1 0-1.146l1.55-.725c.368-.176.661-.49.822-.872l1.228-2.977a.61.61 0 0 1 1.106 0z\\"/>"}}}]');
  for (const collection of collections) {
    for (const [name2, data] of Object.entries(collection.icons)) {
      addIcon2(collection.prefix ? collection.prefix + ":" + name2 : name2, data);
    }
  }
  _initialized = true;
}
async function loadIcon(name2, timeout) {
  if (!name2)
    return null;
  init(addIcon);
  const _icon = getIcon(name2);
  if (_icon)
    return _icon;
  let timeoutWarn;
  const load = loadIcon$1(name2).catch(() => {
    console.warn(`[Icon] failed to load icon \`${name2}\``);
    return null;
  });
  if (timeout > 0)
    await Promise.race([
      load,
      new Promise((resolve) => {
        timeoutWarn = setTimeout(() => {
          console.warn(`[Icon] loading icon \`${name2}\` timed out after ${timeout}ms`);
          resolve();
        }, timeout);
      })
    ]).finally(() => clearTimeout(timeoutWarn));
  else
    await load;
  return getIcon(name2);
}
function useResolvedName(getName) {
  const options = useAppConfig().icon;
  const collections = (options.collections || []).sort((a, b) => b.length - a.length);
  return computed(() => {
    const name2 = getName();
    const bare = name2.startsWith(options.cssSelectorPrefix) ? name2.slice(options.cssSelectorPrefix.length) : name2;
    const resolved = options.aliases?.[bare] || bare;
    if (!resolved.includes(":")) {
      const collection = collections.find((c2) => resolved.startsWith(c2 + "-"));
      return collection ? collection + ":" + resolved.slice(collection.length + 1) : resolved;
    }
    return resolved;
  });
}
function resolveCustomizeFn(customize, globalCustomize) {
  if (customize === false) return void 0;
  if (customize === true || customize === null) return globalCustomize;
  return customize;
}
const SYMBOL_SERVER_CSS = "NUXT_ICONS_SERVER_CSS";
function escapeCssSelector(selector) {
  return selector.replace(/([^\w-])/g, "\\$1");
}
const NuxtIconCss = /* @__PURE__ */ defineComponent({
  name: "NuxtIconCss",
  props: {
    name: {
      type: String,
      required: true
    },
    customize: {
      type: [Function, Boolean, null],
      default: null,
      required: false
    }
  },
  setup(props) {
    const nuxt = useNuxtApp();
    const options = useAppConfig().icon;
    const cssClass = computed(() => props.name ? options.cssSelectorPrefix + props.name : "");
    const selector = computed(() => "." + escapeCssSelector(cssClass.value));
    function getCSS(icon, withLayer = true) {
      let iconSelector = selector.value;
      if (options.cssWherePseudo) {
        iconSelector = `:where(${iconSelector})`;
      }
      const css = getIconCSS(icon, {
        iconSelector,
        format: "compressed",
        customise: resolveCustomizeFn(props.customize, options.customize)
      });
      if (options.cssLayer && withLayer) {
        return `@layer ${options.cssLayer} { ${css} }`;
      }
      return css;
    }
    onServerPrefetch(async () => {
      {
        const configs = (/* @__PURE__ */ useRuntimeConfig()).icon || {};
        if (!configs?.serverKnownCssClasses?.includes(cssClass.value)) {
          const icon = await loadIcon(props.name, options.fetchTimeout).catch(() => null);
          if (!icon)
            return null;
          let ssrCSS = nuxt.vueApp._context.provides[SYMBOL_SERVER_CSS];
          if (!ssrCSS) {
            ssrCSS = nuxt.vueApp._context.provides[SYMBOL_SERVER_CSS] = /* @__PURE__ */ new Map();
            nuxt.runWithContext(() => {
              useHead({
                style: [
                  () => {
                    const sep = "";
                    let css = Array.from(ssrCSS.values()).sort().join(sep);
                    if (options.cssLayer) {
                      css = `@layer ${options.cssLayer} {${sep}${css}${sep}}`;
                    }
                    return { innerHTML: css };
                  }
                ]
              }, {
                tagPriority: "low"
              });
            });
          }
          if (props.name && !ssrCSS.has(props.name)) {
            const css = getCSS(icon, false);
            ssrCSS.set(props.name, css);
          }
          return null;
        }
      }
    });
    return () => h("span", { class: ["iconify", cssClass.value] });
  }
});
const NuxtIconSvg = /* @__PURE__ */ defineComponent({
  name: "NuxtIconSvg",
  props: {
    name: {
      type: String,
      required: true
    },
    customize: {
      type: [Function, Boolean, null],
      default: null,
      required: false
    }
  },
  setup(props, { slots }) {
    useNuxtApp();
    const options = useAppConfig().icon;
    const name2 = useResolvedName(() => props.name);
    const storeKey = "i-" + name2.value;
    if (name2.value) {
      onServerPrefetch(async () => {
        {
          await useAsyncData(
            storeKey,
            async () => await loadIcon(name2.value, options.fetchTimeout),
            { deep: false }
          );
        }
      });
    }
    return () => h(Icon, {
      icon: name2.value,
      ssr: true,
      // Iconify uses `customise`, where we expose `customize` for consistency
      customise: resolveCustomizeFn(props.customize, options.customize)
    }, slots);
  }
});
const __nuxt_component_0$4 = defineComponent({
  name: "NuxtIcon",
  props: {
    name: {
      type: String,
      required: true
    },
    mode: {
      type: String,
      required: false,
      default: null
    },
    size: {
      type: [Number, String],
      required: false,
      default: null
    },
    customize: {
      type: [Function, Boolean, null],
      default: null,
      required: false
    }
  },
  setup(props, { slots }) {
    const nuxtApp = useNuxtApp();
    const runtimeOptions = useAppConfig().icon;
    const name2 = useResolvedName(() => props.name);
    const component = computed(
      () => nuxtApp.vueApp?.component(name2.value) || ((props.mode || runtimeOptions.mode) === "svg" ? NuxtIconSvg : NuxtIconCss)
    );
    const style2 = computed(() => {
      const size = props.size || runtimeOptions.size;
      return size ? { fontSize: Number.isNaN(+size) ? size : size + "px" } : null;
    });
    return () => h(
      component.value,
      {
        ...runtimeOptions.attrs,
        name: name2.value,
        class: runtimeOptions.class,
        style: style2.value,
        customize: props.customize
      },
      slots
    );
  }
});
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __nuxt_component_0$4
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$B = {
  __name: "UIcon",
  __ssrInlineRender: true,
  props: {
    name: { type: null, required: true },
    mode: { type: String, required: false },
    size: { type: [String, Number], required: false },
    customize: { type: Function, required: false }
  },
  setup(__props) {
    const props = __props;
    const iconProps = useForwardProps(reactivePick(props, "name", "mode", "size", "customize"));
    return (_ctx, _push, _parent, _attrs) => {
      const _component_Icon = __nuxt_component_0$4;
      if (typeof __props.name === "string") {
        _push(ssrRenderComponent(_component_Icon, mergeProps(unref(iconProps), _attrs), null, _parent));
      } else {
        ssrRenderVNode(_push, createVNode(resolveDynamicComponent(__props.name), _attrs, null), _parent);
      }
    };
  }
};
const _sfc_setup$A = _sfc_main$B.setup;
_sfc_main$B.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/@nuxt+ui@4.3.0_ce70e36b2b2e96ffad445540e21eec42/node_modules/@nuxt/ui/dist/runtime/components/Icon.vue");
  return _sfc_setup$A ? _sfc_setup$A(props, ctx) : void 0;
};
async function imageMeta(_ctx, url) {
  const meta = await _imageMeta(url).catch((err) => {
    console.error("Failed to get image meta for " + url, err + "");
    return {
      width: 0,
      height: 0,
      ratio: 0
    };
  });
  return meta;
}
async function _imageMeta(url) {
  {
    const imageMeta2 = await import('./index-mH_0pvGP.mjs').then((r) => r.imageMeta);
    const data = await fetch(url).then((res) => res.buffer());
    const metadata2 = imageMeta2(data);
    if (!metadata2) {
      throw new Error(`No metadata could be extracted from the image \`${url}\`.`);
    }
    const { width, height } = metadata2;
    const meta = {
      width,
      height,
      ratio: width && height ? width / height : void 0
    };
    return meta;
  }
}
function createMapper(map) {
  return (key) => {
    return key ? map[key] || key : map.missingValue;
  };
}
function createOperationsGenerator({ formatter, keyMap, joinWith = "/", valueMap } = {}) {
  if (!formatter) {
    formatter = (key, value) => `${key}=${value}`;
  }
  if (keyMap && typeof keyMap !== "function") {
    keyMap = createMapper(keyMap);
  }
  const map = valueMap || {};
  Object.keys(map).forEach((valueKey) => {
    if (typeof map[valueKey] !== "function") {
      map[valueKey] = createMapper(map[valueKey]);
    }
  });
  return (modifiers = {}) => {
    const operations = Object.entries(modifiers).filter(([_2, value]) => typeof value !== "undefined").map(([key, value]) => {
      const mapper = map[key];
      if (typeof mapper === "function") {
        value = mapper(modifiers[key]);
      }
      key = typeof keyMap === "function" ? keyMap(key) : key;
      return formatter(key, value);
    });
    return operations.join(joinWith);
  };
}
function parseSize(input = "") {
  if (typeof input === "number") {
    return input;
  }
  if (typeof input === "string") {
    if (input.replace("px", "").match(/^\d+$/g)) {
      return Number.parseInt(input, 10);
    }
  }
}
function parseDensities(input = "") {
  if (input === void 0 || !input.length) {
    return [];
  }
  const densities = /* @__PURE__ */ new Set();
  for (const density of input.split(" ")) {
    const d = Number.parseInt(density.replace("x", ""));
    if (d) {
      densities.add(d);
    }
  }
  return Array.from(densities);
}
function checkDensities(densities) {
  if (densities.length === 0) {
    throw new Error("`densities` must not be empty, configure to `1` to render regular size only (DPR 1.0)");
  }
}
function parseSizes(input) {
  const sizes = {};
  if (typeof input === "string") {
    for (const entry2 of input.split(/[\s,]+/).filter((e) => e)) {
      const s = entry2.split(":");
      if (s.length !== 2) {
        sizes["1px"] = s[0].trim();
      } else {
        sizes[s[0].trim()] = s[1].trim();
      }
    }
  } else {
    Object.assign(sizes, input);
  }
  return sizes;
}
function createImage(globalOptions) {
  const ctx = {
    options: globalOptions
  };
  const getImage2 = (input, options = {}) => {
    const image = resolveImage(ctx, input, options);
    return image;
  };
  const $img = (input, modifiers = {}, options = {}) => {
    return getImage2(input, {
      ...options,
      modifiers: defu(modifiers, options.modifiers || {})
    }).url;
  };
  for (const presetName in globalOptions.presets) {
    $img[presetName] = (source, modifiers, options) => $img(source, modifiers, { ...globalOptions.presets[presetName], ...options });
  }
  $img.options = globalOptions;
  $img.getImage = getImage2;
  $img.getMeta = (input, options) => getMeta(ctx, input, options);
  $img.getSizes = (input, options) => getSizes(ctx, input, options);
  ctx.$img = $img;
  return $img;
}
async function getMeta(ctx, input, options) {
  const image = resolveImage(ctx, input, { ...options });
  if (typeof image.getMeta === "function") {
    return await image.getMeta();
  } else {
    return await imageMeta(ctx, image.url);
  }
}
function resolveImage(ctx, input, options) {
  if (input && typeof input !== "string") {
    throw new TypeError(`input must be a string (received ${typeof input}: ${JSON.stringify(input)})`);
  }
  if (!input || input.startsWith("data:")) {
    return {
      url: input
    };
  }
  const { provider, defaults } = getProvider(ctx, options.provider || ctx.options.provider);
  const preset = getPreset(ctx, options.preset);
  input = hasProtocol(input) ? input : withLeadingSlash(input);
  if (!provider.supportsAlias) {
    for (const base in ctx.options.alias) {
      if (input.startsWith(base)) {
        const alias = ctx.options.alias[base];
        if (alias) {
          input = joinURL(alias, input.slice(base.length));
        }
      }
    }
  }
  if (provider.validateDomains && hasProtocol(input)) {
    const inputHost = parseURL(input).host;
    if (!ctx.options.domains.find((d) => d === inputHost)) {
      return {
        url: input
      };
    }
  }
  const _options = defu(options, preset, defaults);
  _options.modifiers = { ..._options.modifiers };
  const expectedFormat = _options.modifiers.format;
  if (_options.modifiers?.width) {
    _options.modifiers.width = parseSize(_options.modifiers.width);
  }
  if (_options.modifiers?.height) {
    _options.modifiers.height = parseSize(_options.modifiers.height);
  }
  const image = provider.getImage(input, _options, ctx);
  image.format = image.format || expectedFormat || "";
  return image;
}
function getProvider(ctx, name2) {
  const provider = ctx.options.providers[name2];
  if (!provider) {
    throw new Error("Unknown provider: " + name2);
  }
  return provider;
}
function getPreset(ctx, name2) {
  if (!name2) {
    return {};
  }
  if (!ctx.options.presets[name2]) {
    throw new Error("Unknown preset: " + name2);
  }
  return ctx.options.presets[name2];
}
function getSizes(ctx, input, opts) {
  const width = parseSize(opts.modifiers?.width);
  const height = parseSize(opts.modifiers?.height);
  const sizes = parseSizes(opts.sizes);
  const densities = opts.densities?.trim() ? parseDensities(opts.densities.trim()) : ctx.options.densities;
  checkDensities(densities);
  const hwRatio = width && height ? height / width : 0;
  const sizeVariants = [];
  const srcsetVariants = [];
  if (Object.keys(sizes).length >= 1) {
    for (const key in sizes) {
      const variant = getSizesVariant(key, String(sizes[key]), height, hwRatio, ctx);
      if (variant === void 0) {
        continue;
      }
      sizeVariants.push({
        size: variant.size,
        screenMaxWidth: variant.screenMaxWidth,
        media: `(max-width: ${variant.screenMaxWidth}px)`
      });
      for (const density of densities) {
        srcsetVariants.push({
          width: variant._cWidth * density,
          src: getVariantSrc(ctx, input, opts, variant, density)
        });
      }
    }
    finaliseSizeVariants(sizeVariants);
  } else {
    for (const density of densities) {
      const key = Object.keys(sizes)[0];
      let variant = key ? getSizesVariant(key, String(sizes[key]), height, hwRatio, ctx) : void 0;
      if (variant === void 0) {
        variant = {
          size: "",
          screenMaxWidth: 0,
          _cWidth: opts.modifiers?.width,
          _cHeight: opts.modifiers?.height
        };
      }
      srcsetVariants.push({
        width: density,
        src: getVariantSrc(ctx, input, opts, variant, density)
      });
    }
  }
  finaliseSrcsetVariants(srcsetVariants);
  const defaultVariant = srcsetVariants[srcsetVariants.length - 1];
  const sizesVal = sizeVariants.length ? sizeVariants.map((v) => `${v.media ? v.media + " " : ""}${v.size}`).join(", ") : void 0;
  const suffix = sizesVal ? "w" : "x";
  const srcsetVal = srcsetVariants.map((v) => `${v.src} ${v.width}${suffix}`).join(", ");
  return {
    sizes: sizesVal,
    srcset: srcsetVal,
    src: defaultVariant?.src
  };
}
function getSizesVariant(key, size, height, hwRatio, ctx) {
  const screenMaxWidth = ctx.options.screens && ctx.options.screens[key] || Number.parseInt(key);
  const isFluid = size.endsWith("vw");
  if (!isFluid && /^\d+$/.test(size)) {
    size = size + "px";
  }
  if (!isFluid && !size.endsWith("px")) {
    return void 0;
  }
  let _cWidth = Number.parseInt(size);
  if (!screenMaxWidth || !_cWidth) {
    return void 0;
  }
  if (isFluid) {
    _cWidth = Math.round(_cWidth / 100 * screenMaxWidth);
  }
  const _cHeight = hwRatio ? Math.round(_cWidth * hwRatio) : height;
  return {
    size,
    screenMaxWidth,
    _cWidth,
    _cHeight
  };
}
function getVariantSrc(ctx, input, opts, variant, density) {
  return ctx.$img(
    input,
    {
      ...opts.modifiers,
      width: variant._cWidth ? variant._cWidth * density : void 0,
      height: variant._cHeight ? variant._cHeight * density : void 0
    },
    opts
  );
}
function finaliseSizeVariants(sizeVariants) {
  sizeVariants.sort((v1, v2) => v1.screenMaxWidth - v2.screenMaxWidth);
  let previousMedia = null;
  for (let i = sizeVariants.length - 1; i >= 0; i--) {
    const sizeVariant = sizeVariants[i];
    if (sizeVariant.media === previousMedia) {
      sizeVariants.splice(i, 1);
    }
    previousMedia = sizeVariant.media;
  }
  for (let i = 0; i < sizeVariants.length; i++) {
    sizeVariants[i].media = sizeVariants[i + 1]?.media || "";
  }
}
function finaliseSrcsetVariants(srcsetVariants) {
  srcsetVariants.sort((v1, v2) => v1.width - v2.width);
  let previousWidth = null;
  for (let i = srcsetVariants.length - 1; i >= 0; i--) {
    const sizeVariant = srcsetVariants[i];
    if (sizeVariant.width === previousWidth) {
      srcsetVariants.splice(i, 1);
    }
    previousWidth = sizeVariant.width;
  }
}
const operationsGenerator = createOperationsGenerator({
  keyMap: {
    format: "f",
    fit: "fit",
    width: "w",
    height: "h",
    resize: "s",
    quality: "q",
    background: "b"
  },
  joinWith: "&",
  formatter: (key, val) => encodeParam(key) + "_" + encodeParam(val)
});
const getImage = (src, { modifiers = {}, baseURL: baseURL2 } = {}, ctx) => {
  if (modifiers.width && modifiers.height) {
    modifiers.resize = `${modifiers.width}x${modifiers.height}`;
    delete modifiers.width;
    delete modifiers.height;
  }
  const params = operationsGenerator(modifiers) || "_";
  if (!baseURL2) {
    baseURL2 = joinURL(ctx.options.nuxt.baseURL, "/_ipx");
  }
  return {
    url: joinURL(baseURL2, params, encodePath(src))
  };
};
const validateDomains = true;
const supportsAlias = true;
const ipxRuntime$_9gmkZJeT4coZ5C1Qh877o9YJbXqtJROq8vXeiNwNnhI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getImage,
  operationsGenerator,
  supportsAlias,
  validateDomains
}, Symbol.toStringTag, { value: "Module" }));
const imageOptions = {
  ...{
    "screens": {
      "xs": 320,
      "sm": 640,
      "md": 768,
      "lg": 1024,
      "xl": 1280,
      "xxl": 1536,
      "2xl": 1536
    },
    "presets": {},
    "provider": "ipx",
    "domains": [],
    "alias": {},
    "densities": [
      1,
      2
    ],
    "format": [
      "webp"
    ]
  },
  providers: {
    ["ipx"]: { provider: ipxRuntime$_9gmkZJeT4coZ5C1Qh877o9YJbXqtJROq8vXeiNwNnhI, defaults: {} }
  }
};
const useImage = (event) => {
  const config = /* @__PURE__ */ useRuntimeConfig();
  const nuxtApp = useNuxtApp();
  return nuxtApp.$img || nuxtApp._img || (nuxtApp._img = createImage({
    ...imageOptions,
    event: nuxtApp.ssrContext?.event,
    nuxt: {
      baseURL: config.app.baseURL
    },
    runtimeConfig: config
  }));
};
const baseImageProps = {
  // input source
  src: { type: String, required: false },
  // modifiers
  format: { type: String, required: false },
  quality: { type: [Number, String], required: false },
  background: { type: String, required: false },
  fit: { type: String, required: false },
  modifiers: { type: Object, required: false },
  // options
  preset: { type: String, required: false },
  provider: { type: String, required: false },
  sizes: { type: [Object, String], required: false },
  densities: { type: String, required: false },
  preload: {
    type: [Boolean, Object],
    required: false
  },
  // <img> attributes
  width: { type: [String, Number], required: false },
  height: { type: [String, Number], required: false },
  alt: { type: String, required: false },
  referrerpolicy: { type: String, required: false },
  usemap: { type: String, required: false },
  longdesc: { type: String, required: false },
  ismap: { type: Boolean, required: false },
  loading: {
    type: String,
    required: false,
    validator: (val) => ["lazy", "eager"].includes(val)
  },
  crossorigin: {
    type: [Boolean, String],
    required: false,
    validator: (val) => ["anonymous", "use-credentials", "", true, false].includes(val)
  },
  decoding: {
    type: String,
    required: false,
    validator: (val) => ["async", "auto", "sync"].includes(val)
  },
  // csp
  nonce: { type: [String], required: false }
};
const useBaseImage = (props) => {
  const options = computed(() => {
    return {
      provider: props.provider,
      preset: props.preset
    };
  });
  const attrs = computed(() => {
    return {
      width: parseSize(props.width),
      height: parseSize(props.height),
      alt: props.alt,
      referrerpolicy: props.referrerpolicy,
      usemap: props.usemap,
      longdesc: props.longdesc,
      ismap: props.ismap,
      crossorigin: props.crossorigin === true ? "anonymous" : props.crossorigin || void 0,
      loading: props.loading,
      decoding: props.decoding,
      nonce: props.nonce
    };
  });
  const $img = useImage();
  const modifiers = computed(() => {
    return {
      ...props.modifiers,
      width: parseSize(props.width),
      height: parseSize(props.height),
      format: props.format,
      quality: props.quality || $img.options.quality,
      background: props.background,
      fit: props.fit
    };
  });
  return {
    options,
    attrs,
    modifiers
  };
};
const imgProps = {
  ...baseImageProps,
  placeholder: { type: [Boolean, String, Number, Array], required: false },
  placeholderClass: { type: String, required: false },
  custom: { type: Boolean, required: false }
};
const _sfc_main$A = /* @__PURE__ */ defineComponent({
  __name: "NuxtImg",
  __ssrInlineRender: true,
  props: imgProps,
  emits: ["load", "error"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const attrs = useAttrs();
    const isServer = true;
    const $img = useImage();
    const _base = useBaseImage(props);
    const placeholderLoaded = ref(false);
    const imgEl = ref();
    const sizes = computed(() => $img.getSizes(props.src, {
      ..._base.options.value,
      sizes: props.sizes,
      densities: props.densities,
      modifiers: {
        ..._base.modifiers.value,
        width: parseSize(props.width),
        height: parseSize(props.height)
      }
    }));
    const imgAttrs = computed(() => {
      const attrs2 = { ..._base.attrs.value, "data-nuxt-img": "" };
      if (!props.placeholder || placeholderLoaded.value) {
        attrs2.sizes = sizes.value.sizes;
        attrs2.srcset = sizes.value.srcset;
      }
      return attrs2;
    });
    const placeholder = computed(() => {
      let placeholder2 = props.placeholder;
      if (placeholder2 === "") {
        placeholder2 = true;
      }
      if (!placeholder2 || placeholderLoaded.value) {
        return false;
      }
      if (typeof placeholder2 === "string") {
        return placeholder2;
      }
      const size = Array.isArray(placeholder2) ? placeholder2 : typeof placeholder2 === "number" ? [placeholder2, placeholder2] : [10, 10];
      return $img(props.src, {
        ..._base.modifiers.value,
        width: size[0],
        height: size[1],
        quality: size[2] || 50,
        blur: size[3] || 3
      }, _base.options.value);
    });
    const mainSrc = computed(
      () => props.sizes ? sizes.value.src : $img(props.src, _base.modifiers.value, _base.options.value)
    );
    const src = computed(() => placeholder.value ? placeholder.value : mainSrc.value);
    if (props.preload) {
      const isResponsive = Object.values(sizes.value).every((v) => v);
      useHead({
        link: [{
          rel: "preload",
          as: "image",
          nonce: props.nonce,
          ...!isResponsive ? { href: src.value } : {
            href: sizes.value.src,
            imagesizes: sizes.value.sizes,
            imagesrcset: sizes.value.srcset
          },
          ...typeof props.preload !== "boolean" && props.preload.fetchPriority ? { fetchpriority: props.preload.fetchPriority } : {}
        }]
      });
    }
    const nuxtApp = useNuxtApp();
    nuxtApp.isHydrating;
    return (_ctx, _push, _parent, _attrs) => {
      if (!_ctx.custom) {
        _push(`<img${ssrRenderAttrs(mergeProps({
          ref_key: "imgEl",
          ref: imgEl,
          class: placeholder.value && !placeholderLoaded.value ? _ctx.placeholderClass : void 0
        }, {
          ...unref(isServer) ? { onerror: "this.setAttribute('data-error', 1)" } : {},
          ...imgAttrs.value,
          ...unref(attrs)
        }, { src: src.value }, _attrs))}>`);
      } else {
        ssrRenderSlot(_ctx.$slots, "default", {
          ...unref(isServer) ? { onerror: "this.setAttribute('data-error', 1)" } : {},
          imgAttrs: {
            ...imgAttrs.value,
            ...unref(attrs)
          },
          isLoaded: placeholderLoaded.value,
          src: src.value
        }, null, _push, _parent);
      }
    };
  }
});
const _sfc_setup$z = _sfc_main$A.setup;
_sfc_main$A.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/@nuxt+image@1.11.0_db0@0.3.4_better-sqlite3@12.5.0_drizzle-orm@0.44.7_@cloudflare+worke_5886db073ec5b512e225e21b22b6101b/node_modules/@nuxt/image/dist/runtime/components/NuxtImg.vue");
  return _sfc_setup$z ? _sfc_setup$z(props, ctx) : void 0;
};
const ImageComponent = Object.assign(_sfc_main$A, { __name: "NuxtImg" });
const avatarGroupInjectionKey = /* @__PURE__ */ Symbol("nuxt-ui.avatar-group");
function useAvatarGroup(props) {
  const avatarGroup = inject(avatarGroupInjectionKey, void 0);
  const size = computed(() => props.size ?? avatarGroup?.value.size);
  provide(avatarGroupInjectionKey, computed(() => ({ size: size.value })));
  return {
    size
  };
}
const theme$7 = {
  "slots": {
    "root": "relative inline-flex items-center justify-center shrink-0",
    "base": "rounded-full ring ring-bg flex items-center justify-center text-inverted font-medium whitespace-nowrap"
  },
  "variants": {
    "color": {
      "primary": "bg-primary",
      "secondary": "bg-secondary",
      "success": "bg-success",
      "info": "bg-info",
      "warning": "bg-warning",
      "error": "bg-error",
      "neutral": "bg-inverted"
    },
    "size": {
      "3xs": "h-[4px] min-w-[4px] text-[4px]",
      "2xs": "h-[5px] min-w-[5px] text-[5px]",
      "xs": "h-[6px] min-w-[6px] text-[6px]",
      "sm": "h-[7px] min-w-[7px] text-[7px]",
      "md": "h-[8px] min-w-[8px] text-[8px]",
      "lg": "h-[9px] min-w-[9px] text-[9px]",
      "xl": "h-[10px] min-w-[10px] text-[10px]",
      "2xl": "h-[11px] min-w-[11px] text-[11px]",
      "3xl": "h-[12px] min-w-[12px] text-[12px]"
    },
    "position": {
      "top-right": "top-0 right-0",
      "bottom-right": "bottom-0 right-0",
      "top-left": "top-0 left-0",
      "bottom-left": "bottom-0 left-0"
    },
    "inset": {
      "false": ""
    },
    "standalone": {
      "false": "absolute"
    }
  },
  "compoundVariants": [
    {
      "position": "top-right",
      "inset": false,
      "class": "-translate-y-1/2 translate-x-1/2 transform"
    },
    {
      "position": "bottom-right",
      "inset": false,
      "class": "translate-y-1/2 translate-x-1/2 transform"
    },
    {
      "position": "top-left",
      "inset": false,
      "class": "-translate-y-1/2 -translate-x-1/2 transform"
    },
    {
      "position": "bottom-left",
      "inset": false,
      "class": "translate-y-1/2 -translate-x-1/2 transform"
    }
  ],
  "defaultVariants": {
    "size": "md",
    "color": "primary",
    "position": "top-right"
  }
};
const _sfc_main$z = /* @__PURE__ */ Object.assign({ inheritAttrs: false }, {
  __name: "UChip",
  __ssrInlineRender: true,
  props: /* @__PURE__ */ mergeModels({
    as: { type: null, required: false },
    text: { type: [String, Number], required: false },
    color: { type: null, required: false },
    size: { type: null, required: false },
    position: { type: null, required: false },
    inset: { type: Boolean, required: false, default: false },
    standalone: { type: Boolean, required: false, default: false },
    class: { type: null, required: false },
    ui: { type: null, required: false }
  }, {
    "show": { type: Boolean, ...{ default: true } },
    "showModifiers": {}
  }),
  emits: ["update:show"],
  setup(__props) {
    const props = __props;
    const show = useModel(__props, "show", { type: Boolean, ...{ default: true } });
    const { size } = useAvatarGroup(props);
    const appConfig2 = useAppConfig();
    const ui = computed(() => tv({ extend: tv(theme$7), ...appConfig2.ui?.chip || {} })({
      color: props.color,
      size: size.value,
      position: props.position,
      inset: props.inset,
      standalone: props.standalone
    }));
    return (_ctx, _push, _parent, _attrs) => {
      _push(ssrRenderComponent(unref(Primitive), mergeProps({
        as: __props.as,
        "data-slot": "root",
        class: ui.value.root({ class: [props.ui?.root, props.class] })
      }, _attrs), {
        default: withCtx((_2, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent(unref(Slot), _ctx.$attrs, {
              default: withCtx((_3, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  ssrRenderSlot(_ctx.$slots, "default", {}, null, _push3, _parent3, _scopeId2);
                } else {
                  return [
                    renderSlot(_ctx.$slots, "default")
                  ];
                }
              }),
              _: 3
            }, _parent2, _scopeId));
            if (show.value) {
              _push2(`<span data-slot="base" class="${ssrRenderClass(ui.value.base({ class: props.ui?.base }))}"${_scopeId}>`);
              ssrRenderSlot(_ctx.$slots, "content", {}, () => {
                _push2(`${ssrInterpolate(__props.text)}`);
              }, _push2, _parent2, _scopeId);
              _push2(`</span>`);
            } else {
              _push2(`<!---->`);
            }
          } else {
            return [
              createVNode(unref(Slot), _ctx.$attrs, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default")
                ]),
                _: 3
              }, 16),
              show.value ? (openBlock(), createBlock("span", {
                key: 0,
                "data-slot": "base",
                class: ui.value.base({ class: props.ui?.base })
              }, [
                renderSlot(_ctx.$slots, "content", {}, () => [
                  createTextVNode(toDisplayString$1(__props.text), 1)
                ])
              ], 2)) : createCommentVNode("", true)
            ];
          }
        }),
        _: 3
      }, _parent));
    };
  }
});
const _sfc_setup$y = _sfc_main$z.setup;
_sfc_main$z.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/@nuxt+ui@4.3.0_ce70e36b2b2e96ffad445540e21eec42/node_modules/@nuxt/ui/dist/runtime/components/Chip.vue");
  return _sfc_setup$y ? _sfc_setup$y(props, ctx) : void 0;
};
const theme$6 = {
  "slots": {
    "root": "inline-flex items-center justify-center shrink-0 select-none rounded-full align-middle bg-elevated",
    "image": "h-full w-full rounded-[inherit] object-cover",
    "fallback": "font-medium leading-none text-muted truncate",
    "icon": "text-muted shrink-0"
  },
  "variants": {
    "size": {
      "3xs": {
        "root": "size-4 text-[8px]"
      },
      "2xs": {
        "root": "size-5 text-[10px]"
      },
      "xs": {
        "root": "size-6 text-xs"
      },
      "sm": {
        "root": "size-7 text-sm"
      },
      "md": {
        "root": "size-8 text-base"
      },
      "lg": {
        "root": "size-9 text-lg"
      },
      "xl": {
        "root": "size-10 text-xl"
      },
      "2xl": {
        "root": "size-11 text-[22px]"
      },
      "3xl": {
        "root": "size-12 text-2xl"
      }
    }
  },
  "defaultVariants": {
    "size": "md"
  }
};
const _sfc_main$y = /* @__PURE__ */ Object.assign({ inheritAttrs: false }, {
  __name: "UAvatar",
  __ssrInlineRender: true,
  props: {
    as: { type: null, required: false },
    src: { type: String, required: false },
    alt: { type: String, required: false },
    icon: { type: null, required: false },
    text: { type: String, required: false },
    size: { type: null, required: false },
    chip: { type: [Boolean, Object], required: false },
    class: { type: null, required: false },
    style: { type: null, required: false },
    ui: { type: null, required: false }
  },
  setup(__props) {
    const props = __props;
    const as = computed(() => {
      if (typeof props.as === "string" || typeof props.as?.render === "function") {
        return { root: props.as };
      }
      return defu(props.as, { root: "span" });
    });
    const fallback = computed(() => props.text || (props.alt || "").split(" ").map((word) => word.charAt(0)).join("").substring(0, 2));
    const appConfig2 = useAppConfig();
    const { size } = useAvatarGroup(props);
    const ui = computed(() => tv({ extend: tv(theme$6), ...appConfig2.ui?.avatar || {} })({
      size: size.value
    }));
    const sizePx = computed(() => ({
      "3xs": 16,
      "2xs": 20,
      "xs": 24,
      "sm": 28,
      "md": 32,
      "lg": 36,
      "xl": 40,
      "2xl": 44,
      "3xl": 48
    })[props.size || "md"]);
    const error = ref(false);
    watch(() => props.src, () => {
      if (error.value) {
        error.value = false;
      }
    });
    function onError() {
      error.value = true;
    }
    return (_ctx, _push, _parent, _attrs) => {
      ssrRenderVNode(_push, createVNode(resolveDynamicComponent(props.chip ? _sfc_main$z : unref(Primitive)), mergeProps({
        as: as.value.root
      }, props.chip ? typeof props.chip === "object" ? { inset: true, ...props.chip } : { inset: true } : {}, {
        "data-slot": "root",
        class: ui.value.root({ class: [props.ui?.root, props.class] }),
        style: props.style
      }, _attrs), {
        default: withCtx((_2, _push2, _parent2, _scopeId) => {
          if (_push2) {
            if (__props.src && !error.value) {
              ssrRenderVNode(_push2, createVNode(resolveDynamicComponent(as.value.img || unref(ImageComponent)), mergeProps({
                src: __props.src,
                alt: __props.alt,
                width: sizePx.value,
                height: sizePx.value
              }, _ctx.$attrs, {
                "data-slot": "image",
                class: ui.value.image({ class: props.ui?.image }),
                onError
              }), null), _parent2, _scopeId);
            } else {
              _push2(ssrRenderComponent(unref(Slot), _ctx.$attrs, {
                default: withCtx((_3, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    ssrRenderSlot(_ctx.$slots, "default", {}, () => {
                      if (__props.icon) {
                        _push3(ssrRenderComponent(_sfc_main$B, {
                          name: __props.icon,
                          "data-slot": "icon",
                          class: ui.value.icon({ class: props.ui?.icon })
                        }, null, _parent3, _scopeId2));
                      } else {
                        _push3(`<span data-slot="fallback" class="${ssrRenderClass(ui.value.fallback({ class: props.ui?.fallback }))}"${_scopeId2}>${ssrInterpolate(fallback.value || " ")}</span>`);
                      }
                    }, _push3, _parent3, _scopeId2);
                  } else {
                    return [
                      renderSlot(_ctx.$slots, "default", {}, () => [
                        __props.icon ? (openBlock(), createBlock(_sfc_main$B, {
                          key: 0,
                          name: __props.icon,
                          "data-slot": "icon",
                          class: ui.value.icon({ class: props.ui?.icon })
                        }, null, 8, ["name", "class"])) : (openBlock(), createBlock("span", {
                          key: 1,
                          "data-slot": "fallback",
                          class: ui.value.fallback({ class: props.ui?.fallback })
                        }, toDisplayString$1(fallback.value || " "), 3))
                      ])
                    ];
                  }
                }),
                _: 3
              }, _parent2, _scopeId));
            }
          } else {
            return [
              __props.src && !error.value ? (openBlock(), createBlock(resolveDynamicComponent(as.value.img || unref(ImageComponent)), mergeProps({
                key: 0,
                src: __props.src,
                alt: __props.alt,
                width: sizePx.value,
                height: sizePx.value
              }, _ctx.$attrs, {
                "data-slot": "image",
                class: ui.value.image({ class: props.ui?.image }),
                onError
              }), null, 16, ["src", "alt", "width", "height", "class"])) : (openBlock(), createBlock(unref(Slot), mergeProps({ key: 1 }, _ctx.$attrs), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default", {}, () => [
                    __props.icon ? (openBlock(), createBlock(_sfc_main$B, {
                      key: 0,
                      name: __props.icon,
                      "data-slot": "icon",
                      class: ui.value.icon({ class: props.ui?.icon })
                    }, null, 8, ["name", "class"])) : (openBlock(), createBlock("span", {
                      key: 1,
                      "data-slot": "fallback",
                      class: ui.value.fallback({ class: props.ui?.fallback })
                    }, toDisplayString$1(fallback.value || " "), 3))
                  ])
                ]),
                _: 3
              }, 16))
            ];
          }
        }),
        _: 3
      }), _parent);
    };
  }
});
const _sfc_setup$x = _sfc_main$y.setup;
_sfc_main$y.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/@nuxt+ui@4.3.0_ce70e36b2b2e96ffad445540e21eec42/node_modules/@nuxt/ui/dist/runtime/components/Avatar.vue");
  return _sfc_setup$x ? _sfc_setup$x(props, ctx) : void 0;
};
function useComponentIcons(componentProps) {
  const appConfig2 = useAppConfig();
  const props = computed(() => toValue(componentProps));
  const isLeading = computed(() => props.value.icon && props.value.leading || props.value.icon && !props.value.trailing || props.value.loading && !props.value.trailing || !!props.value.leadingIcon);
  const isTrailing = computed(() => props.value.icon && props.value.trailing || props.value.loading && props.value.trailing || !!props.value.trailingIcon);
  const leadingIconName = computed(() => {
    if (props.value.loading) {
      return props.value.loadingIcon || appConfig2.ui.icons.loading;
    }
    return props.value.leadingIcon || props.value.icon;
  });
  const trailingIconName = computed(() => {
    if (props.value.loading && !isLeading.value) {
      return props.value.loadingIcon || appConfig2.ui.icons.loading;
    }
    return props.value.trailingIcon || props.value.icon;
  });
  return {
    isLeading,
    isTrailing,
    leadingIconName,
    trailingIconName
  };
}
const fieldGroupInjectionKey = /* @__PURE__ */ Symbol("nuxt-ui.field-group");
function useFieldGroup(props) {
  const fieldGroup = inject(fieldGroupInjectionKey, void 0);
  return {
    orientation: computed(() => fieldGroup?.value.orientation),
    size: computed(() => props?.size ?? fieldGroup?.value.size)
  };
}
const formOptionsInjectionKey = /* @__PURE__ */ Symbol("nuxt-ui.form-options");
const formBusInjectionKey = /* @__PURE__ */ Symbol("nuxt-ui.form-events");
const formStateInjectionKey = /* @__PURE__ */ Symbol("nuxt-ui.form-state");
const formFieldInjectionKey = /* @__PURE__ */ Symbol("nuxt-ui.form-field");
const inputIdInjectionKey = /* @__PURE__ */ Symbol("nuxt-ui.input-id");
const formInputsInjectionKey = /* @__PURE__ */ Symbol("nuxt-ui.form-inputs");
const formLoadingInjectionKey = /* @__PURE__ */ Symbol("nuxt-ui.form-loading");
const formErrorsInjectionKey = /* @__PURE__ */ Symbol("nuxt-ui.form-errors");
function useFormField(props, opts) {
  const formOptions = inject(formOptionsInjectionKey, void 0);
  const formBus = inject(formBusInjectionKey, void 0);
  const formField = inject(formFieldInjectionKey, void 0);
  const inputId = inject(inputIdInjectionKey, void 0);
  provide(formFieldInjectionKey, void 0);
  if (formField && inputId) {
    if (opts?.bind === false) {
      inputId.value = void 0;
    } else if (props?.id) {
      inputId.value = props?.id;
    }
  }
  function emitFormEvent(type, name2, eager) {
    if (formBus && formField && name2) {
      formBus.emit({ type, name: name2, eager });
    }
  }
  function emitFormBlur() {
    emitFormEvent("blur", formField?.value.name);
  }
  function emitFormFocus() {
    emitFormEvent("focus", formField?.value.name);
  }
  function emitFormChange() {
    emitFormEvent("change", formField?.value.name);
  }
  const emitFormInput = /* @__PURE__ */ useDebounceFn(
    () => {
      emitFormEvent("input", formField?.value.name, !opts?.deferInputValidation || formField?.value.eagerValidation);
    },
    formField?.value.validateOnInputDelay ?? formOptions?.value.validateOnInputDelay ?? 0
  );
  return {
    id: computed(() => props?.id ?? inputId?.value),
    name: computed(() => props?.name ?? formField?.value.name),
    size: computed(() => props?.size ?? formField?.value.size),
    color: computed(() => formField?.value.error ? "error" : props?.color),
    highlight: computed(() => formField?.value.error ? true : props?.highlight),
    disabled: computed(() => formOptions?.value.disabled || props?.disabled),
    emitFormBlur,
    emitFormInput,
    emitFormChange,
    emitFormFocus,
    ariaAttrs: computed(() => {
      if (!formField?.value) return;
      const descriptiveAttrs = ["error", "hint", "description", "help"].filter((type) => formField?.value?.[type]).map((type) => `${formField?.value.ariaId}-${type}`) || [];
      const attrs = {
        "aria-invalid": !!formField?.value.error
      };
      if (descriptiveAttrs.length > 0) {
        attrs["aria-describedby"] = descriptiveAttrs.join(" ");
      }
      return attrs;
    })
  };
}
const linkKeys = [
  "active",
  "activeClass",
  "ariaCurrentValue",
  "as",
  "disabled",
  "download",
  "exact",
  "exactActiveClass",
  "exactHash",
  "exactQuery",
  "external",
  "form",
  "formaction",
  "formenctype",
  "formmethod",
  "formnovalidate",
  "formtarget",
  "href",
  "hreflang",
  "inactiveClass",
  "media",
  "noPrefetch",
  "noRel",
  "onClick",
  "ping",
  "prefetch",
  "prefetchOn",
  "prefetchedClass",
  "referrerpolicy",
  "rel",
  "replace",
  "target",
  "title",
  "to",
  "trailingSlash",
  "type",
  "viewTransition"
];
function pickLinkProps(link) {
  const keys = Object.keys(link);
  const ariaKeys = keys.filter((key) => key.startsWith("aria-"));
  const dataKeys = keys.filter((key) => key.startsWith("data-"));
  const propsToInclude = [
    ...linkKeys,
    ...ariaKeys,
    ...dataKeys
  ];
  return reactivePick(link, ...propsToInclude);
}
function isPartiallyEqual(item1, item2) {
  const diffedKeys = diff(item1, item2).reduce((filtered, q2) => {
    if (q2.type === "added") {
      filtered.add(q2.key);
    }
    return filtered;
  }, /* @__PURE__ */ new Set());
  const item1Filtered = Object.fromEntries(Object.entries(item1).filter(([key]) => !diffedKeys.has(key)));
  const item2Filtered = Object.fromEntries(Object.entries(item2).filter(([key]) => !diffedKeys.has(key)));
  return isEqual$1(item1Filtered, item2Filtered);
}
const _sfc_main$x = {
  __name: "ULinkBase",
  __ssrInlineRender: true,
  props: {
    as: { type: String, required: false, default: "button" },
    type: { type: String, required: false, default: "button" },
    disabled: { type: Boolean, required: false },
    onClick: { type: [Function, Array], required: false },
    href: { type: String, required: false },
    navigate: { type: Function, required: false },
    target: { type: [String, Object, null], required: false },
    rel: { type: [String, Object, null], required: false },
    active: { type: Boolean, required: false },
    isExternal: { type: Boolean, required: false }
  },
  setup(__props) {
    const props = __props;
    function onClickWrapper(e) {
      if (props.disabled) {
        e.stopPropagation();
        e.preventDefault();
        return;
      }
      if (props.onClick) {
        for (const onClick of Array.isArray(props.onClick) ? props.onClick : [props.onClick]) {
          onClick(e);
        }
      }
      if (props.href && props.navigate && !props.isExternal) {
        props.navigate(e);
      }
    }
    return (_ctx, _push, _parent, _attrs) => {
      _push(ssrRenderComponent(unref(Primitive), mergeProps(__props.href ? {
        "as": "a",
        "href": __props.disabled ? void 0 : __props.href,
        "aria-disabled": __props.disabled ? "true" : void 0,
        "role": __props.disabled ? "link" : void 0,
        "tabindex": __props.disabled ? -1 : void 0
      } : __props.as === "button" ? {
        as: __props.as,
        type: __props.type,
        disabled: __props.disabled
      } : {
        as: __props.as
      }, {
        rel: __props.rel,
        target: __props.target,
        onClick: onClickWrapper
      }, _attrs), {
        default: withCtx((_2, _push2, _parent2, _scopeId) => {
          if (_push2) {
            ssrRenderSlot(_ctx.$slots, "default", {}, null, _push2, _parent2, _scopeId);
          } else {
            return [
              renderSlot(_ctx.$slots, "default")
            ];
          }
        }),
        _: 3
      }, _parent));
    };
  }
};
const _sfc_setup$w = _sfc_main$x.setup;
_sfc_main$x.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/@nuxt+ui@4.3.0_ce70e36b2b2e96ffad445540e21eec42/node_modules/@nuxt/ui/dist/runtime/components/LinkBase.vue");
  return _sfc_setup$w ? _sfc_setup$w(props, ctx) : void 0;
};
const theme$5 = {
  "base": "focus-visible:outline-primary",
  "variants": {
    "active": {
      "true": "text-primary",
      "false": "text-muted"
    },
    "disabled": {
      "true": "cursor-not-allowed opacity-75"
    }
  },
  "compoundVariants": [
    {
      "active": false,
      "disabled": false,
      "class": [
        "hover:text-default",
        "transition-colors"
      ]
    }
  ]
};
const _sfc_main$w = /* @__PURE__ */ Object.assign({ inheritAttrs: false }, {
  __name: "ULink",
  __ssrInlineRender: true,
  props: {
    as: { type: null, required: false, default: "button" },
    type: { type: null, required: false, default: "button" },
    disabled: { type: Boolean, required: false },
    active: { type: Boolean, required: false, default: void 0 },
    exact: { type: Boolean, required: false },
    exactQuery: { type: [Boolean, String], required: false },
    exactHash: { type: Boolean, required: false },
    inactiveClass: { type: String, required: false },
    custom: { type: Boolean, required: false },
    raw: { type: Boolean, required: false },
    class: { type: null, required: false },
    to: { type: null, required: false },
    href: { type: null, required: false },
    external: { type: Boolean, required: false },
    target: { type: [String, Object, null], required: false },
    rel: { type: [String, Object, null], required: false },
    noRel: { type: Boolean, required: false },
    prefetchedClass: { type: String, required: false },
    prefetch: { type: Boolean, required: false },
    prefetchOn: { type: [String, Object], required: false },
    noPrefetch: { type: Boolean, required: false },
    trailingSlash: { type: String, required: false },
    activeClass: { type: String, required: false },
    exactActiveClass: { type: String, required: false },
    ariaCurrentValue: { type: String, required: false, default: "page" },
    viewTransition: { type: Boolean, required: false },
    replace: { type: Boolean, required: false }
  },
  setup(__props) {
    const props = __props;
    const route = useRoute();
    const appConfig2 = useAppConfig();
    const nuxtLinkProps = useForwardProps(reactiveOmit(props, "as", "type", "disabled", "active", "exact", "exactQuery", "exactHash", "activeClass", "inactiveClass", "to", "href", "raw", "custom", "class"));
    const ui = computed(() => tv({
      extend: tv(theme$5),
      ...defu({
        variants: {
          active: {
            true: mergeClasses(appConfig2.ui?.link?.variants?.active?.true, props.activeClass),
            false: mergeClasses(appConfig2.ui?.link?.variants?.active?.false, props.inactiveClass)
          }
        }
      }, appConfig2.ui?.link || {})
    }));
    const to = computed(() => props.to ?? props.href);
    function isLinkActive({ route: linkRoute, isActive, isExactActive }) {
      if (props.active !== void 0) {
        return props.active;
      }
      if (props.exactQuery === "partial") {
        if (!isPartiallyEqual(linkRoute.query, route.query)) return false;
      } else if (props.exactQuery === true) {
        if (!isEqual$1(linkRoute.query, route.query)) return false;
      }
      if (props.exactHash && linkRoute.hash !== route.hash) {
        return false;
      }
      if (props.exact && isExactActive) {
        return true;
      }
      if (!props.exact && isActive) {
        return true;
      }
      return false;
    }
    function resolveLinkClass({ route: route2, isActive, isExactActive }) {
      const active = isLinkActive({ route: route2, isActive, isExactActive });
      if (props.raw) {
        return [props.class, active ? props.activeClass : props.inactiveClass];
      }
      return ui.value({ class: props.class, active, disabled: props.disabled });
    }
    return (_ctx, _push, _parent, _attrs) => {
      const _component_NuxtLink = __nuxt_component_0$5;
      _push(ssrRenderComponent(_component_NuxtLink, mergeProps(unref(nuxtLinkProps), {
        to: to.value,
        custom: ""
      }, _attrs), {
        default: withCtx(({ href, navigate: navigate2, route: linkRoute, rel, target, isExternal, isActive, isExactActive }, _push2, _parent2, _scopeId) => {
          if (_push2) {
            if (__props.custom) {
              ssrRenderSlot(_ctx.$slots, "default", {
                ..._ctx.$attrs,
                ...__props.exact && isExactActive ? { "aria-current": props.ariaCurrentValue } : {},
                as: __props.as,
                type: __props.type,
                disabled: __props.disabled,
                href,
                navigate: navigate2,
                rel,
                target,
                isExternal,
                active: isLinkActive({ route: linkRoute, isActive, isExactActive })
              }, null, _push2, _parent2, _scopeId);
            } else {
              _push2(ssrRenderComponent(_sfc_main$x, mergeProps({
                ..._ctx.$attrs,
                ...__props.exact && isExactActive ? { "aria-current": props.ariaCurrentValue } : {},
                as: __props.as,
                type: __props.type,
                disabled: __props.disabled,
                href,
                navigate: navigate2,
                rel,
                target,
                isExternal
              }, {
                class: resolveLinkClass({ route: linkRoute, isActive, isExactActive })
              }), {
                default: withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    ssrRenderSlot(_ctx.$slots, "default", {
                      active: isLinkActive({ route: linkRoute, isActive, isExactActive })
                    }, null, _push3, _parent3, _scopeId2);
                  } else {
                    return [
                      renderSlot(_ctx.$slots, "default", {
                        active: isLinkActive({ route: linkRoute, isActive, isExactActive })
                      })
                    ];
                  }
                }),
                _: 2
              }, _parent2, _scopeId));
            }
          } else {
            return [
              __props.custom ? renderSlot(_ctx.$slots, "default", mergeProps({ key: 0 }, {
                ..._ctx.$attrs,
                ...__props.exact && isExactActive ? { "aria-current": props.ariaCurrentValue } : {},
                as: __props.as,
                type: __props.type,
                disabled: __props.disabled,
                href,
                navigate: navigate2,
                rel,
                target,
                isExternal,
                active: isLinkActive({ route: linkRoute, isActive, isExactActive })
              })) : (openBlock(), createBlock(_sfc_main$x, mergeProps({ key: 1 }, {
                ..._ctx.$attrs,
                ...__props.exact && isExactActive ? { "aria-current": props.ariaCurrentValue } : {},
                as: __props.as,
                type: __props.type,
                disabled: __props.disabled,
                href,
                navigate: navigate2,
                rel,
                target,
                isExternal
              }, {
                class: resolveLinkClass({ route: linkRoute, isActive, isExactActive })
              }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default", {
                    active: isLinkActive({ route: linkRoute, isActive, isExactActive })
                  })
                ]),
                _: 2
              }, 1040, ["class"]))
            ];
          }
        }),
        _: 3
      }, _parent));
    };
  }
});
const _sfc_setup$v = _sfc_main$w.setup;
_sfc_main$w.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/@nuxt+ui@4.3.0_ce70e36b2b2e96ffad445540e21eec42/node_modules/@nuxt/ui/dist/runtime/components/Link.vue");
  return _sfc_setup$v ? _sfc_setup$v(props, ctx) : void 0;
};
const theme$4 = {
  "slots": {
    "base": [
      "rounded-md font-medium inline-flex items-center disabled:cursor-not-allowed aria-disabled:cursor-not-allowed disabled:opacity-75 aria-disabled:opacity-75",
      "transition-colors"
    ],
    "label": "truncate",
    "leadingIcon": "shrink-0",
    "leadingAvatar": "shrink-0",
    "leadingAvatarSize": "",
    "trailingIcon": "shrink-0"
  },
  "variants": {
    "fieldGroup": {
      "horizontal": "not-only:first:rounded-e-none not-only:last:rounded-s-none not-last:not-first:rounded-none focus-visible:z-[1]",
      "vertical": "not-only:first:rounded-b-none not-only:last:rounded-t-none not-last:not-first:rounded-none focus-visible:z-[1]"
    },
    "color": {
      "primary": "",
      "secondary": "",
      "success": "",
      "info": "",
      "warning": "",
      "error": "",
      "neutral": ""
    },
    "variant": {
      "solid": "",
      "outline": "",
      "soft": "",
      "subtle": "",
      "ghost": "",
      "link": ""
    },
    "size": {
      "xs": {
        "base": "px-2 py-1 text-xs gap-1",
        "leadingIcon": "size-4",
        "leadingAvatarSize": "3xs",
        "trailingIcon": "size-4"
      },
      "sm": {
        "base": "px-2.5 py-1.5 text-xs gap-1.5",
        "leadingIcon": "size-4",
        "leadingAvatarSize": "3xs",
        "trailingIcon": "size-4"
      },
      "md": {
        "base": "px-2.5 py-1.5 text-sm gap-1.5",
        "leadingIcon": "size-5",
        "leadingAvatarSize": "2xs",
        "trailingIcon": "size-5"
      },
      "lg": {
        "base": "px-3 py-2 text-sm gap-2",
        "leadingIcon": "size-5",
        "leadingAvatarSize": "2xs",
        "trailingIcon": "size-5"
      },
      "xl": {
        "base": "px-3 py-2 text-base gap-2",
        "leadingIcon": "size-6",
        "leadingAvatarSize": "xs",
        "trailingIcon": "size-6"
      }
    },
    "block": {
      "true": {
        "base": "w-full justify-center",
        "trailingIcon": "ms-auto"
      }
    },
    "square": {
      "true": ""
    },
    "leading": {
      "true": ""
    },
    "trailing": {
      "true": ""
    },
    "loading": {
      "true": ""
    },
    "active": {
      "true": {
        "base": ""
      },
      "false": {
        "base": ""
      }
    }
  },
  "compoundVariants": [
    {
      "color": "primary",
      "variant": "solid",
      "class": "text-inverted bg-primary hover:bg-primary/75 active:bg-primary/75 disabled:bg-primary aria-disabled:bg-primary focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-primary"
    },
    {
      "color": "secondary",
      "variant": "solid",
      "class": "text-inverted bg-secondary hover:bg-secondary/75 active:bg-secondary/75 disabled:bg-secondary aria-disabled:bg-secondary focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-secondary"
    },
    {
      "color": "success",
      "variant": "solid",
      "class": "text-inverted bg-success hover:bg-success/75 active:bg-success/75 disabled:bg-success aria-disabled:bg-success focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-success"
    },
    {
      "color": "info",
      "variant": "solid",
      "class": "text-inverted bg-info hover:bg-info/75 active:bg-info/75 disabled:bg-info aria-disabled:bg-info focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-info"
    },
    {
      "color": "warning",
      "variant": "solid",
      "class": "text-inverted bg-warning hover:bg-warning/75 active:bg-warning/75 disabled:bg-warning aria-disabled:bg-warning focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-warning"
    },
    {
      "color": "error",
      "variant": "solid",
      "class": "text-inverted bg-error hover:bg-error/75 active:bg-error/75 disabled:bg-error aria-disabled:bg-error focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-error"
    },
    {
      "color": "primary",
      "variant": "outline",
      "class": "ring ring-inset ring-primary/50 text-primary hover:bg-primary/10 active:bg-primary/10 disabled:bg-transparent aria-disabled:bg-transparent dark:disabled:bg-transparent dark:aria-disabled:bg-transparent focus:outline-none focus-visible:ring-2 focus-visible:ring-primary"
    },
    {
      "color": "secondary",
      "variant": "outline",
      "class": "ring ring-inset ring-secondary/50 text-secondary hover:bg-secondary/10 active:bg-secondary/10 disabled:bg-transparent aria-disabled:bg-transparent dark:disabled:bg-transparent dark:aria-disabled:bg-transparent focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary"
    },
    {
      "color": "success",
      "variant": "outline",
      "class": "ring ring-inset ring-success/50 text-success hover:bg-success/10 active:bg-success/10 disabled:bg-transparent aria-disabled:bg-transparent dark:disabled:bg-transparent dark:aria-disabled:bg-transparent focus:outline-none focus-visible:ring-2 focus-visible:ring-success"
    },
    {
      "color": "info",
      "variant": "outline",
      "class": "ring ring-inset ring-info/50 text-info hover:bg-info/10 active:bg-info/10 disabled:bg-transparent aria-disabled:bg-transparent dark:disabled:bg-transparent dark:aria-disabled:bg-transparent focus:outline-none focus-visible:ring-2 focus-visible:ring-info"
    },
    {
      "color": "warning",
      "variant": "outline",
      "class": "ring ring-inset ring-warning/50 text-warning hover:bg-warning/10 active:bg-warning/10 disabled:bg-transparent aria-disabled:bg-transparent dark:disabled:bg-transparent dark:aria-disabled:bg-transparent focus:outline-none focus-visible:ring-2 focus-visible:ring-warning"
    },
    {
      "color": "error",
      "variant": "outline",
      "class": "ring ring-inset ring-error/50 text-error hover:bg-error/10 active:bg-error/10 disabled:bg-transparent aria-disabled:bg-transparent dark:disabled:bg-transparent dark:aria-disabled:bg-transparent focus:outline-none focus-visible:ring-2 focus-visible:ring-error"
    },
    {
      "color": "primary",
      "variant": "soft",
      "class": "text-primary bg-primary/10 hover:bg-primary/15 active:bg-primary/15 focus:outline-none focus-visible:bg-primary/15 disabled:bg-primary/10 aria-disabled:bg-primary/10"
    },
    {
      "color": "secondary",
      "variant": "soft",
      "class": "text-secondary bg-secondary/10 hover:bg-secondary/15 active:bg-secondary/15 focus:outline-none focus-visible:bg-secondary/15 disabled:bg-secondary/10 aria-disabled:bg-secondary/10"
    },
    {
      "color": "success",
      "variant": "soft",
      "class": "text-success bg-success/10 hover:bg-success/15 active:bg-success/15 focus:outline-none focus-visible:bg-success/15 disabled:bg-success/10 aria-disabled:bg-success/10"
    },
    {
      "color": "info",
      "variant": "soft",
      "class": "text-info bg-info/10 hover:bg-info/15 active:bg-info/15 focus:outline-none focus-visible:bg-info/15 disabled:bg-info/10 aria-disabled:bg-info/10"
    },
    {
      "color": "warning",
      "variant": "soft",
      "class": "text-warning bg-warning/10 hover:bg-warning/15 active:bg-warning/15 focus:outline-none focus-visible:bg-warning/15 disabled:bg-warning/10 aria-disabled:bg-warning/10"
    },
    {
      "color": "error",
      "variant": "soft",
      "class": "text-error bg-error/10 hover:bg-error/15 active:bg-error/15 focus:outline-none focus-visible:bg-error/15 disabled:bg-error/10 aria-disabled:bg-error/10"
    },
    {
      "color": "primary",
      "variant": "subtle",
      "class": "text-primary ring ring-inset ring-primary/25 bg-primary/10 hover:bg-primary/15 active:bg-primary/15 disabled:bg-primary/10 aria-disabled:bg-primary/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-primary"
    },
    {
      "color": "secondary",
      "variant": "subtle",
      "class": "text-secondary ring ring-inset ring-secondary/25 bg-secondary/10 hover:bg-secondary/15 active:bg-secondary/15 disabled:bg-secondary/10 aria-disabled:bg-secondary/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary"
    },
    {
      "color": "success",
      "variant": "subtle",
      "class": "text-success ring ring-inset ring-success/25 bg-success/10 hover:bg-success/15 active:bg-success/15 disabled:bg-success/10 aria-disabled:bg-success/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-success"
    },
    {
      "color": "info",
      "variant": "subtle",
      "class": "text-info ring ring-inset ring-info/25 bg-info/10 hover:bg-info/15 active:bg-info/15 disabled:bg-info/10 aria-disabled:bg-info/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-info"
    },
    {
      "color": "warning",
      "variant": "subtle",
      "class": "text-warning ring ring-inset ring-warning/25 bg-warning/10 hover:bg-warning/15 active:bg-warning/15 disabled:bg-warning/10 aria-disabled:bg-warning/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-warning"
    },
    {
      "color": "error",
      "variant": "subtle",
      "class": "text-error ring ring-inset ring-error/25 bg-error/10 hover:bg-error/15 active:bg-error/15 disabled:bg-error/10 aria-disabled:bg-error/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-error"
    },
    {
      "color": "primary",
      "variant": "ghost",
      "class": "text-primary hover:bg-primary/10 active:bg-primary/10 focus:outline-none focus-visible:bg-primary/10 disabled:bg-transparent aria-disabled:bg-transparent dark:disabled:bg-transparent dark:aria-disabled:bg-transparent"
    },
    {
      "color": "secondary",
      "variant": "ghost",
      "class": "text-secondary hover:bg-secondary/10 active:bg-secondary/10 focus:outline-none focus-visible:bg-secondary/10 disabled:bg-transparent aria-disabled:bg-transparent dark:disabled:bg-transparent dark:aria-disabled:bg-transparent"
    },
    {
      "color": "success",
      "variant": "ghost",
      "class": "text-success hover:bg-success/10 active:bg-success/10 focus:outline-none focus-visible:bg-success/10 disabled:bg-transparent aria-disabled:bg-transparent dark:disabled:bg-transparent dark:aria-disabled:bg-transparent"
    },
    {
      "color": "info",
      "variant": "ghost",
      "class": "text-info hover:bg-info/10 active:bg-info/10 focus:outline-none focus-visible:bg-info/10 disabled:bg-transparent aria-disabled:bg-transparent dark:disabled:bg-transparent dark:aria-disabled:bg-transparent"
    },
    {
      "color": "warning",
      "variant": "ghost",
      "class": "text-warning hover:bg-warning/10 active:bg-warning/10 focus:outline-none focus-visible:bg-warning/10 disabled:bg-transparent aria-disabled:bg-transparent dark:disabled:bg-transparent dark:aria-disabled:bg-transparent"
    },
    {
      "color": "error",
      "variant": "ghost",
      "class": "text-error hover:bg-error/10 active:bg-error/10 focus:outline-none focus-visible:bg-error/10 disabled:bg-transparent aria-disabled:bg-transparent dark:disabled:bg-transparent dark:aria-disabled:bg-transparent"
    },
    {
      "color": "primary",
      "variant": "link",
      "class": "text-primary hover:text-primary/75 active:text-primary/75 disabled:text-primary aria-disabled:text-primary focus:outline-none focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-primary"
    },
    {
      "color": "secondary",
      "variant": "link",
      "class": "text-secondary hover:text-secondary/75 active:text-secondary/75 disabled:text-secondary aria-disabled:text-secondary focus:outline-none focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-secondary"
    },
    {
      "color": "success",
      "variant": "link",
      "class": "text-success hover:text-success/75 active:text-success/75 disabled:text-success aria-disabled:text-success focus:outline-none focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-success"
    },
    {
      "color": "info",
      "variant": "link",
      "class": "text-info hover:text-info/75 active:text-info/75 disabled:text-info aria-disabled:text-info focus:outline-none focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-info"
    },
    {
      "color": "warning",
      "variant": "link",
      "class": "text-warning hover:text-warning/75 active:text-warning/75 disabled:text-warning aria-disabled:text-warning focus:outline-none focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-warning"
    },
    {
      "color": "error",
      "variant": "link",
      "class": "text-error hover:text-error/75 active:text-error/75 disabled:text-error aria-disabled:text-error focus:outline-none focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-error"
    },
    {
      "color": "neutral",
      "variant": "solid",
      "class": "text-inverted bg-inverted hover:bg-inverted/90 active:bg-inverted/90 disabled:bg-inverted aria-disabled:bg-inverted focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-inverted"
    },
    {
      "color": "neutral",
      "variant": "outline",
      "class": "ring ring-inset ring-accented text-default bg-default hover:bg-elevated active:bg-elevated disabled:bg-default aria-disabled:bg-default focus:outline-none focus-visible:ring-2 focus-visible:ring-inverted"
    },
    {
      "color": "neutral",
      "variant": "soft",
      "class": "text-default bg-elevated hover:bg-accented/75 active:bg-accented/75 focus:outline-none focus-visible:bg-accented/75 disabled:bg-elevated aria-disabled:bg-elevated"
    },
    {
      "color": "neutral",
      "variant": "subtle",
      "class": "ring ring-inset ring-accented text-default bg-elevated hover:bg-accented/75 active:bg-accented/75 disabled:bg-elevated aria-disabled:bg-elevated focus:outline-none focus-visible:ring-2 focus-visible:ring-inverted"
    },
    {
      "color": "neutral",
      "variant": "ghost",
      "class": "text-default hover:bg-elevated active:bg-elevated focus:outline-none focus-visible:bg-elevated hover:disabled:bg-transparent dark:hover:disabled:bg-transparent hover:aria-disabled:bg-transparent dark:hover:aria-disabled:bg-transparent"
    },
    {
      "color": "neutral",
      "variant": "link",
      "class": "text-muted hover:text-default active:text-default disabled:text-muted aria-disabled:text-muted focus:outline-none focus-visible:ring-inset focus-visible:ring-2 focus-visible:ring-inverted"
    },
    {
      "size": "xs",
      "square": true,
      "class": "p-1"
    },
    {
      "size": "sm",
      "square": true,
      "class": "p-1.5"
    },
    {
      "size": "md",
      "square": true,
      "class": "p-1.5"
    },
    {
      "size": "lg",
      "square": true,
      "class": "p-2"
    },
    {
      "size": "xl",
      "square": true,
      "class": "p-2"
    },
    {
      "loading": true,
      "leading": true,
      "class": {
        "leadingIcon": "animate-spin"
      }
    },
    {
      "loading": true,
      "leading": false,
      "trailing": true,
      "class": {
        "trailingIcon": "animate-spin"
      }
    }
  ],
  "defaultVariants": {
    "color": "primary",
    "variant": "solid",
    "size": "md"
  }
};
const _sfc_main$v = {
  __name: "UButton",
  __ssrInlineRender: true,
  props: {
    label: { type: String, required: false },
    color: { type: null, required: false },
    activeColor: { type: null, required: false },
    variant: { type: null, required: false },
    activeVariant: { type: null, required: false },
    size: { type: null, required: false },
    square: { type: Boolean, required: false },
    block: { type: Boolean, required: false },
    loadingAuto: { type: Boolean, required: false },
    onClick: { type: [Function, Array], required: false },
    class: { type: null, required: false },
    ui: { type: null, required: false },
    icon: { type: null, required: false },
    avatar: { type: Object, required: false },
    leading: { type: Boolean, required: false },
    leadingIcon: { type: null, required: false },
    trailing: { type: Boolean, required: false },
    trailingIcon: { type: null, required: false },
    loading: { type: Boolean, required: false },
    loadingIcon: { type: null, required: false },
    as: { type: null, required: false },
    type: { type: null, required: false },
    disabled: { type: Boolean, required: false },
    active: { type: Boolean, required: false },
    exact: { type: Boolean, required: false },
    exactQuery: { type: [Boolean, String], required: false },
    exactHash: { type: Boolean, required: false },
    inactiveClass: { type: String, required: false },
    to: { type: null, required: false },
    href: { type: null, required: false },
    external: { type: Boolean, required: false },
    target: { type: [String, Object, null], required: false },
    rel: { type: [String, Object, null], required: false },
    noRel: { type: Boolean, required: false },
    prefetchedClass: { type: String, required: false },
    prefetch: { type: Boolean, required: false },
    prefetchOn: { type: [String, Object], required: false },
    noPrefetch: { type: Boolean, required: false },
    trailingSlash: { type: String, required: false },
    activeClass: { type: String, required: false },
    exactActiveClass: { type: String, required: false },
    ariaCurrentValue: { type: String, required: false },
    viewTransition: { type: Boolean, required: false },
    replace: { type: Boolean, required: false }
  },
  setup(__props) {
    const props = __props;
    const slots = useSlots();
    const appConfig2 = useAppConfig();
    const { orientation, size: buttonSize } = useFieldGroup(props);
    const linkProps = useForwardProps(pickLinkProps(props));
    const loadingAutoState = ref(false);
    const formLoading = inject(formLoadingInjectionKey, void 0);
    async function onClickWrapper(event) {
      loadingAutoState.value = true;
      const callbacks = Array.isArray(props.onClick) ? props.onClick : [props.onClick];
      try {
        await Promise.all(callbacks.map((fn) => fn?.(event)));
      } finally {
        loadingAutoState.value = false;
      }
    }
    const isLoading = computed(() => {
      return props.loading || props.loadingAuto && (loadingAutoState.value || formLoading?.value && props.type === "submit");
    });
    const { isLeading, isTrailing, leadingIconName, trailingIconName } = useComponentIcons(
      computed(() => ({ ...props, loading: isLoading.value }))
    );
    const ui = computed(() => tv({
      extend: tv(theme$4),
      ...defu({
        variants: {
          active: {
            true: {
              base: mergeClasses(appConfig2.ui?.button?.variants?.active?.true?.base, props.activeClass)
            },
            false: {
              base: mergeClasses(appConfig2.ui?.button?.variants?.active?.false?.base, props.inactiveClass)
            }
          }
        }
      }, appConfig2.ui?.button || {})
    })({
      color: props.color,
      variant: props.variant,
      size: buttonSize.value,
      loading: isLoading.value,
      block: props.block,
      square: props.square || !slots.default && !props.label,
      leading: isLeading.value,
      trailing: isTrailing.value,
      fieldGroup: orientation.value
    }));
    return (_ctx, _push, _parent, _attrs) => {
      _push(ssrRenderComponent(_sfc_main$w, mergeProps({
        type: __props.type,
        disabled: __props.disabled || isLoading.value
      }, unref(omit)(unref(linkProps), ["type", "disabled", "onClick"]), { custom: "" }, _attrs), {
        default: withCtx(({ active, ...slotProps }, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent(_sfc_main$x, mergeProps(slotProps, {
              "data-slot": "base",
              class: ui.value.base({
                class: [props.ui?.base, props.class],
                active,
                ...active && __props.activeVariant ? { variant: __props.activeVariant } : {},
                ...active && __props.activeColor ? { color: __props.activeColor } : {}
              }),
              onClick: onClickWrapper
            }), {
              default: withCtx((_2, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  ssrRenderSlot(_ctx.$slots, "leading", { ui: ui.value }, () => {
                    if (unref(isLeading) && unref(leadingIconName)) {
                      _push3(ssrRenderComponent(_sfc_main$B, {
                        name: unref(leadingIconName),
                        "data-slot": "leadingIcon",
                        class: ui.value.leadingIcon({ class: props.ui?.leadingIcon, active })
                      }, null, _parent3, _scopeId2));
                    } else if (!!__props.avatar) {
                      _push3(ssrRenderComponent(_sfc_main$y, mergeProps({
                        size: props.ui?.leadingAvatarSize || ui.value.leadingAvatarSize()
                      }, __props.avatar, {
                        "data-slot": "leadingAvatar",
                        class: ui.value.leadingAvatar({ class: props.ui?.leadingAvatar, active })
                      }), null, _parent3, _scopeId2));
                    } else {
                      _push3(`<!---->`);
                    }
                  }, _push3, _parent3, _scopeId2);
                  ssrRenderSlot(_ctx.$slots, "default", { ui: ui.value }, () => {
                    if (__props.label !== void 0 && __props.label !== null) {
                      _push3(`<span data-slot="label" class="${ssrRenderClass(ui.value.label({ class: props.ui?.label, active }))}"${_scopeId2}>${ssrInterpolate(__props.label)}</span>`);
                    } else {
                      _push3(`<!---->`);
                    }
                  }, _push3, _parent3, _scopeId2);
                  ssrRenderSlot(_ctx.$slots, "trailing", { ui: ui.value }, () => {
                    if (unref(isTrailing) && unref(trailingIconName)) {
                      _push3(ssrRenderComponent(_sfc_main$B, {
                        name: unref(trailingIconName),
                        "data-slot": "trailingIcon",
                        class: ui.value.trailingIcon({ class: props.ui?.trailingIcon, active })
                      }, null, _parent3, _scopeId2));
                    } else {
                      _push3(`<!---->`);
                    }
                  }, _push3, _parent3, _scopeId2);
                } else {
                  return [
                    renderSlot(_ctx.$slots, "leading", { ui: ui.value }, () => [
                      unref(isLeading) && unref(leadingIconName) ? (openBlock(), createBlock(_sfc_main$B, {
                        key: 0,
                        name: unref(leadingIconName),
                        "data-slot": "leadingIcon",
                        class: ui.value.leadingIcon({ class: props.ui?.leadingIcon, active })
                      }, null, 8, ["name", "class"])) : !!__props.avatar ? (openBlock(), createBlock(_sfc_main$y, mergeProps({
                        key: 1,
                        size: props.ui?.leadingAvatarSize || ui.value.leadingAvatarSize()
                      }, __props.avatar, {
                        "data-slot": "leadingAvatar",
                        class: ui.value.leadingAvatar({ class: props.ui?.leadingAvatar, active })
                      }), null, 16, ["size", "class"])) : createCommentVNode("", true)
                    ]),
                    renderSlot(_ctx.$slots, "default", { ui: ui.value }, () => [
                      __props.label !== void 0 && __props.label !== null ? (openBlock(), createBlock("span", {
                        key: 0,
                        "data-slot": "label",
                        class: ui.value.label({ class: props.ui?.label, active })
                      }, toDisplayString$1(__props.label), 3)) : createCommentVNode("", true)
                    ]),
                    renderSlot(_ctx.$slots, "trailing", { ui: ui.value }, () => [
                      unref(isTrailing) && unref(trailingIconName) ? (openBlock(), createBlock(_sfc_main$B, {
                        key: 0,
                        name: unref(trailingIconName),
                        "data-slot": "trailingIcon",
                        class: ui.value.trailingIcon({ class: props.ui?.trailingIcon, active })
                      }, null, 8, ["name", "class"])) : createCommentVNode("", true)
                    ])
                  ];
                }
              }),
              _: 2
            }, _parent2, _scopeId));
          } else {
            return [
              createVNode(_sfc_main$x, mergeProps(slotProps, {
                "data-slot": "base",
                class: ui.value.base({
                  class: [props.ui?.base, props.class],
                  active,
                  ...active && __props.activeVariant ? { variant: __props.activeVariant } : {},
                  ...active && __props.activeColor ? { color: __props.activeColor } : {}
                }),
                onClick: onClickWrapper
              }), {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "leading", { ui: ui.value }, () => [
                    unref(isLeading) && unref(leadingIconName) ? (openBlock(), createBlock(_sfc_main$B, {
                      key: 0,
                      name: unref(leadingIconName),
                      "data-slot": "leadingIcon",
                      class: ui.value.leadingIcon({ class: props.ui?.leadingIcon, active })
                    }, null, 8, ["name", "class"])) : !!__props.avatar ? (openBlock(), createBlock(_sfc_main$y, mergeProps({
                      key: 1,
                      size: props.ui?.leadingAvatarSize || ui.value.leadingAvatarSize()
                    }, __props.avatar, {
                      "data-slot": "leadingAvatar",
                      class: ui.value.leadingAvatar({ class: props.ui?.leadingAvatar, active })
                    }), null, 16, ["size", "class"])) : createCommentVNode("", true)
                  ]),
                  renderSlot(_ctx.$slots, "default", { ui: ui.value }, () => [
                    __props.label !== void 0 && __props.label !== null ? (openBlock(), createBlock("span", {
                      key: 0,
                      "data-slot": "label",
                      class: ui.value.label({ class: props.ui?.label, active })
                    }, toDisplayString$1(__props.label), 3)) : createCommentVNode("", true)
                  ]),
                  renderSlot(_ctx.$slots, "trailing", { ui: ui.value }, () => [
                    unref(isTrailing) && unref(trailingIconName) ? (openBlock(), createBlock(_sfc_main$B, {
                      key: 0,
                      name: unref(trailingIconName),
                      "data-slot": "trailingIcon",
                      class: ui.value.trailingIcon({ class: props.ui?.trailingIcon, active })
                    }, null, 8, ["name", "class"])) : createCommentVNode("", true)
                  ])
                ]),
                _: 2
              }, 1040, ["class"])
            ];
          }
        }),
        _: 3
      }, _parent));
    };
  }
};
const _sfc_setup$u = _sfc_main$v.setup;
_sfc_main$v.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/@nuxt+ui@4.3.0_ce70e36b2b2e96ffad445540e21eec42/node_modules/@nuxt/ui/dist/runtime/components/Button.vue");
  return _sfc_setup$u ? _sfc_setup$u(props, ctx) : void 0;
};
const theme$3 = {
  "slots": {
    "root": "gap-2",
    "base": "relative overflow-hidden rounded-full bg-accented",
    "indicator": "rounded-full size-full transition-transform duration-200 ease-out",
    "status": "flex text-dimmed transition-[width] duration-200",
    "steps": "grid items-end",
    "step": "truncate text-end row-start-1 col-start-1 transition-opacity"
  },
  "variants": {
    "animation": {
      "carousel": "",
      "carousel-inverse": "",
      "swing": "",
      "elastic": ""
    },
    "color": {
      "primary": {
        "indicator": "bg-primary",
        "steps": "text-primary"
      },
      "secondary": {
        "indicator": "bg-secondary",
        "steps": "text-secondary"
      },
      "success": {
        "indicator": "bg-success",
        "steps": "text-success"
      },
      "info": {
        "indicator": "bg-info",
        "steps": "text-info"
      },
      "warning": {
        "indicator": "bg-warning",
        "steps": "text-warning"
      },
      "error": {
        "indicator": "bg-error",
        "steps": "text-error"
      },
      "neutral": {
        "indicator": "bg-inverted",
        "steps": "text-inverted"
      }
    },
    "size": {
      "2xs": {
        "status": "text-xs",
        "steps": "text-xs"
      },
      "xs": {
        "status": "text-xs",
        "steps": "text-xs"
      },
      "sm": {
        "status": "text-sm",
        "steps": "text-sm"
      },
      "md": {
        "status": "text-sm",
        "steps": "text-sm"
      },
      "lg": {
        "status": "text-sm",
        "steps": "text-sm"
      },
      "xl": {
        "status": "text-base",
        "steps": "text-base"
      },
      "2xl": {
        "status": "text-base",
        "steps": "text-base"
      }
    },
    "step": {
      "active": {
        "step": "opacity-100"
      },
      "first": {
        "step": "opacity-100 text-muted"
      },
      "other": {
        "step": "opacity-0"
      },
      "last": {
        "step": ""
      }
    },
    "orientation": {
      "horizontal": {
        "root": "w-full flex flex-col",
        "base": "w-full",
        "status": "flex-row items-center justify-end min-w-fit"
      },
      "vertical": {
        "root": "h-full flex flex-row-reverse",
        "base": "h-full",
        "status": "flex-col justify-end min-h-fit"
      }
    },
    "inverted": {
      "true": {
        "status": "self-end"
      }
    }
  },
  "compoundVariants": [
    {
      "inverted": true,
      "orientation": "horizontal",
      "class": {
        "step": "text-start",
        "status": "flex-row-reverse"
      }
    },
    {
      "inverted": true,
      "orientation": "vertical",
      "class": {
        "steps": "items-start",
        "status": "flex-col-reverse"
      }
    },
    {
      "orientation": "horizontal",
      "size": "2xs",
      "class": "h-px"
    },
    {
      "orientation": "horizontal",
      "size": "xs",
      "class": "h-0.5"
    },
    {
      "orientation": "horizontal",
      "size": "sm",
      "class": "h-1"
    },
    {
      "orientation": "horizontal",
      "size": "md",
      "class": "h-2"
    },
    {
      "orientation": "horizontal",
      "size": "lg",
      "class": "h-3"
    },
    {
      "orientation": "horizontal",
      "size": "xl",
      "class": "h-4"
    },
    {
      "orientation": "horizontal",
      "size": "2xl",
      "class": "h-5"
    },
    {
      "orientation": "vertical",
      "size": "2xs",
      "class": "w-px"
    },
    {
      "orientation": "vertical",
      "size": "xs",
      "class": "w-0.5"
    },
    {
      "orientation": "vertical",
      "size": "sm",
      "class": "w-1"
    },
    {
      "orientation": "vertical",
      "size": "md",
      "class": "w-2"
    },
    {
      "orientation": "vertical",
      "size": "lg",
      "class": "w-3"
    },
    {
      "orientation": "vertical",
      "size": "xl",
      "class": "w-4"
    },
    {
      "orientation": "vertical",
      "size": "2xl",
      "class": "w-5"
    },
    {
      "orientation": "horizontal",
      "animation": "carousel",
      "class": {
        "indicator": "data-[state=indeterminate]:animate-[carousel_2s_ease-in-out_infinite] data-[state=indeterminate]:rtl:animate-[carousel-rtl_2s_ease-in-out_infinite]"
      }
    },
    {
      "orientation": "vertical",
      "animation": "carousel",
      "class": {
        "indicator": "data-[state=indeterminate]:animate-[carousel-vertical_2s_ease-in-out_infinite]"
      }
    },
    {
      "orientation": "horizontal",
      "animation": "carousel-inverse",
      "class": {
        "indicator": "data-[state=indeterminate]:animate-[carousel-inverse_2s_ease-in-out_infinite] data-[state=indeterminate]:rtl:animate-[carousel-inverse-rtl_2s_ease-in-out_infinite]"
      }
    },
    {
      "orientation": "vertical",
      "animation": "carousel-inverse",
      "class": {
        "indicator": "data-[state=indeterminate]:animate-[carousel-inverse-vertical_2s_ease-in-out_infinite]"
      }
    },
    {
      "orientation": "horizontal",
      "animation": "swing",
      "class": {
        "indicator": "data-[state=indeterminate]:animate-[swing_2s_ease-in-out_infinite]"
      }
    },
    {
      "orientation": "vertical",
      "animation": "swing",
      "class": {
        "indicator": "data-[state=indeterminate]:animate-[swing-vertical_2s_ease-in-out_infinite]"
      }
    },
    {
      "orientation": "horizontal",
      "animation": "elastic",
      "class": {
        "indicator": "data-[state=indeterminate]:animate-[elastic_2s_ease-in-out_infinite]"
      }
    },
    {
      "orientation": "vertical",
      "animation": "elastic",
      "class": {
        "indicator": "data-[state=indeterminate]:animate-[elastic-vertical_2s_ease-in-out_infinite]"
      }
    }
  ],
  "defaultVariants": {
    "animation": "carousel",
    "color": "primary",
    "size": "md"
  }
};
const _sfc_main$u = {
  __name: "UProgress",
  __ssrInlineRender: true,
  props: {
    as: { type: null, required: false },
    max: { type: [Number, Array], required: false },
    status: { type: Boolean, required: false },
    inverted: { type: Boolean, required: false, default: false },
    size: { type: null, required: false },
    color: { type: null, required: false },
    orientation: { type: null, required: false, default: "horizontal" },
    animation: { type: null, required: false },
    class: { type: null, required: false },
    ui: { type: null, required: false },
    getValueLabel: { type: Function, required: false },
    getValueText: { type: Function, required: false },
    modelValue: { type: [Number, null], required: false, default: null }
  },
  emits: ["update:modelValue", "update:max"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const { dir } = useLocale();
    const appConfig2 = useAppConfig();
    const rootProps = useForwardPropsEmits(reactivePick(props, "getValueLabel", "getValueText", "modelValue"), emits);
    const isIndeterminate = computed(() => rootProps.value.modelValue === null);
    const hasSteps = computed(() => Array.isArray(props.max));
    const realMax = computed(() => {
      if (isIndeterminate.value || !props.max) {
        return void 0;
      }
      if (Array.isArray(props.max)) {
        return props.max.length - 1;
      }
      return Number(props.max);
    });
    const percent2 = computed(() => {
      if (isIndeterminate.value) {
        return void 0;
      }
      switch (true) {
        case rootProps.value.modelValue < 0:
          return 0;
        case rootProps.value.modelValue > (realMax.value ?? 100):
          return 100;
        default:
          return Math.round(rootProps.value.modelValue / (realMax.value ?? 100) * 100);
      }
    });
    const indicatorStyle = computed(() => {
      if (percent2.value === void 0) {
        return;
      }
      if (props.orientation === "vertical") {
        return {
          transform: `translateY(${props.inverted ? "" : "-"}${100 - percent2.value}%)`
        };
      } else {
        if (dir.value === "rtl") {
          return {
            transform: `translateX(${props.inverted ? "-" : ""}${100 - percent2.value}%)`
          };
        } else {
          return {
            transform: `translateX(${props.inverted ? "" : "-"}${100 - percent2.value}%)`
          };
        }
      }
    });
    const statusStyle = computed(() => {
      const value = `${Math.max(percent2.value ?? 0, 0)}%`;
      return props.orientation === "vertical" ? { height: value } : { width: value };
    });
    function isActive(index2) {
      return index2 === Number(props.modelValue);
    }
    function isFirst(index2) {
      return index2 === 0;
    }
    function isLast(index2) {
      return index2 === realMax.value;
    }
    function stepVariant(index2) {
      index2 = Number(index2);
      if (isActive(index2) && !isFirst(index2)) {
        return "active";
      }
      if (isFirst(index2) && isActive(index2)) {
        return "first";
      }
      if (isLast(index2) && isActive(index2)) {
        return "last";
      }
      return "other";
    }
    const ui = computed(() => tv({ extend: tv(theme$3), ...appConfig2.ui?.progress || {} })({
      animation: props.animation,
      size: props.size,
      color: props.color,
      orientation: props.orientation,
      inverted: props.inverted
    }));
    return (_ctx, _push, _parent, _attrs) => {
      _push(ssrRenderComponent(unref(Primitive), mergeProps({
        as: __props.as,
        "data-orientation": __props.orientation,
        "data-slot": "root",
        class: ui.value.root({ class: [props.ui?.root, props.class] })
      }, _attrs), {
        default: withCtx((_2, _push2, _parent2, _scopeId) => {
          if (_push2) {
            if (!isIndeterminate.value && (__props.status || !!slots.status)) {
              _push2(`<div data-slot="status" class="${ssrRenderClass(ui.value.status({ class: props.ui?.status }))}" style="${ssrRenderStyle(statusStyle.value)}"${_scopeId}>`);
              ssrRenderSlot(_ctx.$slots, "status", { percent: percent2.value }, () => {
                _push2(`${ssrInterpolate(percent2.value)}% `);
              }, _push2, _parent2, _scopeId);
              _push2(`</div>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(ssrRenderComponent(unref(ProgressRoot_default), mergeProps(unref(rootProps), {
              max: realMax.value,
              "data-slot": "base",
              class: ui.value.base({ class: props.ui?.base }),
              style: { "transform": "translateZ(0)" }
            }), {
              default: withCtx((_3, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(ssrRenderComponent(unref(ProgressIndicator_default), {
                    "data-slot": "indicator",
                    class: ui.value.indicator({ class: props.ui?.indicator }),
                    style: indicatorStyle.value
                  }, null, _parent3, _scopeId2));
                } else {
                  return [
                    createVNode(unref(ProgressIndicator_default), {
                      "data-slot": "indicator",
                      class: ui.value.indicator({ class: props.ui?.indicator }),
                      style: indicatorStyle.value
                    }, null, 8, ["class", "style"])
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            if (hasSteps.value) {
              _push2(`<div data-slot="steps" class="${ssrRenderClass(ui.value.steps({ class: props.ui?.steps }))}"${_scopeId}><!--[-->`);
              ssrRenderList(__props.max, (step, index2) => {
                _push2(`<div data-slot="step" class="${ssrRenderClass(ui.value.step({ class: props.ui?.step, step: stepVariant(index2) }))}"${_scopeId}>`);
                ssrRenderSlot(_ctx.$slots, `step-${index2}`, { step }, () => {
                  _push2(`${ssrInterpolate(step)}`);
                }, _push2, _parent2, _scopeId);
                _push2(`</div>`);
              });
              _push2(`<!--]--></div>`);
            } else {
              _push2(`<!---->`);
            }
          } else {
            return [
              !isIndeterminate.value && (__props.status || !!slots.status) ? (openBlock(), createBlock("div", {
                key: 0,
                "data-slot": "status",
                class: ui.value.status({ class: props.ui?.status }),
                style: statusStyle.value
              }, [
                renderSlot(_ctx.$slots, "status", { percent: percent2.value }, () => [
                  createTextVNode(toDisplayString$1(percent2.value) + "% ", 1)
                ])
              ], 6)) : createCommentVNode("", true),
              createVNode(unref(ProgressRoot_default), mergeProps(unref(rootProps), {
                max: realMax.value,
                "data-slot": "base",
                class: ui.value.base({ class: props.ui?.base }),
                style: { "transform": "translateZ(0)" }
              }), {
                default: withCtx(() => [
                  createVNode(unref(ProgressIndicator_default), {
                    "data-slot": "indicator",
                    class: ui.value.indicator({ class: props.ui?.indicator }),
                    style: indicatorStyle.value
                  }, null, 8, ["class", "style"])
                ]),
                _: 1
              }, 16, ["max", "class"]),
              hasSteps.value ? (openBlock(), createBlock("div", {
                key: 1,
                "data-slot": "steps",
                class: ui.value.steps({ class: props.ui?.steps })
              }, [
                (openBlock(true), createBlock(Fragment, null, renderList(__props.max, (step, index2) => {
                  return openBlock(), createBlock("div", {
                    key: index2,
                    "data-slot": "step",
                    class: ui.value.step({ class: props.ui?.step, step: stepVariant(index2) })
                  }, [
                    renderSlot(_ctx.$slots, `step-${index2}`, { step }, () => [
                      createTextVNode(toDisplayString$1(step), 1)
                    ])
                  ], 2);
                }), 128))
              ], 2)) : createCommentVNode("", true)
            ];
          }
        }),
        _: 3
      }, _parent));
    };
  }
};
const _sfc_setup$t = _sfc_main$u.setup;
_sfc_main$u.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/@nuxt+ui@4.3.0_ce70e36b2b2e96ffad445540e21eec42/node_modules/@nuxt/ui/dist/runtime/components/Progress.vue");
  return _sfc_setup$t ? _sfc_setup$t(props, ctx) : void 0;
};
const theme$2 = {
  "slots": {
    "root": "relative group overflow-hidden bg-default shadow-lg rounded-lg ring ring-default p-4 flex gap-2.5 focus:outline-none",
    "wrapper": "w-0 flex-1 flex flex-col",
    "title": "text-sm font-medium text-highlighted",
    "description": "text-sm text-muted",
    "icon": "shrink-0 size-5",
    "avatar": "shrink-0",
    "avatarSize": "2xl",
    "actions": "flex gap-1.5 shrink-0",
    "progress": "absolute inset-x-0 bottom-0",
    "close": "p-0"
  },
  "variants": {
    "color": {
      "primary": {
        "root": "focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-primary",
        "icon": "text-primary"
      },
      "secondary": {
        "root": "focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-secondary",
        "icon": "text-secondary"
      },
      "success": {
        "root": "focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-success",
        "icon": "text-success"
      },
      "info": {
        "root": "focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-info",
        "icon": "text-info"
      },
      "warning": {
        "root": "focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-warning",
        "icon": "text-warning"
      },
      "error": {
        "root": "focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-error",
        "icon": "text-error"
      },
      "neutral": {
        "root": "focus-visible:ring-2 focus-visible:ring-inset focus-visible:ring-inverted",
        "icon": "text-highlighted"
      }
    },
    "orientation": {
      "horizontal": {
        "root": "items-center",
        "actions": "items-center"
      },
      "vertical": {
        "root": "items-start",
        "actions": "items-start mt-2.5"
      }
    },
    "title": {
      "true": {
        "description": "mt-1"
      }
    }
  },
  "defaultVariants": {
    "color": "primary"
  }
};
const _sfc_main$t = {
  __name: "UToast",
  __ssrInlineRender: true,
  props: {
    as: { type: null, required: false },
    title: { type: [String, Object, Function], required: false },
    description: { type: [String, Object, Function], required: false },
    icon: { type: null, required: false },
    avatar: { type: Object, required: false },
    color: { type: null, required: false },
    orientation: { type: null, required: false, default: "vertical" },
    close: { type: [Boolean, Object], required: false, default: true },
    closeIcon: { type: null, required: false },
    actions: { type: Array, required: false },
    progress: { type: [Boolean, Object], required: false, default: true },
    class: { type: null, required: false },
    ui: { type: null, required: false },
    defaultOpen: { type: Boolean, required: false },
    open: { type: Boolean, required: false },
    type: { type: String, required: false },
    duration: { type: Number, required: false }
  },
  emits: ["escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const { t } = useLocale();
    const appConfig2 = useAppConfig();
    const rootProps = useForwardPropsEmits(reactivePick(props, "as", "defaultOpen", "open", "duration", "type"), emits);
    const ui = computed(() => tv({ extend: tv(theme$2), ...appConfig2.ui?.toast || {} })({
      color: props.color,
      orientation: props.orientation,
      title: !!props.title || !!slots.title
    }));
    const rootRef = useTemplateRef("rootRef");
    const height = ref(0);
    __expose({
      height
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(ssrRenderComponent(unref(ToastRoot_default), mergeProps({
        ref_key: "rootRef",
        ref: rootRef
      }, unref(rootProps), {
        "data-orientation": __props.orientation,
        "data-slot": "root",
        class: ui.value.root({ class: [props.ui?.root, props.class] }),
        style: { "--height": height.value }
      }, _attrs), {
        default: withCtx(({ remaining, duration: duration2, open }, _push2, _parent2, _scopeId) => {
          if (_push2) {
            ssrRenderSlot(_ctx.$slots, "leading", { ui: ui.value }, () => {
              if (__props.avatar) {
                _push2(ssrRenderComponent(_sfc_main$y, mergeProps({
                  size: props.ui?.avatarSize || ui.value.avatarSize()
                }, __props.avatar, {
                  "data-slot": "avatar",
                  class: ui.value.avatar({ class: props.ui?.avatar })
                }), null, _parent2, _scopeId));
              } else if (__props.icon) {
                _push2(ssrRenderComponent(_sfc_main$B, {
                  name: __props.icon,
                  "data-slot": "icon",
                  class: ui.value.icon({ class: props.ui?.icon })
                }, null, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
            }, _push2, _parent2, _scopeId);
            _push2(`<div data-slot="wrapper" class="${ssrRenderClass(ui.value.wrapper({ class: props.ui?.wrapper }))}"${_scopeId}>`);
            if (__props.title || !!slots.title) {
              _push2(ssrRenderComponent(unref(ToastTitle_default), {
                "data-slot": "title",
                class: ui.value.title({ class: props.ui?.title })
              }, {
                default: withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    ssrRenderSlot(_ctx.$slots, "title", {}, () => {
                      if (typeof __props.title === "function") {
                        ssrRenderVNode(_push3, createVNode(resolveDynamicComponent(__props.title()), null, null), _parent3, _scopeId2);
                      } else if (typeof __props.title === "object") {
                        ssrRenderVNode(_push3, createVNode(resolveDynamicComponent(__props.title), null, null), _parent3, _scopeId2);
                      } else {
                        _push3(`<!--[-->${ssrInterpolate(__props.title)}<!--]-->`);
                      }
                    }, _push3, _parent3, _scopeId2);
                  } else {
                    return [
                      renderSlot(_ctx.$slots, "title", {}, () => [
                        typeof __props.title === "function" ? (openBlock(), createBlock(resolveDynamicComponent(__props.title()), { key: 0 })) : typeof __props.title === "object" ? (openBlock(), createBlock(resolveDynamicComponent(__props.title), { key: 1 })) : (openBlock(), createBlock(Fragment, { key: 2 }, [
                          createTextVNode(toDisplayString$1(__props.title), 1)
                        ], 64))
                      ])
                    ];
                  }
                }),
                _: 2
              }, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            if (__props.description || !!slots.description) {
              _push2(ssrRenderComponent(unref(ToastDescription_default), {
                "data-slot": "description",
                class: ui.value.description({ class: props.ui?.description })
              }, {
                default: withCtx((_2, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    ssrRenderSlot(_ctx.$slots, "description", {}, () => {
                      if (typeof __props.description === "function") {
                        ssrRenderVNode(_push3, createVNode(resolveDynamicComponent(__props.description()), null, null), _parent3, _scopeId2);
                      } else if (typeof __props.description === "object") {
                        ssrRenderVNode(_push3, createVNode(resolveDynamicComponent(__props.description), null, null), _parent3, _scopeId2);
                      } else {
                        _push3(`<!--[-->${ssrInterpolate(__props.description)}<!--]-->`);
                      }
                    }, _push3, _parent3, _scopeId2);
                  } else {
                    return [
                      renderSlot(_ctx.$slots, "description", {}, () => [
                        typeof __props.description === "function" ? (openBlock(), createBlock(resolveDynamicComponent(__props.description()), { key: 0 })) : typeof __props.description === "object" ? (openBlock(), createBlock(resolveDynamicComponent(__props.description), { key: 1 })) : (openBlock(), createBlock(Fragment, { key: 2 }, [
                          createTextVNode(toDisplayString$1(__props.description), 1)
                        ], 64))
                      ])
                    ];
                  }
                }),
                _: 2
              }, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            if (__props.orientation === "vertical" && (__props.actions?.length || !!slots.actions)) {
              _push2(`<div data-slot="actions" class="${ssrRenderClass(ui.value.actions({ class: props.ui?.actions }))}"${_scopeId}>`);
              ssrRenderSlot(_ctx.$slots, "actions", {}, () => {
                _push2(`<!--[-->`);
                ssrRenderList(__props.actions, (action, index2) => {
                  _push2(ssrRenderComponent(unref(ToastAction_default), {
                    key: index2,
                    "alt-text": action.label || "Action",
                    "as-child": "",
                    onClick: () => {
                    }
                  }, {
                    default: withCtx((_2, _push3, _parent3, _scopeId2) => {
                      if (_push3) {
                        _push3(ssrRenderComponent(_sfc_main$v, mergeProps({
                          size: "xs",
                          color: __props.color
                        }, { ref_for: true }, action), null, _parent3, _scopeId2));
                      } else {
                        return [
                          createVNode(_sfc_main$v, mergeProps({
                            size: "xs",
                            color: __props.color
                          }, { ref_for: true }, action), null, 16, ["color"])
                        ];
                      }
                    }),
                    _: 2
                  }, _parent2, _scopeId));
                });
                _push2(`<!--]-->`);
              }, _push2, _parent2, _scopeId);
              _push2(`</div>`);
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div>`);
            if (__props.orientation === "horizontal" && (__props.actions?.length || !!slots.actions) || __props.close) {
              _push2(`<div data-slot="actions" class="${ssrRenderClass(ui.value.actions({ class: props.ui?.actions, orientation: "horizontal" }))}"${_scopeId}>`);
              if (__props.orientation === "horizontal" && (__props.actions?.length || !!slots.actions)) {
                ssrRenderSlot(_ctx.$slots, "actions", {}, () => {
                  _push2(`<!--[-->`);
                  ssrRenderList(__props.actions, (action, index2) => {
                    _push2(ssrRenderComponent(unref(ToastAction_default), {
                      key: index2,
                      "alt-text": action.label || "Action",
                      "as-child": "",
                      onClick: () => {
                      }
                    }, {
                      default: withCtx((_2, _push3, _parent3, _scopeId2) => {
                        if (_push3) {
                          _push3(ssrRenderComponent(_sfc_main$v, mergeProps({
                            size: "xs",
                            color: __props.color
                          }, { ref_for: true }, action), null, _parent3, _scopeId2));
                        } else {
                          return [
                            createVNode(_sfc_main$v, mergeProps({
                              size: "xs",
                              color: __props.color
                            }, { ref_for: true }, action), null, 16, ["color"])
                          ];
                        }
                      }),
                      _: 2
                    }, _parent2, _scopeId));
                  });
                  _push2(`<!--]-->`);
                }, _push2, _parent2, _scopeId);
              } else {
                _push2(`<!---->`);
              }
              if (__props.close || !!slots.close) {
                _push2(ssrRenderComponent(unref(ToastClose_default), { "as-child": "" }, {
                  default: withCtx((_2, _push3, _parent3, _scopeId2) => {
                    if (_push3) {
                      ssrRenderSlot(_ctx.$slots, "close", { ui: ui.value }, () => {
                        if (__props.close) {
                          _push3(ssrRenderComponent(_sfc_main$v, mergeProps({
                            icon: __props.closeIcon || unref(appConfig2).ui.icons.close,
                            color: "neutral",
                            variant: "link",
                            "aria-label": unref(t)("toast.close")
                          }, typeof __props.close === "object" ? __props.close : {}, {
                            "data-slot": "close",
                            class: ui.value.close({ class: props.ui?.close }),
                            onClick: () => {
                            }
                          }), null, _parent3, _scopeId2));
                        } else {
                          _push3(`<!---->`);
                        }
                      }, _push3, _parent3, _scopeId2);
                    } else {
                      return [
                        renderSlot(_ctx.$slots, "close", { ui: ui.value }, () => [
                          __props.close ? (openBlock(), createBlock(_sfc_main$v, mergeProps({
                            key: 0,
                            icon: __props.closeIcon || unref(appConfig2).ui.icons.close,
                            color: "neutral",
                            variant: "link",
                            "aria-label": unref(t)("toast.close")
                          }, typeof __props.close === "object" ? __props.close : {}, {
                            "data-slot": "close",
                            class: ui.value.close({ class: props.ui?.close }),
                            onClick: withModifiers(() => {
                            }, ["stop"])
                          }), null, 16, ["icon", "aria-label", "class", "onClick"])) : createCommentVNode("", true)
                        ])
                      ];
                    }
                  }),
                  _: 2
                }, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
              _push2(`</div>`);
            } else {
              _push2(`<!---->`);
            }
            if (__props.progress && open && remaining > 0 && duration2) {
              _push2(ssrRenderComponent(_sfc_main$u, mergeProps({
                "model-value": remaining / duration2 * 100,
                color: __props.color
              }, typeof __props.progress === "object" ? __props.progress : {}, {
                size: "sm",
                "data-slot": "progress",
                class: ui.value.progress({ class: props.ui?.progress })
              }), null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
          } else {
            return [
              renderSlot(_ctx.$slots, "leading", { ui: ui.value }, () => [
                __props.avatar ? (openBlock(), createBlock(_sfc_main$y, mergeProps({
                  key: 0,
                  size: props.ui?.avatarSize || ui.value.avatarSize()
                }, __props.avatar, {
                  "data-slot": "avatar",
                  class: ui.value.avatar({ class: props.ui?.avatar })
                }), null, 16, ["size", "class"])) : __props.icon ? (openBlock(), createBlock(_sfc_main$B, {
                  key: 1,
                  name: __props.icon,
                  "data-slot": "icon",
                  class: ui.value.icon({ class: props.ui?.icon })
                }, null, 8, ["name", "class"])) : createCommentVNode("", true)
              ]),
              createVNode("div", {
                "data-slot": "wrapper",
                class: ui.value.wrapper({ class: props.ui?.wrapper })
              }, [
                __props.title || !!slots.title ? (openBlock(), createBlock(unref(ToastTitle_default), {
                  key: 0,
                  "data-slot": "title",
                  class: ui.value.title({ class: props.ui?.title })
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "title", {}, () => [
                      typeof __props.title === "function" ? (openBlock(), createBlock(resolveDynamicComponent(__props.title()), { key: 0 })) : typeof __props.title === "object" ? (openBlock(), createBlock(resolveDynamicComponent(__props.title), { key: 1 })) : (openBlock(), createBlock(Fragment, { key: 2 }, [
                        createTextVNode(toDisplayString$1(__props.title), 1)
                      ], 64))
                    ])
                  ]),
                  _: 3
                }, 8, ["class"])) : createCommentVNode("", true),
                __props.description || !!slots.description ? (openBlock(), createBlock(unref(ToastDescription_default), {
                  key: 1,
                  "data-slot": "description",
                  class: ui.value.description({ class: props.ui?.description })
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "description", {}, () => [
                      typeof __props.description === "function" ? (openBlock(), createBlock(resolveDynamicComponent(__props.description()), { key: 0 })) : typeof __props.description === "object" ? (openBlock(), createBlock(resolveDynamicComponent(__props.description), { key: 1 })) : (openBlock(), createBlock(Fragment, { key: 2 }, [
                        createTextVNode(toDisplayString$1(__props.description), 1)
                      ], 64))
                    ])
                  ]),
                  _: 3
                }, 8, ["class"])) : createCommentVNode("", true),
                __props.orientation === "vertical" && (__props.actions?.length || !!slots.actions) ? (openBlock(), createBlock("div", {
                  key: 2,
                  "data-slot": "actions",
                  class: ui.value.actions({ class: props.ui?.actions })
                }, [
                  renderSlot(_ctx.$slots, "actions", {}, () => [
                    (openBlock(true), createBlock(Fragment, null, renderList(__props.actions, (action, index2) => {
                      return openBlock(), createBlock(unref(ToastAction_default), {
                        key: index2,
                        "alt-text": action.label || "Action",
                        "as-child": "",
                        onClick: withModifiers(() => {
                        }, ["stop"])
                      }, {
                        default: withCtx(() => [
                          createVNode(_sfc_main$v, mergeProps({
                            size: "xs",
                            color: __props.color
                          }, { ref_for: true }, action), null, 16, ["color"])
                        ]),
                        _: 2
                      }, 1032, ["alt-text", "onClick"]);
                    }), 128))
                  ])
                ], 2)) : createCommentVNode("", true)
              ], 2),
              __props.orientation === "horizontal" && (__props.actions?.length || !!slots.actions) || __props.close ? (openBlock(), createBlock("div", {
                key: 0,
                "data-slot": "actions",
                class: ui.value.actions({ class: props.ui?.actions, orientation: "horizontal" })
              }, [
                __props.orientation === "horizontal" && (__props.actions?.length || !!slots.actions) ? renderSlot(_ctx.$slots, "actions", { key: 0 }, () => [
                  (openBlock(true), createBlock(Fragment, null, renderList(__props.actions, (action, index2) => {
                    return openBlock(), createBlock(unref(ToastAction_default), {
                      key: index2,
                      "alt-text": action.label || "Action",
                      "as-child": "",
                      onClick: withModifiers(() => {
                      }, ["stop"])
                    }, {
                      default: withCtx(() => [
                        createVNode(_sfc_main$v, mergeProps({
                          size: "xs",
                          color: __props.color
                        }, { ref_for: true }, action), null, 16, ["color"])
                      ]),
                      _: 2
                    }, 1032, ["alt-text", "onClick"]);
                  }), 128))
                ]) : createCommentVNode("", true),
                __props.close || !!slots.close ? (openBlock(), createBlock(unref(ToastClose_default), {
                  key: 1,
                  "as-child": ""
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "close", { ui: ui.value }, () => [
                      __props.close ? (openBlock(), createBlock(_sfc_main$v, mergeProps({
                        key: 0,
                        icon: __props.closeIcon || unref(appConfig2).ui.icons.close,
                        color: "neutral",
                        variant: "link",
                        "aria-label": unref(t)("toast.close")
                      }, typeof __props.close === "object" ? __props.close : {}, {
                        "data-slot": "close",
                        class: ui.value.close({ class: props.ui?.close }),
                        onClick: withModifiers(() => {
                        }, ["stop"])
                      }), null, 16, ["icon", "aria-label", "class", "onClick"])) : createCommentVNode("", true)
                    ])
                  ]),
                  _: 3
                })) : createCommentVNode("", true)
              ], 2)) : createCommentVNode("", true),
              __props.progress && open && remaining > 0 && duration2 ? (openBlock(), createBlock(_sfc_main$u, mergeProps({
                key: 1,
                "model-value": remaining / duration2 * 100,
                color: __props.color
              }, typeof __props.progress === "object" ? __props.progress : {}, {
                size: "sm",
                "data-slot": "progress",
                class: ui.value.progress({ class: props.ui?.progress })
              }), null, 16, ["model-value", "color", "class"])) : createCommentVNode("", true)
            ];
          }
        }),
        _: 3
      }, _parent));
    };
  }
};
const _sfc_setup$s = _sfc_main$t.setup;
_sfc_main$t.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/@nuxt+ui@4.3.0_ce70e36b2b2e96ffad445540e21eec42/node_modules/@nuxt/ui/dist/runtime/components/Toast.vue");
  return _sfc_setup$s ? _sfc_setup$s(props, ctx) : void 0;
};
const theme$1 = {
  "slots": {
    "viewport": "fixed flex flex-col w-[calc(100%-2rem)] sm:w-96 z-[100] data-[expanded=true]:h-(--height) focus:outline-none",
    "base": "pointer-events-auto absolute inset-x-0 z-(--index) transform-(--transform) data-[expanded=false]:data-[front=false]:h-(--front-height) data-[expanded=false]:data-[front=false]:*:opacity-0 data-[front=false]:*:transition-opacity data-[front=false]:*:duration-100 data-[state=closed]:animate-[toast-closed_200ms_ease-in-out] data-[state=closed]:data-[expanded=false]:data-[front=false]:animate-[toast-collapsed-closed_200ms_ease-in-out] data-[swipe=move]:transition-none transition-[transform,translate,height] duration-200 ease-out"
  },
  "variants": {
    "position": {
      "top-left": {
        "viewport": "left-4"
      },
      "top-center": {
        "viewport": "left-1/2 transform -translate-x-1/2"
      },
      "top-right": {
        "viewport": "right-4"
      },
      "bottom-left": {
        "viewport": "left-4"
      },
      "bottom-center": {
        "viewport": "left-1/2 transform -translate-x-1/2"
      },
      "bottom-right": {
        "viewport": "right-4"
      }
    },
    "swipeDirection": {
      "up": "data-[swipe=end]:animate-[toast-slide-up_200ms_ease-out]",
      "right": "data-[swipe=end]:animate-[toast-slide-right_200ms_ease-out]",
      "down": "data-[swipe=end]:animate-[toast-slide-down_200ms_ease-out]",
      "left": "data-[swipe=end]:animate-[toast-slide-left_200ms_ease-out]"
    }
  },
  "compoundVariants": [
    {
      "position": [
        "top-left",
        "top-center",
        "top-right"
      ],
      "class": {
        "viewport": "top-4",
        "base": "top-0 data-[state=open]:animate-[slide-in-from-top_200ms_ease-in-out]"
      }
    },
    {
      "position": [
        "bottom-left",
        "bottom-center",
        "bottom-right"
      ],
      "class": {
        "viewport": "bottom-4",
        "base": "bottom-0 data-[state=open]:animate-[slide-in-from-bottom_200ms_ease-in-out]"
      }
    },
    {
      "swipeDirection": [
        "left",
        "right"
      ],
      "class": "data-[swipe=move]:translate-x-(--reka-toast-swipe-move-x) data-[swipe=end]:translate-x-(--reka-toast-swipe-end-x) data-[swipe=cancel]:translate-x-0"
    },
    {
      "swipeDirection": [
        "up",
        "down"
      ],
      "class": "data-[swipe=move]:translate-y-(--reka-toast-swipe-move-y) data-[swipe=end]:translate-y-(--reka-toast-swipe-end-y) data-[swipe=cancel]:translate-y-0"
    }
  ],
  "defaultVariants": {
    "position": "bottom-right"
  }
};
const __default__$1 = {
  name: "Toaster"
};
const _sfc_main$s = /* @__PURE__ */ Object.assign(__default__$1, {
  __ssrInlineRender: true,
  props: {
    position: { type: null, required: false },
    expand: { type: Boolean, required: false, default: true },
    progress: { type: Boolean, required: false, default: true },
    portal: { type: [Boolean, String], required: false, skipCheck: true, default: true },
    max: { type: Number, required: false, default: 5 },
    class: { type: null, required: false },
    ui: { type: null, required: false },
    label: { type: String, required: false },
    duration: { type: Number, required: false, default: 5e3 },
    disableSwipe: { type: Boolean, required: false },
    swipeThreshold: { type: Number, required: false }
  },
  setup(__props) {
    const props = __props;
    const { toasts, remove } = useToast();
    const appConfig2 = useAppConfig();
    provide(toastMaxInjectionKey, toRef$2(() => props.max));
    const providerProps = useForwardProps(reactivePick(props, "duration", "label", "swipeThreshold", "disableSwipe"));
    const portalProps = usePortal(toRef$2(() => props.portal));
    const swipeDirection = computed(() => {
      switch (props.position) {
        case "top-center":
          return "up";
        case "top-right":
        case "bottom-right":
          return "right";
        case "bottom-center":
          return "down";
        case "top-left":
        case "bottom-left":
          return "left";
      }
      return "right";
    });
    const ui = computed(() => tv({ extend: tv(theme$1), ...appConfig2.ui?.toaster || {} })({
      position: props.position,
      swipeDirection: swipeDirection.value
    }));
    function onUpdateOpen(value, id2) {
      if (value) {
        return;
      }
      remove(id2);
    }
    const hovered = ref(false);
    const expanded = computed(() => props.expand || hovered.value);
    const refs = ref([]);
    const height = computed(() => refs.value.reduce((acc, { height: height2 }) => acc + height2 + 16, 0));
    const frontHeight = computed(() => refs.value[refs.value.length - 1]?.height || 0);
    function getOffset(index2) {
      return refs.value.slice(index2 + 1).reduce((acc, { height: height2 }) => acc + height2 + 16, 0);
    }
    return (_ctx, _push, _parent, _attrs) => {
      _push(ssrRenderComponent(unref(ToastProvider_default), mergeProps({ "swipe-direction": swipeDirection.value }, unref(providerProps), _attrs), {
        default: withCtx((_2, _push2, _parent2, _scopeId) => {
          if (_push2) {
            ssrRenderSlot(_ctx.$slots, "default", {}, null, _push2, _parent2, _scopeId);
            _push2(`<!--[-->`);
            ssrRenderList(unref(toasts), (toast, index2) => {
              _push2(ssrRenderComponent(_sfc_main$t, mergeProps({
                key: toast.id,
                ref_for: true,
                ref_key: "refs",
                ref: refs,
                progress: __props.progress
              }, { ref_for: true }, unref(omit)(toast, ["id", "close"]), {
                close: toast.close,
                "data-expanded": expanded.value,
                "data-front": !expanded.value && index2 === unref(toasts).length - 1,
                style: {
                  "--index": index2 - unref(toasts).length + unref(toasts).length,
                  "--before": unref(toasts).length - 1 - index2,
                  "--offset": getOffset(index2),
                  "--scale": expanded.value ? "1" : "calc(1 - var(--before) * var(--scale-factor))",
                  "--translate": expanded.value ? "calc(var(--offset) * var(--translate-factor))" : "calc(var(--before) * var(--gap))",
                  "--transform": "translateY(var(--translate)) scale(var(--scale))"
                },
                "data-slot": "base",
                class: ui.value.base({ class: [props.ui?.base, toast.onClick ? "cursor-pointer" : void 0] }),
                "onUpdate:open": ($event) => onUpdateOpen($event, toast.id),
                onClick: ($event) => toast.onClick && toast.onClick(toast)
              }), null, _parent2, _scopeId));
            });
            _push2(`<!--]-->`);
            _push2(ssrRenderComponent(unref(ToastPortal_default), unref(portalProps), {
              default: withCtx((_3, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(ssrRenderComponent(unref(ToastViewport_default), {
                    "data-expanded": expanded.value,
                    "data-slot": "viewport",
                    class: ui.value.viewport({ class: [props.ui?.viewport, props.class] }),
                    style: {
                      "--scale-factor": "0.05",
                      "--translate-factor": __props.position?.startsWith("top") ? "1px" : "-1px",
                      "--gap": __props.position?.startsWith("top") ? "16px" : "-16px",
                      "--front-height": `${frontHeight.value}px`,
                      "--height": `${height.value}px`
                    },
                    onMouseenter: ($event) => hovered.value = true,
                    onMouseleave: ($event) => hovered.value = false
                  }, null, _parent3, _scopeId2));
                } else {
                  return [
                    createVNode(unref(ToastViewport_default), {
                      "data-expanded": expanded.value,
                      "data-slot": "viewport",
                      class: ui.value.viewport({ class: [props.ui?.viewport, props.class] }),
                      style: {
                        "--scale-factor": "0.05",
                        "--translate-factor": __props.position?.startsWith("top") ? "1px" : "-1px",
                        "--gap": __props.position?.startsWith("top") ? "16px" : "-16px",
                        "--front-height": `${frontHeight.value}px`,
                        "--height": `${height.value}px`
                      },
                      onMouseenter: ($event) => hovered.value = true,
                      onMouseleave: ($event) => hovered.value = false
                    }, null, 8, ["data-expanded", "class", "style", "onMouseenter", "onMouseleave"])
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
          } else {
            return [
              renderSlot(_ctx.$slots, "default"),
              (openBlock(true), createBlock(Fragment, null, renderList(unref(toasts), (toast, index2) => {
                return openBlock(), createBlock(_sfc_main$t, mergeProps({
                  key: toast.id,
                  ref_for: true,
                  ref_key: "refs",
                  ref: refs,
                  progress: __props.progress
                }, { ref_for: true }, unref(omit)(toast, ["id", "close"]), {
                  close: toast.close,
                  "data-expanded": expanded.value,
                  "data-front": !expanded.value && index2 === unref(toasts).length - 1,
                  style: {
                    "--index": index2 - unref(toasts).length + unref(toasts).length,
                    "--before": unref(toasts).length - 1 - index2,
                    "--offset": getOffset(index2),
                    "--scale": expanded.value ? "1" : "calc(1 - var(--before) * var(--scale-factor))",
                    "--translate": expanded.value ? "calc(var(--offset) * var(--translate-factor))" : "calc(var(--before) * var(--gap))",
                    "--transform": "translateY(var(--translate)) scale(var(--scale))"
                  },
                  "data-slot": "base",
                  class: ui.value.base({ class: [props.ui?.base, toast.onClick ? "cursor-pointer" : void 0] }),
                  "onUpdate:open": ($event) => onUpdateOpen($event, toast.id),
                  onClick: ($event) => toast.onClick && toast.onClick(toast)
                }), null, 16, ["progress", "close", "data-expanded", "data-front", "style", "class", "onUpdate:open", "onClick"]);
              }), 128)),
              createVNode(unref(ToastPortal_default), unref(portalProps), {
                default: withCtx(() => [
                  createVNode(unref(ToastViewport_default), {
                    "data-expanded": expanded.value,
                    "data-slot": "viewport",
                    class: ui.value.viewport({ class: [props.ui?.viewport, props.class] }),
                    style: {
                      "--scale-factor": "0.05",
                      "--translate-factor": __props.position?.startsWith("top") ? "1px" : "-1px",
                      "--gap": __props.position?.startsWith("top") ? "16px" : "-16px",
                      "--front-height": `${frontHeight.value}px`,
                      "--height": `${height.value}px`
                    },
                    onMouseenter: ($event) => hovered.value = true,
                    onMouseleave: ($event) => hovered.value = false
                  }, null, 8, ["data-expanded", "class", "style", "onMouseenter", "onMouseleave"])
                ]),
                _: 1
              }, 16)
            ];
          }
        }),
        _: 3
      }, _parent));
    };
  }
});
const _sfc_setup$r = _sfc_main$s.setup;
_sfc_main$s.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/@nuxt+ui@4.3.0_ce70e36b2b2e96ffad445540e21eec42/node_modules/@nuxt/ui/dist/runtime/components/Toaster.vue");
  return _sfc_setup$r ? _sfc_setup$r(props, ctx) : void 0;
};
const UToaster = Object.assign(_sfc_main$s, { __name: "UToaster" });
function _useOverlay() {
  const overlays = shallowReactive([]);
  const create2 = (component, _options) => {
    const { props, defaultOpen, destroyOnClose } = _options || {};
    const options = reactive({
      id: /* @__PURE__ */ Symbol(""),
      isOpen: !!defaultOpen,
      component: markRaw(component),
      isMounted: !!defaultOpen,
      destroyOnClose: !!destroyOnClose,
      originalProps: props || {},
      props: { ...props }
    });
    overlays.push(options);
    return {
      ...options,
      open: (props2) => open(options.id, props2),
      close: (value) => close(options.id, value),
      patch: (props2) => patch(options.id, props2)
    };
  };
  const open = (id2, props) => {
    const overlay = getOverlay(id2);
    if (props) {
      overlay.props = { ...overlay.originalProps, ...props };
    } else {
      overlay.props = { ...overlay.originalProps };
    }
    overlay.isOpen = true;
    overlay.isMounted = true;
    const result = new Promise((resolve) => overlay.resolvePromise = resolve);
    return Object.assign(result, {
      id: id2,
      isMounted: overlay.isMounted,
      isOpen: overlay.isOpen,
      result
    });
  };
  const close = (id2, value) => {
    const overlay = getOverlay(id2);
    overlay.isOpen = false;
    if (overlay.resolvePromise) {
      overlay.resolvePromise(value);
      overlay.resolvePromise = void 0;
    }
  };
  const closeAll = () => {
    overlays.forEach((overlay) => close(overlay.id));
  };
  const unmount = (id2) => {
    const overlay = getOverlay(id2);
    overlay.isMounted = false;
    if (overlay.destroyOnClose) {
      const index2 = overlays.findIndex((overlay2) => overlay2.id === id2);
      overlays.splice(index2, 1);
    }
  };
  const patch = (id2, props) => {
    const overlay = getOverlay(id2);
    overlay.props = { ...overlay.props, ...props };
  };
  const getOverlay = (id2) => {
    const overlay = overlays.find((overlay2) => overlay2.id === id2);
    if (!overlay) {
      throw new Error("Overlay not found");
    }
    return overlay;
  };
  const isOpen = (id2) => {
    const overlay = getOverlay(id2);
    return overlay.isOpen;
  };
  return {
    overlays,
    open,
    close,
    closeAll,
    create: create2,
    patch,
    unmount,
    isOpen
  };
}
const useOverlay = /* @__PURE__ */ createSharedComposable(_useOverlay);
const _sfc_main$r = {
  __name: "UOverlayProvider",
  __ssrInlineRender: true,
  setup(__props) {
    const { overlays, unmount, close } = useOverlay();
    const mountedOverlays = computed(() => overlays.filter((overlay) => overlay.isMounted));
    const onAfterLeave = (id2) => {
      close(id2);
      unmount(id2);
    };
    const onClose = (id2, value) => {
      close(id2, value);
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<!--[-->`);
      ssrRenderList(mountedOverlays.value, (overlay) => {
        ssrRenderVNode(_push, createVNode(resolveDynamicComponent(overlay.component), mergeProps({
          key: overlay.id
        }, { ref_for: true }, overlay.props, {
          open: overlay.isOpen,
          "onUpdate:open": ($event) => overlay.isOpen = $event,
          onClose: (value) => onClose(overlay.id, value),
          "onAfter:leave": ($event) => onAfterLeave(overlay.id)
        }), null), _parent);
      });
      _push(`<!--]-->`);
    };
  }
};
const _sfc_setup$q = _sfc_main$r.setup;
_sfc_main$r.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/@nuxt+ui@4.3.0_ce70e36b2b2e96ffad445540e21eec42/node_modules/@nuxt/ui/dist/runtime/components/OverlayProvider.vue");
  return _sfc_setup$q ? _sfc_setup$q(props, ctx) : void 0;
};
const __default__ = {
  name: "App"
};
const _sfc_main$q = /* @__PURE__ */ Object.assign(__default__, {
  __ssrInlineRender: true,
  props: {
    tooltip: { type: Object, required: false },
    toaster: { type: [Object, null], required: false },
    locale: { type: Object, required: false },
    portal: { type: [Boolean, String], required: false, skipCheck: true, default: "body" },
    dir: { type: String, required: false },
    scrollBody: { type: [Boolean, Object], required: false },
    nonce: { type: String, required: false }
  },
  setup(__props) {
    const props = __props;
    const configProviderProps = useForwardProps(reactivePick(props, "scrollBody"));
    const tooltipProps = toRef$2(() => props.tooltip);
    const toasterProps = toRef$2(() => props.toaster);
    const locale = toRef$2(() => props.locale);
    provide(localeContextInjectionKey, locale);
    const portal = toRef$2(() => props.portal);
    provide(portalTargetInjectionKey, portal);
    return (_ctx, _push, _parent, _attrs) => {
      _push(ssrRenderComponent(unref(ConfigProvider_default), mergeProps({
        "use-id": () => useId(),
        dir: props.dir || locale.value?.dir,
        locale: locale.value?.code
      }, unref(configProviderProps), _attrs), {
        default: withCtx((_2, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent(unref(TooltipProvider_default), tooltipProps.value, {
              default: withCtx((_3, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  if (__props.toaster !== null) {
                    _push3(ssrRenderComponent(UToaster, toasterProps.value, {
                      default: withCtx((_4, _push4, _parent4, _scopeId3) => {
                        if (_push4) {
                          ssrRenderSlot(_ctx.$slots, "default", {}, null, _push4, _parent4, _scopeId3);
                        } else {
                          return [
                            renderSlot(_ctx.$slots, "default")
                          ];
                        }
                      }),
                      _: 3
                    }, _parent3, _scopeId2));
                  } else {
                    ssrRenderSlot(_ctx.$slots, "default", {}, null, _push3, _parent3, _scopeId2);
                  }
                  _push3(ssrRenderComponent(_sfc_main$r, null, null, _parent3, _scopeId2));
                } else {
                  return [
                    __props.toaster !== null ? (openBlock(), createBlock(UToaster, mergeProps({ key: 0 }, toasterProps.value), {
                      default: withCtx(() => [
                        renderSlot(_ctx.$slots, "default")
                      ]),
                      _: 3
                    }, 16)) : renderSlot(_ctx.$slots, "default", { key: 1 }),
                    createVNode(_sfc_main$r)
                  ];
                }
              }),
              _: 3
            }, _parent2, _scopeId));
          } else {
            return [
              createVNode(unref(TooltipProvider_default), tooltipProps.value, {
                default: withCtx(() => [
                  __props.toaster !== null ? (openBlock(), createBlock(UToaster, mergeProps({ key: 0 }, toasterProps.value), {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "default")
                    ]),
                    _: 3
                  }, 16)) : renderSlot(_ctx.$slots, "default", { key: 1 }),
                  createVNode(_sfc_main$r)
                ]),
                _: 3
              }, 16)
            ];
          }
        }),
        _: 3
      }, _parent));
    };
  }
});
const _sfc_setup$p = _sfc_main$q.setup;
_sfc_main$q.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/@nuxt+ui@4.3.0_ce70e36b2b2e96ffad445540e21eec42/node_modules/@nuxt/ui/dist/runtime/components/App.vue");
  return _sfc_setup$p ? _sfc_setup$p(props, ctx) : void 0;
};
const __nuxt_component_0$3 = Object.assign(_sfc_main$q, { __name: "UApp" });
function defaultEstimatedProgress(duration2, elapsed) {
  const completionPercentage = elapsed / duration2 * 100;
  return 2 / Math.PI * 100 * Math.atan(completionPercentage / 50);
}
function createLoadingIndicator(opts = {}) {
  const { duration: duration2 = 2e3, throttle = 200, hideDelay = 500, resetDelay = 400 } = opts;
  opts.estimatedProgress || defaultEstimatedProgress;
  const nuxtApp = useNuxtApp();
  const progress2 = shallowRef(0);
  const isLoading = shallowRef(false);
  const error = shallowRef(false);
  const start = (opts2 = {}) => {
    error.value = false;
    set(0, opts2);
  };
  function set(at2 = 0, opts2 = {}) {
    if (nuxtApp.isHydrating) {
      return;
    }
    if (at2 >= 100) {
      return finish({ force: opts2.force });
    }
    progress2.value = at2 < 0 ? 0 : at2;
    opts2.force ? 0 : throttle;
    {
      isLoading.value = true;
    }
  }
  function finish(opts2 = {}) {
    progress2.value = 100;
    if (opts2.error) {
      error.value = true;
    }
    if (opts2.force) {
      progress2.value = 0;
      isLoading.value = false;
    }
  }
  function clear() {
  }
  let _cleanup = () => {
  };
  return {
    _cleanup,
    progress: computed(() => progress2.value),
    isLoading: computed(() => isLoading.value),
    error: computed(() => error.value),
    start,
    set,
    finish,
    clear
  };
}
function useLoadingIndicator(opts = {}) {
  const nuxtApp = useNuxtApp();
  const indicator = nuxtApp._loadingIndicator ||= createLoadingIndicator(opts);
  return indicator;
}
const __nuxt_component_1$3 = defineComponent({
  name: "NuxtLoadingIndicator",
  props: {
    throttle: {
      type: Number,
      default: 200
    },
    duration: {
      type: Number,
      default: 2e3
    },
    hideDelay: {
      type: Number,
      default: 500
    },
    resetDelay: {
      type: Number,
      default: 400
    },
    height: {
      type: Number,
      default: 3
    },
    color: {
      type: [String, Boolean],
      default: "repeating-linear-gradient(to right,#00dc82 0%,#34cdfe 50%,#0047e1 100%)"
    },
    errorColor: {
      type: String,
      default: "repeating-linear-gradient(to right,#f87171 0%,#ef4444 100%)"
    },
    estimatedProgress: {
      type: Function,
      required: false
    }
  },
  setup(props, { slots, expose }) {
    const { progress: progress2, isLoading, error, start, finish, clear } = useLoadingIndicator({
      duration: props.duration,
      throttle: props.throttle,
      hideDelay: props.hideDelay,
      resetDelay: props.resetDelay,
      estimatedProgress: props.estimatedProgress
    });
    expose({
      progress: progress2,
      isLoading,
      error,
      start,
      finish,
      clear
    });
    return () => h("div", {
      class: "nuxt-loading-indicator",
      style: {
        position: "fixed",
        top: 0,
        right: 0,
        left: 0,
        pointerEvents: "none",
        width: "auto",
        height: `${props.height}px`,
        opacity: isLoading.value ? 1 : 0,
        background: error.value ? props.errorColor : props.color || void 0,
        backgroundSize: `${progress2.value > 0 ? 100 / progress2.value * 100 : 0}% auto`,
        transform: `scaleX(${progress2.value}%)`,
        transformOrigin: "left",
        transition: "transform 0.1s, height 0.4s, opacity 0.4s",
        zIndex: 999999
      }
    }, slots);
  }
});
const PhotosContextKey = /* @__PURE__ */ Symbol("PhotosContext");
function providePhotos(photos, status, refresh) {
  const context = {
    photos,
    status,
    refresh,
    getPhotoById: (id2) => {
      return photos.value.find((photo) => photo.id === id2);
    },
    filterPhotos: (predicate) => {
      return photos.value.filter(predicate);
    },
    totalCount: computed(() => photos.value.length)
  };
  provide(PhotosContextKey, context);
  return context;
}
function usePhotos() {
  const context = inject(PhotosContextKey);
  if (!context) {
    throw new Error("usePhotos must be used within a PhotosProvider");
  }
  return context;
}
const _sfc_main$p = /* @__PURE__ */ defineComponent({
  __name: "PhotosProvider",
  __ssrInlineRender: true,
  props: {
    photos: {},
    refresh: { type: Function },
    status: {}
  },
  setup(__props) {
    const props = __props;
    const photosRef = toRef$2(props, "photos");
    const status = toRef$2(props, "status");
    const refresh = props.refresh;
    providePhotos(photosRef, status, refresh);
    return (_ctx, _push, _parent, _attrs) => {
      ssrRenderSlot(_ctx.$slots, "default", {}, null, _push, _parent);
    };
  }
});
const _sfc_setup$o = _sfc_main$p.setup;
_sfc_main$p.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/PhotosProvider.vue");
  return _sfc_setup$o ? _sfc_setup$o(props, ctx) : void 0;
};
const __nuxt_component_2$2 = Object.assign(_sfc_main$p, { __name: "PhotosProvider" });
const layouts = {
  dashboard: defineAsyncComponent(() => import('./dashboard-Bbh7JJ8e.mjs').then((m) => m.default || m)),
  masonry: defineAsyncComponent(() => import('./masonry-C_aDr18R.mjs').then((m) => m.default || m)),
  onboarding: defineAsyncComponent(() => import('./onboarding-BJDpgLVt.mjs').then((m) => m.default || m))
};
const LayoutLoader = defineComponent({
  name: "LayoutLoader",
  inheritAttrs: false,
  props: {
    name: String,
    layoutProps: Object
  },
  setup(props, context) {
    return () => h(layouts[props.name], props.layoutProps, context.slots);
  }
});
const nuxtLayoutProps = {
  name: {
    type: [String, Boolean, Object],
    default: null
  },
  fallback: {
    type: [String, Object],
    default: null
  }
};
const __nuxt_component_3 = defineComponent({
  name: "NuxtLayout",
  inheritAttrs: false,
  props: nuxtLayoutProps,
  setup(props, context) {
    const nuxtApp = useNuxtApp();
    const injectedRoute = inject(PageRouteSymbol);
    const shouldUseEagerRoute = !injectedRoute || injectedRoute === useRoute();
    const route = shouldUseEagerRoute ? useRoute$1() : injectedRoute;
    const layout = computed(() => {
      let layout2 = unref(props.name) ?? route?.meta.layout ?? "default";
      if (layout2 && !(layout2 in layouts)) {
        if (props.fallback) {
          layout2 = unref(props.fallback);
        }
      }
      return layout2;
    });
    const layoutRef = shallowRef();
    context.expose({ layoutRef });
    const done = nuxtApp.deferHydration();
    let lastLayout;
    return () => {
      const hasLayout = layout.value && layout.value in layouts;
      const transitionProps = route?.meta.layoutTransition ?? appLayoutTransition;
      const previouslyRenderedLayout = lastLayout;
      lastLayout = layout.value;
      return _wrapInTransition(hasLayout && transitionProps, {
        default: () => h(Suspense, { suspensible: true, onResolve: () => {
          nextTick(done);
        } }, {
          default: () => h(
            LayoutProvider,
            {
              layoutProps: mergeProps(context.attrs, { ref: layoutRef }),
              key: layout.value || void 0,
              name: layout.value,
              shouldProvide: !props.name,
              isRenderingNewLayout: (name2) => {
                return name2 !== previouslyRenderedLayout && name2 === layout.value;
              },
              hasTransition: !!transitionProps
            },
            context.slots
          )
        })
      }).default();
    };
  }
});
const LayoutProvider = defineComponent({
  name: "NuxtLayoutProvider",
  inheritAttrs: false,
  props: {
    name: {
      type: [String, Boolean]
    },
    layoutProps: {
      type: Object
    },
    hasTransition: {
      type: Boolean
    },
    shouldProvide: {
      type: Boolean
    },
    isRenderingNewLayout: {
      type: Function,
      required: true
    }
  },
  setup(props, context) {
    const name2 = props.name;
    if (props.shouldProvide) {
      provide(LayoutMetaSymbol, {
        isCurrent: (route) => name2 === (route.meta.layout ?? "default")
      });
    }
    const injectedRoute = inject(PageRouteSymbol);
    const isNotWithinNuxtPage = injectedRoute && injectedRoute === useRoute();
    if (isNotWithinNuxtPage) {
      const vueRouterRoute = useRoute$1();
      const reactiveChildRoute = {};
      for (const _key in vueRouterRoute) {
        const key = _key;
        Object.defineProperty(reactiveChildRoute, key, {
          enumerable: true,
          get: () => {
            return props.isRenderingNewLayout(props.name) ? vueRouterRoute[key] : injectedRoute[key];
          }
        });
      }
      provide(PageRouteSymbol, shallowReactive(reactiveChildRoute));
    }
    return () => {
      if (!name2 || typeof name2 === "string" && !(name2 in layouts)) {
        return context.slots.default?.();
      }
      return h(
        LayoutLoader,
        { key: name2, layoutProps: props.layoutProps, name: name2 },
        context.slots
      );
    };
  }
});
const defineRouteProvider = (name2 = "RouteProvider") => defineComponent({
  name: name2,
  props: {
    route: {
      type: Object,
      required: true
    },
    vnode: Object,
    vnodeRef: Object,
    renderKey: String,
    trackRootNodes: Boolean
  },
  setup(props) {
    const previousKey = props.renderKey;
    const previousRoute = props.route;
    const route = {};
    for (const key in props.route) {
      Object.defineProperty(route, key, {
        get: () => previousKey === props.renderKey ? props.route[key] : previousRoute[key],
        enumerable: true
      });
    }
    provide(PageRouteSymbol, shallowReactive(route));
    return () => {
      if (!props.vnode) {
        return props.vnode;
      }
      return h(props.vnode, { ref: props.vnodeRef });
    };
  }
});
const RouteProvider = defineRouteProvider();
const __nuxt_component_7 = defineComponent({
  name: "NuxtPage",
  inheritAttrs: false,
  props: {
    name: {
      type: String
    },
    transition: {
      type: [Boolean, Object],
      default: void 0
    },
    keepalive: {
      type: [Boolean, Object],
      default: void 0
    },
    route: {
      type: Object
    },
    pageKey: {
      type: [Function, String],
      default: null
    }
  },
  setup(props, { attrs, slots, expose }) {
    const nuxtApp = useNuxtApp();
    const pageRef = ref();
    inject(PageRouteSymbol, null);
    expose({ pageRef });
    inject(LayoutMetaSymbol, null);
    nuxtApp.deferHydration();
    return () => {
      return h(RouterView, { name: props.name, route: props.route, ...attrs }, {
        default: (routeProps) => {
          return h(Suspense, { suspensible: true }, {
            default() {
              return h(RouteProvider, {
                vnode: slots.default ? normalizeSlot(slots.default, routeProps) : routeProps.Component,
                route: routeProps.route,
                vnodeRef: pageRef
              });
            }
          });
        }
      });
    };
  }
});
function normalizeSlot(slot, data) {
  const slotContent = slot(data);
  return slotContent.length === 1 ? h(slotContent[0]) : h(Fragment, void 0, slotContent);
}
const _sfc_main$o = /* @__PURE__ */ defineComponent({
  __name: "ThumbHash",
  __ssrInlineRender: true,
  props: {
    thumbhash: {},
    class: {}
  },
  setup(__props) {
    const props = __props;
    const dataUrl = computed(() => {
      if (typeof props.thumbhash === "string") {
        return thumbHashToDataURL(decompressUint8Array(props.thumbhash));
      }
      return thumbHashToDataURL(props.thumbhash);
    });
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<img${ssrRenderAttrs(mergeProps({
        src: unref(dataUrl),
        class: unref(twMerge)("w-full h-full", props.class)
      }, _attrs))}>`);
    };
  }
});
const _sfc_setup$n = _sfc_main$o.setup;
_sfc_main$o.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/ThumbHash.vue");
  return _sfc_setup$n ? _sfc_setup$n(props, ctx) : void 0;
};
const __nuxt_component_0$2 = Object.assign(_sfc_main$o, { __name: "ThumbHash" });
const stepsOrder = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function createRenderStep(runNextFrame, stepName) {
  let thisFrame = /* @__PURE__ */ new Set();
  let nextFrame = /* @__PURE__ */ new Set();
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  function triggerCallback(callback) {
    if (toKeepAlive.has(callback)) {
      step.schedule(callback);
      runNextFrame();
    }
    callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (!queue.has(callback))
        queue.add(callback);
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      latestFrameData = frameData2;
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      thisFrame.forEach(triggerCallback);
      thisFrame.clear();
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}
const MotionGlobalConfig = {};
const maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state2 = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const flagRunNextFrame = () => runNextFrame = true;
  const steps = stepsOrder.reduce((acc, key) => {
    acc[key] = createRenderStep(flagRunNextFrame);
    return acc;
  }, {});
  const { setup, read, resolveKeyframes, preUpdate, update, preRender, render: render2, postRender } = steps;
  const processBatch = () => {
    const timestamp = MotionGlobalConfig.useManualTiming ? state2.timestamp : performance.now();
    runNextFrame = false;
    if (!MotionGlobalConfig.useManualTiming) {
      state2.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state2.timestamp, maxElapsed), 1);
    }
    state2.timestamp = timestamp;
    state2.isProcessing = true;
    setup.process(state2);
    read.process(state2);
    resolveKeyframes.process(state2);
    preUpdate.process(state2);
    update.process(state2);
    preRender.process(state2);
    render2.process(state2);
    postRender.process(state2);
    state2.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  };
  const wake = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state2.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  };
  const schedule = stepsOrder.reduce((acc, key) => {
    const step = steps[key];
    acc[key] = (process2, keepAlive = false, immediate = false) => {
      if (!runNextFrame)
        wake();
      return step.schedule(process2, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = (process2) => {
    for (let i = 0; i < stepsOrder.length; i++) {
      steps[stepsOrder[i]].cancel(process2);
    }
  };
  return { schedule, cancel, state: state2, steps };
}
const noop = /* @__NO_SIDE_EFFECTS__ */ (any) => any;
const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);
let now;
function clearTime() {
  now = void 0;
}
const time = {
  now: () => {
    if (now === void 0) {
      time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
    }
    return now;
  },
  set: (newTime) => {
    now = newTime;
    queueMicrotask(clearTime);
  }
};
const secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (seconds) => seconds * 1e3;
const millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (milliseconds) => milliseconds / 1e3;
function delay$1(callback, timeout) {
  const start = time.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.setup(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
const checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);
const isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--");
const startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--");
const isCSSVariableToken = (value) => {
  const startsWithToken = startsAsVariableToken(value);
  if (!startsWithToken)
    return false;
  return singleCssVariableRegex.test(value.split("/*")[0].trim());
};
const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  for (const key in correctors) {
    scaleCorrectors[key] = correctors[key];
    if (isCSSVariableName(key)) {
      scaleCorrectors[key].isCSSVariable = true;
    }
  }
}
function createContext(providerComponentName, contextName) {
  const symbolDescription = typeof providerComponentName === "string" && !contextName ? `${providerComponentName}Context` : contextName;
  const injectionKey = Symbol(symbolDescription);
  const injectContext = (fallback) => {
    const context = inject(injectionKey, fallback);
    if (context === void 0) {
      throw new Error(
        `Injection \`${injectionKey.toString()}\` not found. Component must be used within ${Array.isArray(providerComponentName) ? `one of the following components: ${providerComponentName.join(
          ", "
        )}` : `\`${providerComponentName}\``}`
      );
    }
    return context;
  };
  const provideContext = (contextValue) => {
    provide(injectionKey, contextValue);
    return contextValue;
  };
  return [injectContext, provideContext];
}
const [injectMotion, provideMotion] = createContext("Motion");
const [injectLayoutGroup] = createContext("LayoutGroup");
function isAnimationControls$1(v) {
  return v !== null && typeof v === "object" && typeof v.start === "function";
}
class Feature {
  constructor(state2) {
    this.state = state2;
  }
  beforeMount() {
  }
  mount() {
  }
  unmount() {
  }
  update() {
  }
  beforeUpdate() {
  }
  beforeUnmount() {
  }
}
function resolveVariant$1(definition, variants, custom) {
  if (Array.isArray(definition)) {
    return definition.reduce((acc, item) => {
      const resolvedVariant = resolveVariant$1(item, variants, custom);
      return resolvedVariant ? { ...acc, ...resolvedVariant } : acc;
    }, {});
  } else if (typeof definition === "object") {
    return definition;
  } else if (definition && variants) {
    const variant = variants[definition];
    return typeof variant === "function" ? variant(custom) : variant;
  }
}
function hasChanged(a, b) {
  if (typeof a !== typeof b)
    return true;
  if (Array.isArray(a) && Array.isArray(b))
    return !shallowCompare(a, b);
  return a !== b;
}
function shallowCompare(next, prev) {
  const prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (let i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i])
      return false;
  }
  return true;
}
function isCssVar(name2) {
  return name2 == null ? void 0 : name2.startsWith("--");
}
const noopReturn = (v) => v;
function isNumber$1(value) {
  return typeof value === "number";
}
const svgElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "tspan",
  "use",
  "view",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "linearGradient",
  "radialGradient",
  "textPath"
];
const svgElementSet = new Set(svgElements);
function isSVGElement$1(as) {
  return svgElementSet.has(as);
}
class FeatureManager {
  constructor(state2) {
    this.features = [];
    const { features = [], lazyMotionContext } = state2.options;
    const allFeatures = features.concat(lazyMotionContext.features.value);
    this.features = allFeatures.map((Feature2) => new Feature2(state2));
    const featureInstances = this.features;
    watch(lazyMotionContext.features, (features2) => {
      features2.forEach((feature) => {
        if (!allFeatures.includes(feature)) {
          allFeatures.push(feature);
          const featureInstance = new feature(state2);
          featureInstances.push(featureInstance);
          if (state2.isMounted()) {
            featureInstance.beforeMount();
            featureInstance.mount();
          }
        }
      });
    }, {
      flush: "pre"
    });
  }
  mount() {
    this.features.forEach((feature) => feature.mount());
  }
  beforeMount() {
    this.features.forEach((feature) => {
      var _a;
      return (_a = feature.beforeMount) == null ? void 0 : _a.call(feature);
    });
  }
  unmount() {
    this.features.forEach((feature) => feature.unmount());
  }
  update() {
    this.features.forEach((feature) => {
      var _a;
      return (_a = feature.update) == null ? void 0 : _a.call(feature);
    });
  }
  beforeUpdate() {
    this.features.forEach((feature) => feature.beforeUpdate());
  }
  beforeUnmount() {
    this.features.forEach((feature) => feature.beforeUnmount());
  }
}
const doneCallbacks = /* @__PURE__ */ new WeakMap();
function removeDoneCallback(element) {
  const prevDoneCallback = doneCallbacks.get(element);
  if (prevDoneCallback) {
    element.removeEventListener("motioncomplete", prevDoneCallback);
  }
  doneCallbacks.delete(element);
}
const [injectAnimatePresence, provideAnimatePresence] = createContext("AnimatePresenceContext");
function useAnimatePresence(props) {
  const presenceContext = {
    initial: props.initial,
    custom: props.custom
  };
  watch(() => props.custom, (v) => {
    presenceContext.custom = v;
  }, {
    flush: "pre"
  });
  provideAnimatePresence(presenceContext);
}
function isVariantLabels(value) {
  return typeof value === "string" || value === false || Array.isArray(value);
}
const mountedStates = /* @__PURE__ */ new WeakMap();
let id$3 = 0;
class MotionState {
  constructor(options, parent) {
    var _a;
    this.element = null;
    this.isSafeToRemove = false;
    this.isVShow = false;
    this.children = /* @__PURE__ */ new Set();
    this.activeStates = {
      initial: true,
      animate: true
    };
    this.currentProcess = null;
    this._context = null;
    this.animateUpdates = noop;
    this.id = `motion-state-${id$3++}`;
    this.options = options;
    this.parent = parent;
    (_a = parent == null ? void 0 : parent.children) == null ? void 0 : _a.add(this);
    const initial = options.initial === void 0 && options.variants ? this.context.initial : options.initial;
    const initialVariantSource = initial === false ? ["initial", "animate"] : ["initial"];
    this.initTarget(initialVariantSource);
    this.featureManager = new FeatureManager(this);
    this.type = isSVGElement$1(this.options.as) ? "svg" : "html";
  }
  // Get animation context, falling back to parent context for inheritance
  get context() {
    if (!this._context) {
      const handler = {
        get: (target, prop) => {
          var _a;
          return isVariantLabels(this.options[prop]) ? this.options[prop] : (_a = this.parent) == null ? void 0 : _a.context[prop];
        }
      };
      this._context = new Proxy({}, handler);
    }
    return this._context;
  }
  // Initialize animation target values
  initTarget(initialVariantSource) {
    var _a;
    const custom = this.options.custom ?? ((_a = this.options.animatePresenceContext) == null ? void 0 : _a.custom);
    this.baseTarget = initialVariantSource.reduce((acc, variant) => {
      return {
        ...acc,
        ...resolveVariant$1(this.options[variant] || this.context[variant], this.options.variants, custom)
      };
    }, {});
    this.target = {};
  }
  // Update visual element with new options
  updateOptions(options) {
    var _a;
    this.options = options;
    (_a = this.visualElement) == null ? void 0 : _a.update({
      ...this.options,
      whileTap: this.options.whilePress
    }, {
      isPresent: !doneCallbacks.has(this.element)
    });
  }
  // Called before mounting, executes in parent-to-child order
  beforeMount() {
    this.featureManager.beforeMount();
  }
  // Mount motion state to DOM element, handles parent-child relationships
  mount(element, options, notAnimate = false) {
    var _a, _b;
    this.element = element;
    this.updateOptions(options);
    this.options.layoutId && ((_a = this.visualElement.projection.getStack()) == null ? void 0 : _a.members.length) > 0;
    this.featureManager.mount();
    if (!notAnimate && this.options.animate) {
      (_b = this.startAnimation) == null ? void 0 : _b.call(this);
    }
  }
  clearAnimation() {
    var _a, _b;
    this.currentProcess && cancelFrame(this.currentProcess);
    this.currentProcess = null;
    (_b = (_a = this.visualElement) == null ? void 0 : _a.variantChildren) == null ? void 0 : _b.forEach((child) => {
      child.state.clearAnimation();
    });
  }
  // update trigger animation
  startAnimation() {
    this.clearAnimation();
    this.currentProcess = frame.render(() => {
      this.currentProcess = null;
      this.animateUpdates();
    });
  }
  // Called before unmounting, executes in child-to-parent order
  beforeUnmount() {
    this.featureManager.beforeUnmount();
  }
  unmount(unMountChildren = false) {
    var _a;
    const shouldDelay = this.options.layoutId && ((_a = this.visualElement.projection) == null ? void 0 : _a.getStack().lead) === this.visualElement.projection && this.visualElement.projection.isProjecting();
    const unmountState = () => {
      var _a2, _b, _c;
      if (unMountChildren) {
        Array.from(this.children).reverse().forEach(this.unmountChild);
      }
      (_b = (_a2 = this.parent) == null ? void 0 : _a2.children) == null ? void 0 : _b.delete(this);
      mountedStates.delete(this.element);
      this.featureManager.unmount();
      (_c = this.visualElement) == null ? void 0 : _c.unmount();
      this.clearAnimation();
    };
    if (shouldDelay) {
      Promise.resolve().then(() => {
        unmountState();
      });
    } else {
      unmountState();
    }
  }
  unmountChild(child) {
    child.unmount(true);
  }
  // Called before updating, executes in parent-to-child order
  beforeUpdate() {
    this.featureManager.beforeUpdate();
  }
  // Update motion state with new options
  update(options) {
    this.updateOptions(options);
    this.featureManager.update();
    this.startAnimation();
  }
  // Set animation state active status and propagate to children
  setActive(name2, isActive, isAnimate = true) {
    var _a;
    if (!this.element || this.activeStates[name2] === isActive)
      return;
    this.activeStates[name2] = isActive;
    (_a = this.visualElement.variantChildren) == null ? void 0 : _a.forEach((child) => {
      child.state.setActive(name2, isActive, false);
    });
    if (isAnimate) {
      this.animateUpdates({
        isExit: name2 === "exit" && this.activeStates.exit
      });
    }
  }
  isMounted() {
    return Boolean(this.element);
  }
  // Called before layout updates to prepare for changes
  willUpdate(label) {
    var _a;
    if (this.options.layout || this.options.layoutId) {
      (_a = this.visualElement.projection) == null ? void 0 : _a.willUpdate();
    }
  }
}
const visualElementStore = /* @__PURE__ */ new WeakMap();
function motionEvent(name2, target, isExit) {
  return new CustomEvent(name2, { detail: { target, isExit } });
}
const rotation = {
  syntax: "<angle>",
  initialValue: "0deg",
  toDefaultUnit: (v) => `${v}deg`
};
const baseTransformProperties = {
  translate: {
    syntax: "<length-percentage>",
    initialValue: "0px",
    toDefaultUnit: (v) => `${v}px`
  },
  rotate: rotation,
  scale: {
    syntax: "<number>",
    initialValue: 1,
    toDefaultUnit: noopReturn
  },
  skew: rotation
};
const order = ["translate", "scale", "rotate", "skew"];
const axes = ["", "X", "Y", "Z"];
const transformDefinitions = /* @__PURE__ */ new Map();
const transforms = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"];
order.forEach((name2) => {
  axes.forEach((axis) => {
    transforms.push(name2 + axis);
    transformDefinitions.set(
      name2 + axis,
      baseTransformProperties[name2]
    );
  });
});
const transformLookup = new Set(transforms);
const isTransform = (name2) => transformLookup.has(name2);
const transformAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ"
};
function compareTransformOrder([a], [b]) {
  return transforms.indexOf(a) - transforms.indexOf(b);
}
function transformListToString(template, [name2, value]) {
  return `${template} ${name2}(${value})`;
}
function buildTransformTemplate(transforms2) {
  return transforms2.sort(compareTransformOrder).reduce(transformListToString, "").trim();
}
const transformResetValue = {
  translate: [0, 0],
  rotate: 0,
  scale: 1,
  skew: 0,
  x: 0,
  y: 0,
  z: 0
};
const createUnitType = /* @__NO_SIDE_EFFECTS__ */ (unit) => ({
  test: (v) => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,
  parse: parseFloat,
  transform: (v) => `${v}${unit}`
});
const degrees = /* @__PURE__ */ createUnitType("deg");
const percent = /* @__PURE__ */ createUnitType("%");
const px = /* @__PURE__ */ createUnitType("px");
const vh = /* @__PURE__ */ createUnitType("vh");
const vw = /* @__PURE__ */ createUnitType("vw");
const progressPercentage = /* @__PURE__ */ (() => ({
  ...percent,
  parse: (v) => percent.parse(v) / 100,
  transform: (v) => percent.transform(v * 100)
}))();
const isMotionValue = (value) => Boolean(value && value.getVelocity);
const style = {
  get: (element, name2) => {
    let value = isCssVar(name2) ? element.style.getPropertyValue(name2) : getComputedStyle(element)[name2];
    if (!value && value !== "0") {
      const definition = transformDefinitions.get(name2);
      if (definition)
        value = definition.initialValue;
    }
    return value;
  },
  set: (element, name2, value) => {
    if (isCssVar(name2)) {
      element.style.setProperty(name2, value);
    } else {
      element.style[name2] = value;
    }
  }
};
function createStyles(keyframes2) {
  var _a;
  const initialKeyframes = {};
  const transforms2 = [];
  for (let key in keyframes2) {
    let value = keyframes2[key];
    value = isMotionValue(value) ? value.get() : value;
    if (isTransform(key)) {
      if (key in transformAlias) {
        key = transformAlias[key];
      }
    }
    let initialKeyframe = Array.isArray(value) ? value[0] : value;
    const definition = transformDefinitions.get(key);
    if (definition) {
      initialKeyframe = isNumber$1(value) ? (_a = definition.toDefaultUnit) == null ? void 0 : _a.call(definition, value) : value;
      transforms2.push([key, initialKeyframe]);
    } else {
      initialKeyframes[key] = initialKeyframe;
    }
  }
  if (transforms2.length) {
    initialKeyframes.transform = buildTransformTemplate(transforms2);
  }
  if (Object.keys(initialKeyframes).length === 0) {
    return null;
  }
  return initialKeyframes;
}
const SVG_STYLE_TO_ATTRIBUTES = {
  "fill": true,
  "stroke": true,
  "opacity": true,
  "stroke-width": true,
  "fill-opacity": true,
  "stroke-opacity": true,
  "stroke-linecap": true,
  "stroke-linejoin": true,
  "stroke-dasharray": true,
  "stroke-dashoffset": true,
  "cx": true,
  "cy": true,
  "r": true,
  "d": true,
  "x1": true,
  "y1": true,
  "x2": true,
  "y2": true,
  "points": true,
  "path-length": true,
  "viewBox": true,
  "width": true,
  "height": true,
  "preserve-aspect-ratio": true,
  "clip-path": true,
  "filter": true,
  "mask": true,
  "stop-color": true,
  "stop-opacity": true,
  "gradient-transform": true,
  "gradient-units": true,
  "spread-method": true,
  "marker-end": true,
  "marker-mid": true,
  "marker-start": true,
  "text-anchor": true,
  "dominant-baseline": true,
  "font-family": true,
  "font-size": true,
  "font-weight": true,
  "letter-spacing": true,
  "vector-effect": true
};
function camelToKebab(str) {
  return str.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function buildSVGPath$1(attrs, length, spacing = 1, offset = 0) {
  attrs.pathLength = 1;
  delete attrs["path-length"];
  attrs["stroke-dashoffset"] = px.transform(-offset);
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs["stroke-dasharray"] = `${pathLength} ${pathSpacing}`;
}
function convertSvgStyleToAttributes(keyframes2) {
  const attrs = {};
  const styleProps = {};
  for (const key in keyframes2) {
    const kebabKey = camelToKebab(key);
    if (kebabKey in SVG_STYLE_TO_ATTRIBUTES) {
      const value = keyframes2[key];
      attrs[kebabKey] = isMotionValue(value) ? value.get() : value;
    } else {
      styleProps[key] = keyframes2[key];
    }
  }
  if (attrs["path-length"] !== void 0) {
    buildSVGPath$1(attrs, attrs["path-length"], attrs["path-spacing"], attrs["path-offset"]);
  }
  return {
    attrs,
    style: styleProps
  };
}
function convertBoundingBoxToBox$1({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function transformBoxPoints$1(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function measureViewportBox$1(instance, transformPoint2) {
  return convertBoundingBoxToBox$1(transformBoxPoints$1(instance.getBoundingClientRect(), transformPoint2));
}
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
const featureDefinitions = {};
for (const key in featureProps) {
  featureDefinitions[key] = {
    isEnabled: (props) => featureProps[key].some((name2) => !!props[name2])
  };
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis$1 = () => ({ min: 0, max: 0 });
const createBox$1 = () => ({
  x: createAxis$1(),
  y: createAxis$1()
});
const prefersReducedMotion = { current: null };
function isAnimationControls(v) {
  return v !== null && typeof v === "object" && typeof v.start === "function";
}
function isVariantLabel(v) {
  return typeof v === "string" || Array.isArray(v);
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
const variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name2) => isVariantLabel(props[name2]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  if (index2 > -1)
    arr.splice(index2, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a, b, c2) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a, b, c2);
    } else {
      for (let i = 0; i < numSubscriptions; i++) {
        const handler = this.subscriptions[i];
        handler && handler(a, b, c2);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const MAX_VELOCITY_DELTA = 30;
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(init2, options = {}) {
    this.canTrackVelocity = null;
    this.events = {};
    this.updateAndNotify = (v) => {
      var _a;
      const currentTime = time.now();
      if (this.updatedAt !== currentTime) {
        this.setPrevFrameValue();
      }
      this.prev = this.current;
      this.setCurrent(v);
      if (this.current !== this.prev) {
        (_a = this.events.change) == null ? void 0 : _a.notify(this.current);
        if (this.dependents) {
          for (const dependent of this.dependents) {
            dependent.dirty();
          }
        }
      }
    };
    this.hasAnimated = false;
    this.setCurrent(init2);
    this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current;
    this.updatedAt = time.now();
    if (this.canTrackVelocity === null && current !== void 0) {
      this.canTrackVelocity = isFloat(this.current);
    }
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue;
    this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v) {
    if (!this.passiveEffect) {
      this.updateAndNotify(v);
    } else {
      this.passiveEffect(v, this.updateAndNotify);
    }
  }
  setWithVelocity(prev, current, delta) {
    this.set(current);
    this.prev = void 0;
    this.prevFrameValue = prev;
    this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v, endAnimation = true) {
    this.updateAndNotify(v);
    this.prev = v;
    this.prevUpdatedAt = this.prevFrameValue = void 0;
    endAnimation && this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  dirty() {
    var _a;
    (_a = this.events.change) == null ? void 0 : _a.notify(this.current);
  }
  addDependent(dependent) {
    if (!this.dependents) {
      this.dependents = /* @__PURE__ */ new Set();
    }
    this.dependents.add(dependent);
  }
  removeDependent(dependent) {
    if (this.dependents) {
      this.dependents.delete(dependent);
    }
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
      return 0;
    }
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    var _a, _b;
    (_a = this.dependents) == null ? void 0 : _a.clear();
    (_b = this.events.destroy) == null ? void 0 : _b.notify();
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init2, options) {
  return new MotionValue(init2, options);
}
function updateMotionValuesFromProps(element, next, prev) {
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}
function getValueState(visualElement) {
  const state2 = [{}, {}];
  visualElement == null ? void 0 : visualElement.values.forEach((value, key) => {
    state2[0][key] = value.get();
    state2[1][key] = value.getVelocity();
  });
  return state2;
}
function resolveVariantFromProps(props, definition, custom, visualElement) {
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  return definition;
}
function fillWildcards(keyframes2) {
  for (let i = 1; i < keyframes2.length; i++) {
    keyframes2[i] ?? (keyframes2[i] = keyframes2[i - 1]);
  }
}
const radToDeg = (rad) => rad * 180 / Math.PI;
const rotate = (v) => {
  const angle = radToDeg(Math.atan2(v[1], v[0]));
  return rebaseAngle(angle);
};
const matrix2dParsers = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,
  rotate,
  rotateZ: rotate,
  skewX: (v) => radToDeg(Math.atan(v[1])),
  skewY: (v) => radToDeg(Math.atan(v[2])),
  skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2
};
const rebaseAngle = (angle) => {
  angle = angle % 360;
  if (angle < 0)
    angle += 360;
  return angle;
};
const rotateZ = rotate;
const scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]);
const scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]);
const matrix3dParsers = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX,
  scaleY,
  scale: (v) => (scaleX(v) + scaleY(v)) / 2,
  rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),
  rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),
  rotateZ,
  rotate: rotateZ,
  skewX: (v) => radToDeg(Math.atan(v[4])),
  skewY: (v) => radToDeg(Math.atan(v[1])),
  skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2
};
function defaultTransformValue(name2) {
  return name2.includes("scale") ? 1 : 0;
}
function parseValueFromTransform(transform2, name2) {
  if (!transform2 || transform2 === "none") {
    return defaultTransformValue(name2);
  }
  const matrix3dMatch = transform2.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let parsers;
  let match;
  if (matrix3dMatch) {
    parsers = matrix3dParsers;
    match = matrix3dMatch;
  } else {
    const matrix2dMatch = transform2.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    parsers = matrix2dParsers;
    match = matrix2dMatch;
  }
  if (!match) {
    return defaultTransformValue(name2);
  }
  const valueParser = parsers[name2];
  const values = match[1].split(",").map(convertTransformToNumber);
  return typeof valueParser === "function" ? valueParser(values) : values[valueParser];
}
const readTransformValue = (instance, name2) => {
  const { transform: transform2 = "none" } = getComputedStyle(instance);
  return parseValueFromTransform(transform2, name2);
};
function convertTransformToNumber(value) {
  return parseFloat(value.trim());
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = /* @__PURE__ */ (() => new Set(transformPropOrder))();
const clamp = (min, max, v) => {
  if (v > max)
    return max;
  if (v < min)
    return min;
  return v;
};
const number = {
  test: (v) => typeof v === "number",
  parse: parseFloat,
  transform: (v) => v
};
const alpha = {
  ...number,
  transform: (v) => clamp(0, 1, v)
};
const scale = {
  ...number,
  default: 1
};
const isNumOrPxType = (v) => v === number || v === px;
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
  right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
  // Transform
  x: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "x"),
  y: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "y")
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const toResolve = /* @__PURE__ */ new Set();
let isScheduled = false;
let anyNeedsMeasurement = false;
let isForced = false;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
    const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
    const transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      if (!removedTransforms.length)
        return;
      transformsToRestore.set(element, removedTransforms);
      element.render();
    });
    resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
    elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      if (restore) {
        restore.forEach(([key, value]) => {
          var _a;
          (_a = element.getValue(key)) == null ? void 0 : _a.set(value);
        });
      }
    });
    resolversToMeasure.forEach((resolver) => resolver.measureEndState());
    resolversToMeasure.forEach((resolver) => {
      if (resolver.suspendedScrollY !== void 0) {
        (void 0).scrollTo(0, resolver.suspendedScrollY);
      }
    });
  }
  anyNeedsMeasurement = false;
  isScheduled = false;
  toResolve.forEach((resolver) => resolver.complete(isForced));
  toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes();
    if (resolver.needsMeasurement) {
      anyNeedsMeasurement = true;
    }
  });
}
function flushKeyframeResolvers() {
  isForced = true;
  readAllKeyframes();
  measureAllKeyframes();
  isForced = false;
}
class KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name2, motionValue2, element, isAsync = false) {
    this.state = "pending";
    this.isAsync = false;
    this.needsMeasurement = false;
    this.unresolvedKeyframes = [...unresolvedKeyframes];
    this.onComplete = onComplete;
    this.name = name2;
    this.motionValue = motionValue2;
    this.element = element;
    this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.state = "scheduled";
    if (this.isAsync) {
      toResolve.add(this);
      if (!isScheduled) {
        isScheduled = true;
        frame.read(readAllKeyframes);
        frame.resolveKeyframes(measureAllKeyframes);
      }
    } else {
      this.readKeyframes();
      this.complete();
    }
  }
  readKeyframes() {
    const { unresolvedKeyframes, name: name2, element, motionValue: motionValue2 } = this;
    if (unresolvedKeyframes[0] === null) {
      const currentValue = motionValue2 == null ? void 0 : motionValue2.get();
      const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (currentValue !== void 0) {
        unresolvedKeyframes[0] = currentValue;
      } else if (element && name2) {
        const valueAsRead = element.readValue(name2, finalKeyframe);
        if (valueAsRead !== void 0 && valueAsRead !== null) {
          unresolvedKeyframes[0] = valueAsRead;
        }
      }
      if (unresolvedKeyframes[0] === void 0) {
        unresolvedKeyframes[0] = finalKeyframe;
      }
      if (motionValue2 && currentValue === void 0) {
        motionValue2.set(unresolvedKeyframes[0]);
      }
    }
    fillWildcards(unresolvedKeyframes);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(isForcedComplete = false) {
    this.state = "complete";
    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);
    toResolve.delete(this);
  }
  cancel() {
    if (this.state === "scheduled") {
      toResolve.delete(this);
      this.state = "pending";
    }
  }
  resume() {
    if (this.state === "pending")
      this.scheduleResolve();
  }
}
const isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);
const isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);
const sanitize = (v) => Math.round(v * 1e5) / 1e5;
const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(v) {
  return v == null;
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
const isColorString = (type, testProp) => (v) => {
  return Boolean(typeof v === "string" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));
};
const splitColor = (aName, bName, cName) => (v) => {
  if (typeof v !== "string")
    return v;
  const [a, b, c2, alpha2] = v.match(floatRegex);
  return {
    [aName]: parseFloat(a),
    [bName]: parseFloat(b),
    [cName]: parseFloat(c2),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const clampRgbUnit = (v) => clamp(0, 255, v);
const rgbUnit = {
  ...number,
  transform: (v) => Math.round(clampRgbUnit(v))
};
const rgba = {
  test: /* @__PURE__ */ isColorString("rgb", "red"),
  parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v) {
  let r = "";
  let g2 = "";
  let b = "";
  let a = "";
  if (v.length > 5) {
    r = v.substring(1, 3);
    g2 = v.substring(3, 5);
    b = v.substring(5, 7);
    a = v.substring(7, 9);
  } else {
    r = v.substring(1, 2);
    g2 = v.substring(2, 3);
    b = v.substring(3, 4);
    a = v.substring(4, 5);
    r += r;
    g2 += g2;
    b += b;
    a += a;
  }
  return {
    red: parseInt(r, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
const hex = {
  test: /* @__PURE__ */ isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const hsla = {
  test: /* @__PURE__ */ isColorString("hsl", "hue"),
  parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const color = {
  test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
  parse: (v) => {
    if (rgba.test(v)) {
      return rgba.parse(v);
    } else if (hsla.test(v)) {
      return hsla.parse(v);
    } else {
      return hex.parse(v);
    }
  },
  transform: (v) => {
    return typeof v === "string" ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
  },
  getAnimatableNone: (v) => {
    const parsed = color.parse(v);
    parsed.alpha = 0;
    return color.transform(parsed);
  }
};
const colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(v) {
  var _a, _b;
  return isNaN(v) && typeof v === "string" && (((_a = v.match(floatRegex)) == null ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) == null ? void 0 : _b.length) || 0) > 0;
}
const NUMBER_TOKEN = "number";
const COLOR_TOKEN = "color";
const VAR_TOKEN = "var";
const VAR_FUNCTION_TOKEN = "var(";
const SPLIT_TOKEN = "${}";
const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const values = [];
  const indexes = {
    color: [],
    number: [],
    var: []
  };
  const types = [];
  let i = 0;
  const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
    if (color.test(parsedValue)) {
      indexes.color.push(i);
      types.push(COLOR_TOKEN);
      values.push(color.parse(parsedValue));
    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
      indexes.var.push(i);
      types.push(VAR_TOKEN);
      values.push(parsedValue);
    } else {
      indexes.number.push(i);
      types.push(NUMBER_TOKEN);
      values.push(parseFloat(parsedValue));
    }
    ++i;
    return SPLIT_TOKEN;
  });
  const split = tokenised.split(SPLIT_TOKEN);
  return { values, split, indexes, types };
}
function parseComplexValue(v) {
  return analyseComplexValue(v).values;
}
function createTransformer(source) {
  const { split, types } = analyseComplexValue(source);
  const numSections = split.length;
  return (v) => {
    let output = "";
    for (let i = 0; i < numSections; i++) {
      output += split[i];
      if (v[i] !== void 0) {
        const type = types[i];
        if (type === NUMBER_TOKEN) {
          output += sanitize(v[i]);
        } else if (type === COLOR_TOKEN) {
          output += color.transform(v[i]);
        } else {
          output += v[i];
        }
      }
    }
    return output;
  };
}
const convertNumbersToZero = (v) => typeof v === "number" ? 0 : color.test(v) ? color.getAnimatableNone(v) : v;
function getAnimatableNone$1(v) {
  const parsed = parseComplexValue(v);
  const transformer = createTransformer(v);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};
const auto = {
  test: (v) => v === "auto",
  parse: (v) => v
};
const testValueType = (v) => (type) => type.test(v);
const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
const findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));
const valueTypes = [...dimensionValueTypes, color, complex];
const findValueType = (v) => valueTypes.find(testValueType(v));
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
  const [name2, value] = v.slice(0, -1).split("(");
  if (name2 === "drop-shadow")
    return v;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name2) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name2 + "(" + defaultValue + unit + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
const filter = {
  ...complex,
  getAnimatableNone: (v) => {
    const functions = v.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v;
  }
};
const int = {
  ...number,
  transform: Math.round
};
const transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px
};
const numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px,
  ...transformValueTypes,
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
};
const getDefaultValueType = (key) => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const { schedule: microtask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, true);
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.KeyframeResolver = KeyframeResolver;
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.renderScheduledAt = 0;
    this.scheduleRender = () => {
      const now2 = time.now();
      if (this.renderScheduledAt < now2) {
        this.renderScheduledAt = now2;
        frame.render(this.render, false, true);
      }
    };
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.blockInitialAnimation = Boolean(blockInitialAnimation);
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key]);
      }
    }
  }
  mount(instance) {
    var _a;
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    (_a = this.parent) == null ? void 0 : _a.addChild(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    var _a;
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.valueSubscriptions.clear();
    this.removeFromVariantTree && this.removeFromVariantTree();
    (_a = this.parent) == null ? void 0 : _a.removeChild(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    for (const key in this.features) {
      const feature = this.features[key];
      if (feature) {
        feature.unmount();
        feature.isMounted = false;
      }
    }
    this.current = null;
  }
  addChild(child) {
    this.children.add(child);
    this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set());
    this.enteringChildren.add(child);
  }
  removeChild(child) {
    this.children.delete(child);
    this.enteringChildren && this.enteringChildren.delete(child);
  }
  bindToMotionValue(key, value) {
    if (this.valueSubscriptions.has(key)) {
      this.valueSubscriptions.get(key)();
    }
    const valueIsTransform = transformProps.has(key);
    if (valueIsTransform && this.onBindTransform) {
      this.onBindTransform();
    }
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && frame.preRender(this.notifyUpdate);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
      this.scheduleRender();
    });
    let removeSyncCheck;
    if ((void 0).MotionCheckAppearSync) {
      removeSyncCheck = (void 0).MotionCheckAppearSync(this, key, value);
    }
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      if (removeSyncCheck)
        removeSyncCheck();
      if (value.owner)
        value.stop();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key = "animation";
    for (key in featureDefinitions) {
      const featureDefinition = featureDefinitions[key];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
        this.features[key] = new FeatureConstructor(this);
      }
      if (this.features[key]) {
        const feature = this.features[key];
        if (feature.isMounted) {
          feature.update();
        } else {
          feature.mount();
          feature.isMounted = true;
        }
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox$1();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key = propEventHandlers[i];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listenerName = "on" + key;
      const listener = props[listenerName];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name2) {
    return this.props.variants ? this.props.variants[name2] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    const existingValue = this.values.get(key);
    if (value !== existingValue) {
      if (existingValue)
        this.removeValue(key);
      this.bindToMotionValue(key, value);
      this.values.set(key, value);
      this.latestValues[key] = value.get();
    }
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key);
    }
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    let value = this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);
    if (value !== void 0 && value !== null) {
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(target)) {
        value = getAnimatableNone(key, target);
      }
      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
    }
    return isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a;
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial === "string" || typeof initial === "object") {
      const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) == null ? void 0 : _a.custom);
      if (variant) {
        valueFromInitial = variant[key];
      }
    }
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
  scheduleRenderMicrotask() {
    microtask.render(this.render);
  }
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...transformPropOrder
]);
let invariant = () => {
};
const splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(current) {
  const match = splitCSSVariableRegex.exec(current);
  if (!match)
    return [,];
  const [, token1, token2, fallback] = match;
  return [`--${token1 ?? token2}`, fallback];
}
function getVariableValue(current, element, depth = 1) {
  const [token, fallback] = parseCSSVariable(current);
  if (!token)
    return;
  const resolved = (void 0).getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  } else {
    return true;
  }
}
const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name2) {
  let i = 0;
  let animatableTemplate = void 0;
  while (i < unresolvedKeyframes.length && !animatableTemplate) {
    const keyframe = unresolvedKeyframes[i];
    if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
      animatableTemplate = unresolvedKeyframes[i];
    }
    i++;
  }
  if (animatableTemplate && name2) {
    for (const noneIndex of noneKeyframeIndexes) {
      unresolvedKeyframes[noneIndex] = getAnimatableNone(name2, animatableTemplate);
    }
  }
}
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name2, motionValue2, element) {
    super(unresolvedKeyframes, onComplete, name2, motionValue2, element, true);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name: name2 } = this;
    if (!element || !element.current)
      return;
    super.readKeyframes();
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      let keyframe = unresolvedKeyframes[i];
      if (typeof keyframe === "string") {
        keyframe = keyframe.trim();
        if (isCSSVariableToken(keyframe)) {
          const resolved = getVariableValue(keyframe, element.current);
          if (resolved !== void 0) {
            unresolvedKeyframes[i] = resolved;
          }
          if (i === unresolvedKeyframes.length - 1) {
            this.finalKeyframe = keyframe;
          }
        }
      }
    }
    this.resolveNoneKeyframes();
    if (!positionalKeys.has(name2) || unresolvedKeyframes.length !== 2) {
      return;
    }
    const [origin, target] = unresolvedKeyframes;
    const originType = findDimensionValueType(origin);
    const targetType = findDimensionValueType(target);
    if (originType === targetType)
      return;
    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        const value = unresolvedKeyframes[i];
        if (typeof value === "string") {
          unresolvedKeyframes[i] = parseFloat(value);
        }
      }
    } else if (positionalValues[name2]) {
      this.needsMeasurement = true;
    }
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name: name2 } = this;
    const noneKeyframeIndexes = [];
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      if (unresolvedKeyframes[i] === null || isNone(unresolvedKeyframes[i])) {
        noneKeyframeIndexes.push(i);
      }
    }
    if (noneKeyframeIndexes.length) {
      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name2);
    }
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name: name2 } = this;
    if (!element || !element.current)
      return;
    if (name2 === "height") {
      this.suspendedScrollY = (void 0).pageYOffset;
    }
    this.measuredOrigin = positionalValues[name2](element.measureViewportBox(), (void 0).getComputedStyle(element.current));
    unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    if (measureKeyframe !== void 0) {
      element.getValue(name2, measureKeyframe).jump(measureKeyframe, false);
    }
  }
  measureEndState() {
    var _a;
    const { element, name: name2, unresolvedKeyframes } = this;
    if (!element || !element.current)
      return;
    const value = element.getValue(name2);
    value && value.jump(this.measuredOrigin, false);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1;
    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name2](element.measureViewportBox(), (void 0).getComputedStyle(element.current));
    if (finalKeyframe !== null && this.finalKeyframe === void 0) {
      this.finalKeyframe = finalKeyframe;
    }
    if ((_a = this.removedTransforms) == null ? void 0 : _a.length) {
      this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
        element.getValue(unsetTransformName).set(unsetTransformValue);
      });
    }
    this.resolveNoneKeyframes();
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments);
    this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a, b) {
    return a.compareDocumentPosition(b) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    return props.style ? props.style[key] : void 0;
  }
  removeValueFromRenderState(key, { vars, style: style2 }) {
    delete vars[key];
    delete style2[key];
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current) {
          this.current.textContent = `${latest}`;
        }
      });
    }
  }
}
const getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const numTransforms = transformPropOrder.length;
function buildTransform(latestValues, transform2, transformTemplate) {
  let transformString = "";
  let transformIsDefault = true;
  for (let i = 0; i < numTransforms; i++) {
    const key = transformPropOrder[i];
    const value = latestValues[key];
    if (value === void 0)
      continue;
    let valueIsDefault = true;
    if (typeof value === "number") {
      valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
    } else {
      valueIsDefault = parseFloat(value) === 0;
    }
    if (!valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = false;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      if (transformTemplate) {
        transform2[key] = valueAsType;
      }
    }
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString);
  } else if (transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildHTMLStyles(state2, latestValues, transformTemplate) {
  const { style: style2, vars, transformOrigin } = state2;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      hasTransform2 = true;
      continue;
    } else if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (key.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin[key] = valueAsType;
      } else {
        style2[key] = valueAsType;
      }
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style2.transform = buildTransform(latestValues, state2.transform, transformTemplate);
    } else if (style2.transform) {
      style2.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style2.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
function renderHTML(element, { style: style2, vars }, styleProp, projection2) {
  const elementStyle = element.style;
  let key;
  for (key in style2) {
    elementStyle[key] = style2[key];
  }
  projection2 == null ? void 0 : projection2.applyProjectionStyles(elementStyle, styleProp);
  for (key in vars) {
    elementStyle.setProperty(key, vars[key]);
  }
}
function isForcedMotionValue(key, { layout, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
  var _a;
  const { style: style2 } = props;
  const newValues = {};
  for (const key in style2) {
    if (isMotionValue(style2[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a = visualElement == null ? void 0 : visualElement.getValue(key)) == null ? void 0 : _a.liveStyle) !== void 0) {
      newValues[key] = style2[key];
    }
  }
  return newValues;
}
function getComputedStyle$1(element) {
  return (void 0).getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "html";
    this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key) {
    var _a;
    if (transformProps.has(key)) {
      return ((_a = this.projection) == null ? void 0 : _a.isProjecting) ? defaultTransformValue(key) : readTransformValue(instance, key);
    } else {
      const computedStyle = getComputedStyle$1(instance);
      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox$1(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  }
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset);
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state2, {
  attrX,
  attrY,
  attrScale,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate, styleProp) {
  buildHTMLStyles(state2, latest, transformTemplate);
  if (isSVGTag2) {
    if (state2.style.viewBox) {
      state2.attrs.viewBox = state2.style.viewBox;
    }
    return;
  }
  state2.attrs = state2.style;
  state2.style = {};
  const { attrs, style: style2 } = state2;
  if (attrs.transform) {
    style2.transform = attrs.transform;
    delete attrs.transform;
  }
  if (style2.transform || attrs.transformOrigin) {
    style2.transformOrigin = attrs.transformOrigin ?? "50% 50%";
    delete attrs.transformOrigin;
  }
  if (style2.transform) {
    style2.transformBox = (styleProp == null ? void 0 : styleProp.transformBox) ?? "fill-box";
    delete attrs.transformBox;
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
function renderSVG(element, renderState, _styleProp, projection2) {
  renderHTML(element, renderState, void 0, projection2);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.isSVGTag = false;
    this.measureInstanceViewportBox = createBox$1;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance.getAttribute(key);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
  }
  renderInstance(instance, renderState, styleProp, projection2) {
    renderSVG(instance, renderState, styleProp, projection2);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}
function createVisualElement(Component, options) {
  return isSVGElement$1(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options);
}
function calcChildStagger(children, child, delayChildren, staggerChildren = 0, staggerDirection = 1) {
  const sortedChildren = Array.from(children);
  const index2 = sortedChildren.indexOf(child);
  const numChildren = children.size;
  const maxStaggerDuration = (numChildren - 1) * staggerChildren;
  const delayIsFunction = typeof delayChildren === "function";
  if (index2 === sortedChildren.length - 1) {
    child.parent.enteringChildren = void 0;
  }
  return delayIsFunction ? delayChildren(index2, numChildren) : staggerDirection === 1 ? index2 * staggerChildren : maxStaggerDuration - index2 * staggerChildren;
}
function isDOMKeyframes(keyframes2) {
  return typeof keyframes2 === "object" && !Array.isArray(keyframes2);
}
function resolveElements(elementOrSelector, scope, selectorCache) {
  if (elementOrSelector instanceof EventTarget) {
    return [elementOrSelector];
  } else if (typeof elementOrSelector === "string") {
    let root = void 0;
    const elements = (selectorCache == null ? void 0 : selectorCache[elementOrSelector]) ?? root.querySelectorAll(elementOrSelector);
    return elements ? Array.from(elements) : [];
  }
  return Array.from(elementOrSelector);
}
function resolveSubjects(subject, keyframes2, scope, selectorCache) {
  if (typeof subject === "string" && isDOMKeyframes(keyframes2)) {
    return resolveElements(subject, scope, selectorCache);
  } else if (subject instanceof NodeList) {
    return Array.from(subject);
  } else if (Array.isArray(subject)) {
    return subject;
  } else {
    return [subject];
  }
}
function calculateRepeatDuration(duration2, repeat, _repeatDelay) {
  return duration2 * (repeat + 1);
}
function calcNextTime(current, next, prev, labels) {
  if (typeof next === "number") {
    return next;
  } else if (next.startsWith("-") || next.startsWith("+")) {
    return Math.max(0, current + parseFloat(next));
  } else if (next === "<") {
    return prev;
  } else if (next.startsWith("<")) {
    return Math.max(0, prev + parseFloat(next.slice(1)));
  } else {
    return labels.get(next) ?? current;
  }
}
const mixNumber$1 = (from, to, progress2) => {
  return from + (to - from) * progress2;
};
const wrap = (min, max, v) => {
  const rangeSize = max - min;
  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;
};
const isEasingArray = (ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
};
function getEasingForSegment(easing, i) {
  return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;
}
function eraseKeyframes(sequence, startTime, endTime) {
  for (let i = 0; i < sequence.length; i++) {
    const keyframe = sequence[i];
    if (keyframe.at > startTime && keyframe.at < endTime) {
      removeItem(sequence, keyframe);
      i--;
    }
  }
}
function addKeyframes(sequence, keyframes2, easing, offset, startTime, endTime) {
  eraseKeyframes(sequence, startTime, endTime);
  for (let i = 0; i < keyframes2.length; i++) {
    sequence.push({
      value: keyframes2[i],
      at: mixNumber$1(startTime, endTime, offset[i]),
      easing: getEasingForSegment(easing, i)
    });
  }
}
function normalizeTimes(times, repeat) {
  for (let i = 0; i < times.length; i++) {
    times[i] = times[i] / (repeat + 1);
  }
}
function compareByTime(a, b) {
  if (a.at === b.at) {
    if (a.value === null)
      return 1;
    if (b.value === null)
      return -1;
    return 0;
  } else {
    return a.at - b.at;
  }
}
const progress = /* @__NO_SIDE_EFFECTS__ */ (from, to, value) => {
  const toFromDifference = to - from;
  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
};
function fillOffset(offset, remaining) {
  const min = offset[offset.length - 1];
  for (let i = 1; i <= remaining; i++) {
    const offsetProgress = /* @__PURE__ */ progress(0, remaining, i);
    offset.push(mixNumber$1(min, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset = [0];
  fillOffset(offset, arr.length - 1);
  return offset;
}
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration2 = 0;
  const timeStep = 50;
  let state2 = generator.next(duration2);
  while (!state2.done && duration2 < maxGeneratorDuration) {
    duration2 += timeStep;
    state2 = generator.next(duration2);
  }
  return duration2 >= maxGeneratorDuration ? Infinity : duration2;
}
function createGeneratorEasing(options, scale2 = 100, createGenerator) {
  const generator = createGenerator({ ...options, keyframes: [0, scale2] });
  const duration2 = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (progress2) => {
      return generator.next(duration2 * progress2).value / scale2;
    },
    duration: /* @__PURE__ */ millisecondsToSeconds(duration2)
  };
}
function isGenerator(type) {
  return typeof type === "function" && "applyToOptions" in type;
}
const defaultSegmentEasing = "easeInOut";
function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {
  const defaultDuration = defaultTransition.duration || 0.3;
  const animationDefinitions = /* @__PURE__ */ new Map();
  const sequences = /* @__PURE__ */ new Map();
  const elementCache = {};
  const timeLabels = /* @__PURE__ */ new Map();
  let prevTime = 0;
  let currentTime = 0;
  let totalDuration = 0;
  for (let i = 0; i < sequence.length; i++) {
    const segment = sequence[i];
    if (typeof segment === "string") {
      timeLabels.set(segment, currentTime);
      continue;
    } else if (!Array.isArray(segment)) {
      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));
      continue;
    }
    let [subject, keyframes2, transition = {}] = segment;
    if (transition.at !== void 0) {
      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);
    }
    let maxDuration = 0;
    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
      const valueKeyframesAsList = keyframesAsList(valueKeyframes);
      const { delay: delay2 = 0, times = defaultOffset(valueKeyframesAsList), type = "keyframes", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;
      let { ease: ease2 = defaultTransition.ease || "easeOut", duration: duration2 } = valueTransition;
      const calculatedDelay = typeof delay2 === "function" ? delay2(elementIndex, numSubjects) : delay2;
      const numKeyframes = valueKeyframesAsList.length;
      const createGenerator = isGenerator(type) ? type : generators == null ? void 0 : generators[type || "keyframes"];
      if (numKeyframes <= 2 && createGenerator) {
        let absoluteDelta = 100;
        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {
          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];
          absoluteDelta = Math.abs(delta);
        }
        const springTransition = { ...remainingTransition };
        if (duration2 !== void 0) {
          springTransition.duration = /* @__PURE__ */ secondsToMilliseconds(duration2);
        }
        const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);
        ease2 = springEasing.ease;
        duration2 = springEasing.duration;
      }
      duration2 ?? (duration2 = defaultDuration);
      const startTime = currentTime + calculatedDelay;
      if (times.length === 1 && times[0] === 0) {
        times[1] = 1;
      }
      const remainder = times.length - valueKeyframesAsList.length;
      remainder > 0 && fillOffset(times, remainder);
      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);
      if (repeat) {
        duration2 = calculateRepeatDuration(duration2, repeat);
        const originalKeyframes = [...valueKeyframesAsList];
        const originalTimes = [...times];
        ease2 = Array.isArray(ease2) ? [...ease2] : [ease2];
        const originalEase = [...ease2];
        for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {
          valueKeyframesAsList.push(...originalKeyframes);
          for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {
            times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));
            ease2.push(keyframeIndex === 0 ? "linear" : getEasingForSegment(originalEase, keyframeIndex - 1));
          }
        }
        normalizeTimes(times, repeat);
      }
      const targetTime = startTime + duration2;
      addKeyframes(valueSequence, valueKeyframesAsList, ease2, times, startTime, targetTime);
      maxDuration = Math.max(calculatedDelay + duration2, maxDuration);
      totalDuration = Math.max(targetTime, totalDuration);
    };
    if (isMotionValue(subject)) {
      const subjectSequence = getSubjectSequence(subject, sequences);
      resolveValueSequence(keyframes2, transition, getValueSequence("default", subjectSequence));
    } else {
      const subjects = resolveSubjects(subject, keyframes2, scope, elementCache);
      const numSubjects = subjects.length;
      for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {
        keyframes2 = keyframes2;
        transition = transition;
        const thisSubject = subjects[subjectIndex];
        const subjectSequence = getSubjectSequence(thisSubject, sequences);
        for (const key in keyframes2) {
          resolveValueSequence(keyframes2[key], getValueTransition$1(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);
        }
      }
    }
    prevTime = currentTime;
    currentTime += maxDuration;
  }
  sequences.forEach((valueSequences, element) => {
    for (const key in valueSequences) {
      const valueSequence = valueSequences[key];
      valueSequence.sort(compareByTime);
      const keyframes2 = [];
      const valueOffset = [];
      const valueEasing = [];
      for (let i = 0; i < valueSequence.length; i++) {
        const { at: at2, value, easing } = valueSequence[i];
        keyframes2.push(value);
        valueOffset.push(/* @__PURE__ */ progress(0, totalDuration, at2));
        valueEasing.push(easing || "easeOut");
      }
      if (valueOffset[0] !== 0) {
        valueOffset.unshift(0);
        keyframes2.unshift(keyframes2[0]);
        valueEasing.unshift(defaultSegmentEasing);
      }
      if (valueOffset[valueOffset.length - 1] !== 1) {
        valueOffset.push(1);
        keyframes2.push(null);
      }
      if (!animationDefinitions.has(element)) {
        animationDefinitions.set(element, {
          keyframes: {},
          transition: {}
        });
      }
      const definition = animationDefinitions.get(element);
      definition.keyframes[key] = keyframes2;
      definition.transition[key] = {
        ...defaultTransition,
        duration: totalDuration,
        ease: valueEasing,
        times: valueOffset,
        ...sequenceTransition
      };
    }
  });
  return animationDefinitions;
}
function getSubjectSequence(subject, sequences) {
  !sequences.has(subject) && sequences.set(subject, {});
  return sequences.get(subject);
}
function getValueSequence(name2, sequences) {
  if (!sequences[name2])
    sequences[name2] = [];
  return sequences[name2];
}
function keyframesAsList(keyframes2) {
  return Array.isArray(keyframes2) ? keyframes2 : [keyframes2];
}
function getValueTransition$1(transition, key) {
  return transition && transition[key] ? {
    ...transition,
    ...transition[key]
  } : { ...transition };
}
const isNumber = (keyframe) => typeof keyframe === "number";
const isNumberKeyframesArray = (keyframes2) => keyframes2.every(isNumber);
const isKeyframesTarget = (v) => {
  return Array.isArray(v);
};
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, props.custom, visualElement);
}
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
function resolveFinalValueInKeyframes(v) {
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
function isWillChangeMotionValue$1(value) {
  return Boolean(isMotionValue(value) && value.add);
}
function addValueToWillChange$1(visualElement, key) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue$1(willChange)) {
    return willChange.add(key);
  } else if (!willChange && MotionGlobalConfig.WillChange) {
    const newWillChange = new MotionGlobalConfig.WillChange("auto");
    visualElement.addValue("willChange", newWillChange);
    newWillChange.add(key);
  }
}
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
const isNotNull$1 = (value) => value !== null;
function getFinalKeyframe$1(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull$1);
  const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return resolvedKeyframes[index2];
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
  }
  return ease;
};
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
function getValueTransition(transition, key) {
  return (transition == null ? void 0 : transition[key]) ?? (transition == null ? void 0 : transition["default"]) ?? transition;
}
function makeAnimationInstant(options) {
  options.duration = 0;
  options.type === "keyframes";
}
function hueToRgb(p, q2, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q2 - p) * 6 * t;
  if (t < 1 / 2)
    return q2;
  if (t < 2 / 3)
    return p + (q2 - p) * (2 / 3 - t) * 6;
  return p;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p = 2 * lightness - q2;
    red = hueToRgb(p, q2, hue + 1 / 3);
    green = hueToRgb(p, q2, hue);
    blue = hueToRgb(p, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
function mixImmediate(a, b) {
  return (p) => p > 0 ? b : a;
}
const mixLinearColor = (from, to, v) => {
  const fromExpo = from * from;
  const expo = v * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v) => colorTypes.find((type) => type.test(v));
function asRGBA(color2) {
  const type = getColorType(color2);
  if (!Boolean(type))
    return false;
  let model = type.parse(color2);
  if (type === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from, to) => {
  const fromRGBA = asRGBA(from);
  const toRGBA = asRGBA(to);
  if (!fromRGBA || !toRGBA) {
    return mixImmediate(from, to);
  }
  const blended = { ...fromRGBA };
  return (v) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
    blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);
    return rgba.transform(blended);
  };
};
const invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin, target) {
  if (invisibleValues.has(origin)) {
    return (p) => p <= 0 ? origin : target;
  } else {
    return (p) => p >= 1 ? target : origin;
  }
}
const combineFunctions = (a, b) => (v) => b(a(v));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
function mixNumber(a, b) {
  return (p) => mixNumber$1(a, b, p);
}
function getMixer(a) {
  if (typeof a === "number") {
    return mixNumber;
  } else if (typeof a === "string") {
    return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
  } else if (Array.isArray(a)) {
    return mixArray;
  } else if (typeof a === "object") {
    return color.test(a) ? mixColor : mixObject;
  }
  return mixImmediate;
}
function mixArray(a, b) {
  const output = [...a];
  const numValues = output.length;
  const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
  return (p) => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](p);
    }
    return output;
  };
}
function mixObject(a, b) {
  const output = { ...a, ...b };
  const blendValue = {};
  for (const key in output) {
    if (a[key] !== void 0 && b[key] !== void 0) {
      blendValue[key] = getMixer(a[key])(a[key], b[key]);
    }
  }
  return (v) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v);
    }
    return output;
  };
}
function matchOrder(origin, target) {
  const orderedOrigin = [];
  const pointers = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < target.values.length; i++) {
    const type = target.types[i];
    const originIndex = origin.indexes[type][pointers[type]];
    const originValue = origin.values[originIndex] ?? 0;
    orderedOrigin[i] = originValue;
    pointers[type]++;
  }
  return orderedOrigin;
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
  if (canInterpolate) {
    if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
      return mixVisibility(origin, target);
    }
    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
  } else {
    return mixImmediate(origin, target);
  }
};
function mix(from, to, p) {
  if (typeof from === "number" && typeof to === "number" && typeof p === "number") {
    return mixNumber$1(from, to, p);
  }
  const mixer = getMixer(from);
  return mixer(from, to);
}
const frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time.now()
  };
};
const generateLinearEasing = (easing, duration2, resolution = 10) => {
  let points = "";
  const numPoints = Math.max(Math.round(duration2 / resolution), 2);
  for (let i = 0; i < numPoints; i++) {
    points += Math.round(easing(i / (numPoints - 1)) * 1e4) / 1e4 + ", ";
  }
  return `linear(${points.substring(0, points.length - 2)})`;
};
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue2, t, current) {
  const prevT = Math.max(t - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue2(prevT), t - prevT);
}
const springDefaults = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
};
const safeMin = 1e-3;
function findSpring({ duration: duration2 = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
  let envelope;
  let derivative;
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
  duration2 = clamp(springDefaults.minDuration, springDefaults.maxDuration, /* @__PURE__ */ millisecondsToSeconds(duration2));
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration2;
      const a = exponentialDecay - velocity;
      const b = calcAngularFreq(undampedFreq2, dampingRatio);
      const c2 = Math.exp(-delta);
      return safeMin - a / b * c2;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration2;
      const d = delta * velocity + velocity;
      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration2;
      const f = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration2);
      const b = (undampedFreq2 - velocity) * duration2 + 1;
      return -safeMin + a * b;
    };
    derivative = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration2);
      const b = (velocity - undampedFreq2) * (duration2 * duration2);
      return a * b;
    };
  }
  const initialGuess = 5 / duration2;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration2 = /* @__PURE__ */ secondsToMilliseconds(duration2);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration: duration2
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration: duration2
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    if (options.visualDuration) {
      const visualDuration = options.visualDuration;
      const root = 2 * Math.PI / (visualDuration * 1.2);
      const stiffness = root * root;
      const damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
      springOptions = {
        ...springOptions,
        mass: springDefaults.mass,
        stiffness,
        damping
      };
    } else {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: springDefaults.mass
      };
      springOptions.isResolvedFromDuration = true;
    }
  }
  return springOptions;
}
function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
  const options = typeof optionsOrVisualDuration !== "object" ? {
    visualDuration: optionsOrVisualDuration,
    keyframes: [0, 1],
    bounce
  } : optionsOrVisualDuration;
  let { restSpeed, restDelta } = options;
  const origin = options.keyframes[0];
  const target = options.keyframes[options.keyframes.length - 1];
  const state2 = { done: false, value: origin };
  const { stiffness, damping, mass, duration: duration2, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -/* @__PURE__ */ millisecondsToSeconds(options.velocity || 0)
  });
  const initialVelocity = velocity || 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = /* @__PURE__ */ millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
  restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t) => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      const freqForT = Math.min(dampedAngularFreq * t, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  const generator = {
    calculatedDuration: isResolvedFromDuration ? duration2 || null : null,
    next: (t) => {
      const current = resolveSpring(t);
      if (!isResolvedFromDuration) {
        let currentVelocity = t === 0 ? initialVelocity : 0;
        if (dampingRatio < 1) {
          currentVelocity = t === 0 ? /* @__PURE__ */ secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state2.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state2.done = t >= duration2;
      }
      state2.value = state2.done ? target : current;
      return state2;
    },
    toString: () => {
      const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
      const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
      return calculatedDuration + "ms " + easing;
    },
    toTransition: () => {
    }
  };
  return generator;
}
spring.applyToOptions = (options) => {
  const generatorOptions = createGeneratorEasing(options, 100, spring);
  options.ease = generatorOptions.ease;
  options.duration = /* @__PURE__ */ secondsToMilliseconds(generatorOptions.duration);
  options.type = "keyframes";
  return options;
};
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed }) {
  const origin = keyframes2[0];
  const state2 = {
    done: false,
    value: origin
  };
  const isOutOfBounds = (v) => min !== void 0 && v < min || max !== void 0 && v > max;
  const nearestBoundary = (v) => {
    if (min === void 0)
      return max;
    if (max === void 0)
      return min;
    return Math.abs(min - v) < Math.abs(max - v) ? min : max;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
  const calcLatest = (t) => target + calcDelta(t);
  const applyFriction = (t) => {
    const delta = calcDelta(t);
    const latest = calcLatest(t);
    state2.done = Math.abs(delta) <= restDelta;
    state2.value = state2.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t) => {
    if (!isOutOfBounds(state2.value))
      return;
    timeReachedBoundary = t;
    spring$1 = spring({
      keyframes: [state2.value, nearestBoundary(state2.value)],
      velocity: calcGeneratorVelocity(calcLatest, t, state2.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t);
        checkCatchBoundary(t);
      }
      if (timeReachedBoundary !== void 0 && t >= timeReachedBoundary) {
        return spring$1.next(t - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t);
        return state2;
      }
    }
  };
}
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i] || noop : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length);
  if (inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && output[0] === output[1])
    return () => output[1];
  const isZeroDeltaRange = input[0] === input[1];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = (v) => {
    if (isZeroDeltaRange && v < input[0])
      return output[0];
    let i = 0;
    if (numMixers > 1) {
      for (; i < input.length - 2; i++) {
        if (v < input[i + 1])
          break;
      }
    }
    const progressInRange = /* @__PURE__ */ progress(input[i], input[i + 1], v);
    return mixers[i](progressInRange);
  };
  return isClamp ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
}
function convertOffsetToTimes(offset, duration2) {
  return offset.map((o) => o * duration2);
}
const calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}
const easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1);
const easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1);
const easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1);
const mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
const reverseEasing = (easing) => (p) => 1 - easing(1 - p);
const backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = /* @__PURE__ */ reverseEasing(backOut);
const backInOut = /* @__PURE__ */ mirrorEasing(backIn);
const anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
const circIn = (p) => 1 - Math.sin(Math.acos(p));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circIn);
const isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";
const easingLookup = {
  linear: noop,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const isValidEasing = (easing) => {
  return typeof easing === "string";
};
const easingDefinitionToFunction = (definition) => {
  if (isBezierDefinition(definition)) {
    invariant(definition.length === 4);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (isValidEasing(definition)) {
    return easingLookup[definition];
  }
  return definition;
};
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({ duration: duration2 = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state2 = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration2
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration2,
    next: (t) => {
      state2.value = mapTimeToKeyframe(t);
      state2.done = t >= duration2;
      return state2;
    }
  };
}
const isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
  const resolvedKeyframes = keyframes2.filter(isNotNull);
  const useFirstKeyframe = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1;
  const index2 = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
  return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
}
const transitionTypeMap = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
function replaceTransitionType(transition) {
  if (typeof transition.type === "string") {
    transition.type = transitionTypeMap[transition.type];
  }
}
class WithPromise {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(onResolve, onReject) {
    return this.finished.then(onResolve, onReject);
  }
}
const percentToProgress = (percent2) => percent2 / 100;
class JSAnimation extends WithPromise {
  constructor(options) {
    super();
    this.state = "idle";
    this.startTime = null;
    this.isStopped = false;
    this.currentTime = 0;
    this.holdTime = null;
    this.playbackSpeed = 1;
    this.stop = () => {
      var _a, _b;
      const { motionValue: motionValue2 } = this.options;
      if (motionValue2 && motionValue2.updatedAt !== time.now()) {
        this.tick(time.now());
      }
      this.isStopped = true;
      if (this.state === "idle")
        return;
      this.teardown();
      (_b = (_a = this.options).onStop) == null ? void 0 : _b.call(_a);
    };
    this.options = options;
    this.initAnimation();
    this.play();
    if (options.autoplay === false)
      this.pause();
  }
  initAnimation() {
    const { options } = this;
    replaceTransitionType(options);
    const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
    let { keyframes: keyframes$1 } = options;
    const generatorFactory = type || keyframes;
    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
      this.mixKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
      keyframes$1 = [0, 100];
    }
    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
    if (repeatType === "mirror") {
      this.mirroredGenerator = generatorFactory({
        ...options,
        keyframes: [...keyframes$1].reverse(),
        velocity: -velocity
      });
    }
    if (generator.calculatedDuration === null) {
      generator.calculatedDuration = calcGeneratorDuration(generator);
    }
    const { calculatedDuration } = generator;
    this.calculatedDuration = calculatedDuration;
    this.resolvedDuration = calculatedDuration + repeatDelay;
    this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
    this.generator = generator;
  }
  updateTime(timestamp) {
    const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
    if (this.holdTime !== null) {
      this.currentTime = this.holdTime;
    } else {
      this.currentTime = animationTime;
    }
  }
  tick(timestamp, sample = false) {
    const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration } = this;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay2 = 0, keyframes: keyframes2, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe } = this.options;
    if (this.speed > 0) {
      this.startTime = Math.min(this.startTime, timestamp);
    } else if (this.speed < 0) {
      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
    }
    if (sample) {
      this.currentTime = timestamp;
    } else {
      this.updateTime(timestamp);
    }
    const timeWithoutDelay = this.currentTime - delay2 * (this.playbackSpeed >= 0 ? 1 : -1);
    const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0);
    if (this.state === "finished" && this.holdTime === null) {
      this.currentTime = totalDuration;
    }
    let elapsed = this.currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const isOddIteration = Boolean(currentIteration % 2);
      if (isOddIteration) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
    }
    const state2 = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
    if (mixKeyframes) {
      state2.value = mixKeyframes(state2.value);
    }
    let { done } = state2;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
    }
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    if (isAnimationFinished && type !== inertia) {
      state2.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe, this.speed);
    }
    if (onUpdate) {
      onUpdate(state2.value);
    }
    if (isAnimationFinished) {
      this.finish();
    }
    return state2;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.finished.then(resolve, reject);
  }
  get duration() {
    return /* @__PURE__ */ millisecondsToSeconds(this.calculatedDuration);
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    var _a;
    newTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
    this.currentTime = newTime;
    if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {
      this.holdTime = newTime;
    } else if (this.driver) {
      this.startTime = this.driver.now() - newTime / this.playbackSpeed;
    }
    (_a = this.driver) == null ? void 0 : _a.start(false);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    this.updateTime(time.now());
    const hasChanged2 = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed;
    if (hasChanged2) {
      this.time = /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
    }
  }
  play() {
    var _a, _b;
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, startTime } = this.options;
    if (!this.driver) {
      this.driver = driver((timestamp) => this.tick(timestamp));
    }
    (_b = (_a = this.options).onPlay) == null ? void 0 : _b.call(_a);
    const now2 = this.driver.now();
    if (this.state === "finished") {
      this.updateFinished();
      this.startTime = now2;
    } else if (this.holdTime !== null) {
      this.startTime = now2 - this.holdTime;
    } else if (!this.startTime) {
      this.startTime = startTime ?? now2;
    }
    if (this.state === "finished" && this.speed < 0) {
      this.startTime += this.calculatedDuration;
    }
    this.holdTime = null;
    this.state = "running";
    this.driver.start();
  }
  pause() {
    this.state = "paused";
    this.updateTime(time.now());
    this.holdTime = this.currentTime;
  }
  complete() {
    if (this.state !== "running") {
      this.play();
    }
    this.state = "finished";
    this.holdTime = null;
  }
  finish() {
    var _a, _b;
    this.notifyFinished();
    this.teardown();
    this.state = "finished";
    (_b = (_a = this.options).onComplete) == null ? void 0 : _b.call(_a);
  }
  cancel() {
    var _a, _b;
    this.holdTime = null;
    this.startTime = 0;
    this.tick(0);
    this.teardown();
    (_b = (_a = this.options).onCancel) == null ? void 0 : _b.call(_a);
  }
  teardown() {
    this.state = "idle";
    this.stopDriver();
    this.startTime = this.holdTime = null;
  }
  stopDriver() {
    if (!this.driver)
      return;
    this.driver.stop();
    this.driver = void 0;
  }
  sample(sampleTime) {
    this.startTime = 0;
    return this.tick(sampleTime, true);
  }
  attachTimeline(timeline) {
    var _a;
    if (this.options.allowFlatten) {
      this.options.type = "keyframes";
      this.options.ease = "linear";
      this.initAnimation();
    }
    (_a = this.driver) == null ? void 0 : _a.stop();
    return timeline.observe(this);
  }
}
const isCSSVar = (name2) => name2.startsWith("--");
function setStyle(element, name2, value) {
  isCSSVar(name2) ? element.style.setProperty(name2, value) : element.style[name2] = value;
}
// @__NO_SIDE_EFFECTS__
function memo(callback) {
  let result;
  return () => {
    if (result === void 0)
      result = callback();
    return result;
  };
}
const supportsScrollTimeline = /* @__PURE__ */ memo(() => (void 0).ScrollTimeline !== void 0);
const supportsFlags = {};
function memoSupports(callback, supportsFlag) {
  const memoized = /* @__PURE__ */ memo(callback);
  return () => supportsFlags[supportsFlag] ?? memoized();
}
const supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
  try {
    (void 0).createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch (e) {
    return false;
  }
  return true;
}, "linearEasing");
const cubicBezierAsString = ([a, b, c2, d]) => `cubic-bezier(${a}, ${b}, ${c2}, ${d})`;
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing, duration2) {
  if (!easing) {
    return void 0;
  } else if (typeof easing === "function") {
    return supportsLinearEasing() ? generateLinearEasing(easing, duration2) : "ease-out";
  } else if (isBezierDefinition(easing)) {
    return cubicBezierAsString(easing);
  } else if (Array.isArray(easing)) {
    return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration2) || supportedWaapiEasing.easeOut);
  } else {
    return supportedWaapiEasing[easing];
  }
}
function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration: duration2 = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeOut", times } = {}, pseudoElement = void 0) {
  const keyframeOptions = {
    [valueName]: keyframes2
  };
  if (times)
    keyframeOptions.offset = times;
  const easing = mapEasingToNativeEasing(ease2, duration2);
  if (Array.isArray(easing))
    keyframeOptions.easing = easing;
  const options = {
    delay: delay2,
    duration: duration2,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  };
  if (pseudoElement)
    options.pseudoElement = pseudoElement;
  const animation = element.animate(keyframeOptions, options);
  return animation;
}
function applyGeneratorOptions({ type, ...options }) {
  if (isGenerator(type) && supportsLinearEasing()) {
    return type.applyToOptions(options);
  } else {
    options.duration ?? (options.duration = 300);
    options.ease ?? (options.ease = "easeOut");
  }
  return options;
}
class NativeAnimation extends WithPromise {
  constructor(options) {
    super();
    this.finishedTime = null;
    this.isStopped = false;
    if (!options)
      return;
    const { element, name: name2, keyframes: keyframes2, pseudoElement, allowFlatten = false, finalKeyframe, onComplete } = options;
    this.isPseudoElement = Boolean(pseudoElement);
    this.allowFlatten = allowFlatten;
    this.options = options;
    invariant(typeof options.type !== "string");
    const transition = applyGeneratorOptions(options);
    this.animation = startWaapiAnimation(element, name2, keyframes2, transition, pseudoElement);
    if (transition.autoplay === false) {
      this.animation.pause();
    }
    this.animation.onfinish = () => {
      this.finishedTime = this.time;
      if (!pseudoElement) {
        const keyframe = getFinalKeyframe(keyframes2, this.options, finalKeyframe, this.speed);
        if (this.updateMotionValue) {
          this.updateMotionValue(keyframe);
        } else {
          setStyle(element, name2, keyframe);
        }
        this.animation.cancel();
      }
      onComplete == null ? void 0 : onComplete();
      this.notifyFinished();
    };
  }
  play() {
    if (this.isStopped)
      return;
    this.animation.play();
    if (this.state === "finished") {
      this.updateFinished();
    }
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    var _a, _b;
    (_b = (_a = this.animation).finish) == null ? void 0 : _b.call(_a);
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch (e) {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = true;
    const { state: state2 } = this;
    if (state2 === "idle" || state2 === "finished") {
      return;
    }
    if (this.updateMotionValue) {
      this.updateMotionValue();
    } else {
      this.commitStyles();
    }
    if (!this.isPseudoElement)
      this.cancel();
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    var _a, _b;
    if (!this.isPseudoElement) {
      (_b = (_a = this.animation).commitStyles) == null ? void 0 : _b.call(_a);
    }
  }
  get duration() {
    var _a, _b;
    const duration2 = ((_b = (_a = this.animation.effect) == null ? void 0 : _a.getComputedTiming) == null ? void 0 : _b.call(_a).duration) || 0;
    return /* @__PURE__ */ millisecondsToSeconds(Number(duration2));
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(Number(this.animation.currentTime) || 0);
  }
  set time(newTime) {
    this.finishedTime = null;
    this.animation.currentTime = /* @__PURE__ */ secondsToMilliseconds(newTime);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(newSpeed) {
    if (newSpeed < 0)
      this.finishedTime = null;
    this.animation.playbackRate = newSpeed;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(newStartTime) {
    this.animation.startTime = newStartTime;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline, observe }) {
    var _a;
    if (this.allowFlatten) {
      (_a = this.animation.effect) == null ? void 0 : _a.updateTiming({ easing: "linear" });
    }
    this.animation.onfinish = null;
    if (timeline && supportsScrollTimeline()) {
      this.animation.timeline = timeline;
      return noop;
    } else {
      return observe(this);
    }
  }
}
const unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(key) {
  return key in unsupportedEasingFunctions;
}
function replaceStringEasing(transition) {
  if (typeof transition.ease === "string" && isUnsupportedEase(transition.ease)) {
    transition.ease = unsupportedEasingFunctions[transition.ease];
  }
}
const sampleDelta = 10;
class NativeAnimationExtended extends NativeAnimation {
  constructor(options) {
    replaceStringEasing(options);
    replaceTransitionType(options);
    super(options);
    if (options.startTime) {
      this.startTime = options.startTime;
    }
    this.options = options;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read commited styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(value) {
    const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
    if (!motionValue2)
      return;
    if (value !== void 0) {
      motionValue2.set(value);
      return;
    }
    const sampleAnimation = new JSAnimation({
      ...options,
      autoplay: false
    });
    const sampleTime = /* @__PURE__ */ secondsToMilliseconds(this.finishedTime ?? this.time);
    motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
    sampleAnimation.stop();
  }
}
const isAnimatable = (value, name2) => {
  if (name2 === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};
function hasKeyframesChanged(keyframes2) {
  const current = keyframes2[0];
  if (keyframes2.length === 1)
    return true;
  for (let i = 0; i < keyframes2.length; i++) {
    if (keyframes2[i] !== current)
      return true;
  }
}
function canAnimate(keyframes2, name2, type, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null)
    return false;
  if (name2 === "display" || name2 === "visibility")
    return true;
  const targetKeyframe = keyframes2[keyframes2.length - 1];
  const isOriginAnimatable = isAnimatable(originKeyframe, name2);
  const isTargetAnimatable = isAnimatable(targetKeyframe, name2);
  if (!isOriginAnimatable || !isTargetAnimatable) {
    return false;
  }
  return hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]);
const supportsWaapi = /* @__PURE__ */ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function supportsBrowserAnimation(options) {
  var _a;
  const { motionValue: motionValue2, name: name2, repeatDelay, repeatType, damping, type } = options;
  const subject = (_a = motionValue2 == null ? void 0 : motionValue2.owner) == null ? void 0 : _a.current;
  if (!(subject instanceof HTMLElement)) {
    return false;
  }
  const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
  return supportsWaapi() && name2 && acceleratedValues.has(name2) && (name2 !== "transform" || !transformTemplate) && /**
  * If we're outputting values to onUpdate then we can't use WAAPI as there's
  * no way to read the value from WAAPI every frame.
  */
  !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
}
const MAX_RESOLVE_DELAY = 40;
class AsyncMotionValueAnimation extends WithPromise {
  constructor({ autoplay = true, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes: keyframes2, name: name2, motionValue: motionValue2, element, ...options }) {
    var _a;
    super();
    this.stop = () => {
      var _a2, _b;
      if (this._animation) {
        this._animation.stop();
        (_a2 = this.stopTimeline) == null ? void 0 : _a2.call(this);
      }
      (_b = this.keyframeResolver) == null ? void 0 : _b.cancel();
    };
    this.createdAt = time.now();
    const optionsWithDefaults = {
      autoplay,
      delay: delay2,
      type,
      repeat,
      repeatDelay,
      repeatType,
      name: name2,
      motionValue: motionValue2,
      element,
      ...options
    };
    const KeyframeResolver$1 = (element == null ? void 0 : element.KeyframeResolver) || KeyframeResolver;
    this.keyframeResolver = new KeyframeResolver$1(keyframes2, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name2, motionValue2, element);
    (_a = this.keyframeResolver) == null ? void 0 : _a.scheduleResolve();
  }
  onKeyframesResolved(keyframes2, finalKeyframe, options, sync) {
    this.keyframeResolver = void 0;
    const { name: name2, type, velocity, delay: delay2, isHandoff, onUpdate } = options;
    this.resolvedAt = time.now();
    if (!canAnimate(keyframes2, name2, type, velocity)) {
      if (MotionGlobalConfig.instantAnimations || !delay2) {
        onUpdate == null ? void 0 : onUpdate(getFinalKeyframe(keyframes2, options, finalKeyframe));
      }
      keyframes2[0] = keyframes2[keyframes2.length - 1];
      makeAnimationInstant(options);
      options.repeat = 0;
    }
    const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : void 0;
    const resolvedOptions = {
      startTime,
      finalKeyframe,
      ...options,
      keyframes: keyframes2
    };
    const animation = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended({
      ...resolvedOptions,
      element: resolvedOptions.motionValue.owner.current
    }) : new JSAnimation(resolvedOptions);
    animation.finished.then(() => this.notifyFinished()).catch(noop);
    if (this.pendingTimeline) {
      this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
      this.pendingTimeline = void 0;
    }
    this._animation = animation;
  }
  get finished() {
    if (!this._animation) {
      return this._finished;
    } else {
      return this.animation.finished;
    }
  }
  then(onResolve, _onReject) {
    return this.finished.finally(onResolve).then(() => {
    });
  }
  get animation() {
    var _a;
    if (!this._animation) {
      (_a = this.keyframeResolver) == null ? void 0 : _a.resume();
      flushKeyframeResolvers();
    }
    return this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(newTime) {
    this.animation.time = newTime;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(newSpeed) {
    this.animation.speed = newSpeed;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(timeline) {
    if (this._animation) {
      this.stopTimeline = this.animation.attachTimeline(timeline);
    } else {
      this.pendingTimeline = timeline;
    }
    return () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    var _a;
    if (this._animation) {
      this.animation.cancel();
    }
    (_a = this.keyframeResolver) == null ? void 0 : _a.cancel();
  }
}
const animateMotionValue = (name2, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition(transition, name2) || {};
  const delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - /* @__PURE__ */ secondsToMilliseconds(delay2);
  const options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v) => {
      value.set(v);
      valueTransition.onUpdate && valueTransition.onUpdate(v);
    },
    onComplete: () => {
      onComplete();
      valueTransition.onComplete && valueTransition.onComplete();
    },
    name: name2,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  if (!isTransitionDefined(valueTransition)) {
    Object.assign(options, getDefaultTransition(name2, options));
  }
  options.duration && (options.duration = /* @__PURE__ */ secondsToMilliseconds(options.duration));
  options.repeatDelay && (options.repeatDelay = /* @__PURE__ */ secondsToMilliseconds(options.repeatDelay));
  if (options.from !== void 0) {
    options.keyframes[0] = options.from;
  }
  let shouldSkip = false;
  if (options.type === false || options.duration === 0 && !options.repeatDelay) {
    makeAnimationInstant(options);
    if (options.delay === 0) {
      shouldSkip = true;
    }
  }
  if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {
    shouldSkip = true;
    makeAnimationInstant(options);
    options.delay = 0;
  }
  options.allowFlatten = !valueTransition.type && !valueTransition.ease;
  if (shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe$1(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0) {
      frame.update(() => {
        options.onUpdate(finalKeyframe);
        options.onComplete();
      });
      return;
    }
  }
  return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);
};
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  if (transitionOverride)
    transition = transitionOverride;
  const animations = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key in target) {
    const value = visualElement.getValue(key, visualElement.latestValues[key] ?? null);
    const valueTarget = target[key];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = {
      delay: delay2,
      ...getValueTransition(transition || {}, key)
    };
    const currentValue = value.get();
    if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity) {
      continue;
    }
    let isHandoff = false;
    if ((void 0).MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = (void 0).MotionHandoffAnimation(appearId, key, frame);
        if (startTime !== null) {
          valueTransition.startTime = startTime;
          isHandoff = true;
        }
      }
    }
    addValueToWillChange$1(visualElement, key);
    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? { type: false } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    if (animation) {
      animations.push(animation);
    }
  }
  if (transitionEnd) {
    Promise.all(animations).then(() => {
      frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
  }
  return animations;
}
function isObjectKey(key, object) {
  return key in object;
}
class ObjectVisualElement extends VisualElement {
  constructor() {
    super(...arguments);
    this.type = "object";
  }
  readValueFromInstance(instance, key) {
    if (isObjectKey(key, instance)) {
      const value = instance[key];
      if (typeof value === "string" || typeof value === "number") {
        return value;
      }
    }
    return void 0;
  }
  getBaseTargetFromProps() {
    return void 0;
  }
  removeValueFromRenderState(key, renderState) {
    delete renderState.output[key];
  }
  measureInstanceViewportBox() {
    return createBox$1();
  }
  build(renderState, latestValues) {
    Object.assign(renderState.output, latestValues);
  }
  renderInstance(instance, { output }) {
    Object.assign(instance, output);
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
function isObject(value) {
  return typeof value === "object" && value !== null;
}
function isSVGElement(element) {
  return isObject(element) && "ownerSVGElement" in element;
}
function isSVGSVGElement(element) {
  return isSVGElement(element) && element.tagName === "svg";
}
function createDOMVisualElement(element) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  };
  const node = isSVGElement(element) && !isSVGSVGElement(element) ? new SVGVisualElement(options) : new HTMLVisualElement(options);
  node.mount(element);
  visualElementStore.set(element, node);
}
function createObjectVisualElement(subject) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  };
  const node = new ObjectVisualElement(options);
  node.mount(subject);
  visualElementStore.set(subject, node);
}
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
  return motionValue$1.animation;
}
function isSingleValue(subject, keyframes2) {
  return isMotionValue(subject) || typeof subject === "number" || typeof subject === "string" && !isDOMKeyframes(keyframes2);
}
function animateSubject(subject, keyframes2, options, scope) {
  const animations = [];
  if (isSingleValue(subject, keyframes2)) {
    animations.push(animateSingleValue(subject, isDOMKeyframes(keyframes2) ? keyframes2.default || keyframes2 : keyframes2, options ? options.default || options : options));
  } else {
    const subjects = resolveSubjects(subject, keyframes2, scope);
    const numSubjects = subjects.length;
    for (let i = 0; i < numSubjects; i++) {
      const thisSubject = subjects[i];
      const createVisualElement2 = thisSubject instanceof Element ? createDOMVisualElement : createObjectVisualElement;
      if (!visualElementStore.has(thisSubject)) {
        createVisualElement2(thisSubject);
      }
      const visualElement = visualElementStore.get(thisSubject);
      const transition = { ...options };
      if ("delay" in transition && typeof transition.delay === "function") {
        transition.delay = transition.delay(i, numSubjects);
      }
      animations.push(...animateTarget(visualElement, { ...keyframes2, transition }, {}));
    }
  }
  return animations;
}
function animateSequence(sequence, options, scope) {
  const animations = [];
  const animationDefinitions = createAnimationsFromSequence(sequence, options, scope, { spring });
  animationDefinitions.forEach(({ keyframes: keyframes2, transition }, subject) => {
    animations.push(...animateSubject(subject, keyframes2, transition));
  });
  return animations;
}
class GroupAnimation {
  constructor(animations) {
    this.stop = () => this.runAll("stop");
    this.animations = animations.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((animation) => animation.finished));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(propName) {
    return this.animations[0][propName];
  }
  setAll(propName, newValue) {
    for (let i = 0; i < this.animations.length; i++) {
      this.animations[i][propName] = newValue;
    }
  }
  attachTimeline(timeline) {
    const subscriptions = this.animations.map((animation) => animation.attachTimeline(timeline));
    return () => {
      subscriptions.forEach((cancel, i) => {
        cancel && cancel();
        this.animations[i].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(time2) {
    this.setAll("time", time2);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(speed) {
    this.setAll("speed", speed);
  }
  get state() {
    return this.getAll("state");
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let max = 0;
    for (let i = 0; i < this.animations.length; i++) {
      max = Math.max(max, this.animations[i].duration);
    }
    return max;
  }
  runAll(methodName) {
    this.animations.forEach((controls) => controls[methodName]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
class GroupAnimationWithThen extends GroupAnimation {
  then(onResolve, _onReject) {
    return this.finished.finally(onResolve).then(() => {
    });
  }
}
function isSequence(value) {
  return Array.isArray(value) && value.some(Array.isArray);
}
function createScopedAnimate(scope) {
  function scopedAnimate(subjectOrSequence, optionsOrKeyframes, options) {
    let animations = [];
    if (isSequence(subjectOrSequence)) {
      animations = animateSequence(subjectOrSequence, optionsOrKeyframes, scope);
    } else {
      animations = animateSubject(subjectOrSequence, optionsOrKeyframes, options, scope);
    }
    const animation = new GroupAnimationWithThen(animations);
    return animation;
  }
  return scopedAnimate;
}
const animate = createScopedAnimate();
const STATE_TYPES = ["initial", "animate", "whileInView", "whileHover", "whilePress", "whileDrag", "whileFocus", "exit"];
class AnimationFeature extends Feature {
  constructor(state2) {
    var _a, _b;
    super(state2);
    this.animateUpdates = ({
      controlActiveState,
      directAnimate,
      directTransition,
      controlDelay = 0,
      isExit
    } = {}) => {
      const { reducedMotion } = this.state.options.motionConfig;
      this.state.visualElement.shouldReduceMotion = reducedMotion === "always" || reducedMotion === "user" && false;
      const prevTarget = this.state.target;
      this.state.target = { ...this.state.baseTarget };
      let animationOptions = {};
      animationOptions = this.resolveStateAnimation({
        controlActiveState,
        directAnimate,
        directTransition
      });
      this.state.finalTransition = animationOptions;
      const factories = this.createAnimationFactories(prevTarget, animationOptions, controlDelay);
      const { getChildAnimations } = this.setupChildAnimations(animationOptions, this.state.activeStates);
      return this.executeAnimations({
        factories,
        getChildAnimations,
        transition: animationOptions,
        controlActiveState,
        isExit
      });
    };
    this.state.visualElement = createVisualElement(this.state.options.as, {
      presenceContext: null,
      parent: (_a = this.state.parent) == null ? void 0 : _a.visualElement,
      props: {
        ...this.state.options,
        whileTap: this.state.options.whilePress
      },
      visualState: {
        renderState: {
          transform: {},
          transformOrigin: {},
          style: {},
          vars: {},
          attrs: {}
        },
        latestValues: {
          ...this.state.baseTarget
        }
      },
      reducedMotionConfig: this.state.options.motionConfig.reducedMotion
    });
    (_b = this.state.visualElement.parent) == null ? void 0 : _b.addChild(this.state.visualElement);
    this.state.animateUpdates = this.animateUpdates;
    if (this.state.isMounted())
      this.state.startAnimation();
  }
  updateAnimationControlsSubscription() {
    const { animate: animate2 } = this.state.options;
    if (isAnimationControls$1(animate2)) {
      this.unmountControls = animate2.subscribe(this.state);
    }
  }
  executeAnimations({
    factories,
    getChildAnimations,
    transition,
    controlActiveState,
    isExit = false
  }) {
    const getAnimation = () => Promise.all(factories.map((factory) => factory()).filter(Boolean));
    const animationTarget2 = { ...this.state.target };
    const element = this.state.element;
    const finishAnimation2 = (animationPromise) => {
      var _a, _b;
      element.dispatchEvent(motionEvent("motionstart", animationTarget2));
      (_b = (_a = this.state.options).onAnimationStart) == null ? void 0 : _b.call(_a, animationTarget2);
      animationPromise.then(() => {
        var _a2, _b2;
        element.dispatchEvent(motionEvent("motioncomplete", animationTarget2, isExit));
        (_b2 = (_a2 = this.state.options).onAnimationComplete) == null ? void 0 : _b2.call(_a2, animationTarget2);
      }).catch(noop);
    };
    const getAnimationPromise = () => {
      const animationPromise = (transition == null ? void 0 : transition.when) ? (transition.when === "beforeChildren" ? getAnimation() : getChildAnimations()).then(() => transition.when === "beforeChildren" ? getChildAnimations() : getAnimation()) : Promise.all([getAnimation(), getChildAnimations()]);
      finishAnimation2(animationPromise);
      return animationPromise;
    };
    return controlActiveState ? getAnimationPromise : getAnimationPromise();
  }
  /**
   * Setup child animations
   */
  setupChildAnimations(transition, controlActiveState) {
    var _a;
    const visualElement = this.state.visualElement;
    if (!((_a = visualElement.variantChildren) == null ? void 0 : _a.size) || !controlActiveState)
      return { getChildAnimations: () => Promise.resolve() };
    const { staggerChildren = 0, staggerDirection = 1, delayChildren = 0 } = transition || {};
    const numChildren = visualElement.variantChildren.size;
    const maxStaggerDuration = (numChildren - 1) * staggerChildren;
    const delayIsFunction = typeof delayChildren === "function";
    const generateStaggerDuration = delayIsFunction ? (i) => delayChildren(i, numChildren) : staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
    const childAnimations = Array.from(visualElement.variantChildren).map((child, index2) => {
      return child.state.animateUpdates({
        controlActiveState,
        controlDelay: (delayIsFunction ? 0 : delayChildren) + generateStaggerDuration(index2)
      });
    });
    return {
      getChildAnimations: () => Promise.all(childAnimations.map((animation) => {
        return animation();
      }))
    };
  }
  createAnimationFactories(prevTarget, animationOptions, controlDelay) {
    const factories = [];
    Object.keys(this.state.target).forEach((key) => {
      var _a;
      if (!hasChanged(prevTarget[key], this.state.target[key]))
        return;
      (_a = this.state.baseTarget)[key] ?? (_a[key] = style.get(this.state.element, key));
      const keyValue = this.state.target[key] === "none" && isDef(transformResetValue[key]) ? transformResetValue[key] : this.state.target[key];
      factories.push(() => {
        var _a2;
        return animate(
          this.state.element,
          { [key]: keyValue },
          {
            ...(animationOptions == null ? void 0 : animationOptions[key]) || animationOptions,
            delay: (((_a2 = animationOptions == null ? void 0 : animationOptions[key]) == null ? void 0 : _a2.delay) || (animationOptions == null ? void 0 : animationOptions.delay) || 0) + controlDelay
          }
        );
      });
    });
    return factories;
  }
  resolveStateAnimation({
    controlActiveState,
    directAnimate,
    directTransition
  }) {
    let variantTransition = this.state.options.transition;
    let variant = {};
    const { variants, custom, transition, animatePresenceContext } = this.state.options;
    const customValue = custom ?? (animatePresenceContext == null ? void 0 : animatePresenceContext.custom);
    this.state.activeStates = { ...this.state.activeStates, ...controlActiveState };
    STATE_TYPES.forEach((name2) => {
      if (!this.state.activeStates[name2] || isAnimationControls$1(this.state.options[name2]))
        return;
      const definition = this.state.options[name2];
      let resolvedVariant = isDef(definition) ? resolveVariant$1(definition, variants, customValue) : void 0;
      if (this.state.visualElement.isVariantNode) {
        const controlVariant = resolveVariant$1(this.state.context[name2], variants, customValue);
        resolvedVariant = controlVariant ? Object.assign(controlVariant || {}, resolvedVariant) : Object.assign(variant, resolvedVariant);
      }
      if (!resolvedVariant)
        return;
      if (name2 !== "initial")
        variantTransition = resolvedVariant.transition || this.state.options.transition || {};
      variant = Object.assign(variant, resolvedVariant);
    });
    if (directAnimate) {
      variant = resolveVariant$1(directAnimate, variants, customValue);
      variantTransition = variant.transition || directTransition || transition;
    }
    Object.entries(variant).forEach(([key, value]) => {
      if (key === "transition")
        return;
      this.state.target[key] = value;
    });
    return variantTransition;
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    var _a, _b;
    const { element } = this.state;
    mountedStates.set(element, this.state);
    if (!visualElementStore.get(element)) {
      this.state.visualElement.mount(element);
      visualElementStore.set(element, this.state.visualElement);
    }
    this.state.visualElement.state = this.state;
    this.updateAnimationControlsSubscription();
    const visualElement = this.state.visualElement;
    const parentVisualElement = visualElement.parent;
    visualElement.enteringChildren = void 0;
    if (((_a = this.state.parent) == null ? void 0 : _a.isMounted()) && !visualElement.isControllingVariants && ((_b = parentVisualElement == null ? void 0 : parentVisualElement.enteringChildren) == null ? void 0 : _b.has(visualElement))) {
      const { delayChildren } = this.state.parent.finalTransition || {};
      this.animateUpdates({
        controlActiveState: this.state.parent.activeStates,
        controlDelay: calcChildStagger(parentVisualElement.enteringChildren, visualElement, delayChildren)
      })();
    }
  }
  update() {
    const { animate: animate2 } = this.state.options;
    const { animate: prevAnimate } = this.state.visualElement.prevProps || {};
    if (animate2 !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
    var _a;
    (_a = this.unmountControls) == null ? void 0 : _a.call(this);
  }
}
function isHTMLElement$1(element) {
  return isObject(element) && "offsetHeight" in element;
}
const isDragging = {
  y: false
};
function isDragActive() {
  return isDragging.y;
}
const isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
const isPrimaryPointer$1 = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
function setupGesture(elementOrSelector, options) {
  const elements = resolveElements(elementOrSelector);
  const gestureAbortController = new AbortController();
  const eventOptions = {
    passive: true,
    ...options,
    signal: gestureAbortController.signal
  };
  const cancel = () => gestureAbortController.abort();
  return [elements, eventOptions, cancel];
}
const focusableElements = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function isElementKeyboardAccessible(element) {
  return focusableElements.has(element.tagName) || element.tabIndex !== -1;
}
const isPressing = /* @__PURE__ */ new WeakSet();
function filterEvents(callback) {
  return (event) => {
    if (event.key !== "Enter")
      return;
    callback(event);
  };
}
function firePointerEvent(target, type) {
  target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
}
const enableKeyboardPress = (focusEvent, eventOptions) => {
  const element = focusEvent.currentTarget;
  if (!element)
    return;
  const handleKeydown = filterEvents(() => {
    if (isPressing.has(element))
      return;
    firePointerEvent(element, "down");
    const handleKeyup = filterEvents(() => {
      firePointerEvent(element, "up");
    });
    const handleBlur = () => firePointerEvent(element, "cancel");
    element.addEventListener("keyup", handleKeyup, eventOptions);
    element.addEventListener("blur", handleBlur, eventOptions);
  });
  element.addEventListener("keydown", handleKeydown, eventOptions);
  element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
};
function isValidPressEvent(event) {
  return isPrimaryPointer$1(event) && true;
}
function press(targetOrSelector, onPressStart, options = {}) {
  const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
  const startPress = (startEvent) => {
    const target = startEvent.currentTarget;
    if (!isValidPressEvent(startEvent))
      return;
    isPressing.add(target);
    const onPressEnd = onPressStart(target, startEvent);
    const onPointerEnd = (endEvent, success) => {
      (void 0).removeEventListener("pointerup", onPointerUp);
      (void 0).removeEventListener("pointercancel", onPointerCancel);
      if (isPressing.has(target)) {
        isPressing.delete(target);
      }
      if (!isValidPressEvent(endEvent)) {
        return;
      }
      if (typeof onPressEnd === "function") {
        onPressEnd(endEvent, { success });
      }
    };
    const onPointerUp = (upEvent) => {
      onPointerEnd(upEvent, target === void 0 || target === void 0 || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
    };
    const onPointerCancel = (cancelEvent) => {
      onPointerEnd(cancelEvent, false);
    };
    (void 0).addEventListener("pointerup", onPointerUp, eventOptions);
    (void 0).addEventListener("pointercancel", onPointerCancel, eventOptions);
  };
  targets.forEach((target) => {
    const pointerDownTarget = options.useGlobalTarget ? void 0 : target;
    pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
    if (isHTMLElement$1(target)) {
      target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions));
      if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) {
        target.tabIndex = 0;
      }
    }
  });
  return cancelEvents;
}
function extractEventInfo$1(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY
    }
  };
}
function handlePressEvent(state2, event, lifecycle) {
  const props = state2.options;
  if (props.whilePress) {
    state2.setActive("whilePress", lifecycle === "Start");
  }
  const eventName = `onPress${lifecycle === "End" ? "" : lifecycle}`;
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo$1(event)));
  }
}
class PressGesture extends Feature {
  isActive() {
    const { whilePress, onPress, onPressCancel, onPressStart } = this.state.options;
    return Boolean(whilePress || onPress || onPressCancel || onPressStart);
  }
  constructor(state2) {
    super(state2);
  }
  mount() {
    this.register();
  }
  update() {
    const { whilePress, onPress, onPressCancel, onPressStart } = this.state.options;
    if (!(whilePress || onPress || onPressCancel || onPressStart)) {
      this.register();
    }
  }
  register() {
    const element = this.state.element;
    if (!element || !this.isActive())
      return;
    this.unmount();
    this.unmount = press(
      element,
      (el, startEvent) => {
        handlePressEvent(this.state, startEvent, "Start");
        return (endEvent, { success }) => handlePressEvent(
          this.state,
          endEvent,
          success ? "End" : "Cancel"
        );
      },
      { useGlobalTarget: this.state.options.globalPressTarget }
    );
  }
}
function isValidHover(event) {
  return !(event.pointerType === "touch" || isDragActive());
}
function hover(elementOrSelector, onHoverStart, options = {}) {
  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
  const onPointerEnter = (enterEvent) => {
    if (!isValidHover(enterEvent))
      return;
    const { target } = enterEvent;
    const onHoverEnd = onHoverStart(target, enterEvent);
    if (typeof onHoverEnd !== "function" || !target)
      return;
    const onPointerLeave = (leaveEvent) => {
      if (!isValidHover(leaveEvent))
        return;
      onHoverEnd(leaveEvent);
      target.removeEventListener("pointerleave", onPointerLeave);
    };
    target.addEventListener("pointerleave", onPointerLeave, eventOptions);
  };
  elements.forEach((element) => {
    element.addEventListener("pointerenter", onPointerEnter, eventOptions);
  });
  return cancel;
}
function handleHoverEvent$1(state2, event, lifecycle) {
  const props = state2.options;
  if (props.whileHover) {
    state2.setActive("whileHover", lifecycle === "Start");
  }
  const eventName = `onHover${lifecycle}`;
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo$1(event)));
  }
}
class HoverGesture extends Feature {
  isActive() {
    const { whileHover, onHoverStart, onHoverEnd } = this.state.options;
    return Boolean(whileHover || onHoverStart || onHoverEnd);
  }
  constructor(state2) {
    super(state2);
  }
  mount() {
    this.register();
  }
  update() {
    const { whileHover, onHoverStart, onHoverEnd } = this.state.visualElement.prevProps;
    if (!(whileHover || onHoverStart || onHoverEnd)) {
      this.register();
    }
  }
  register() {
    const element = this.state.element;
    if (!element || !this.isActive())
      return;
    this.unmount();
    this.unmount = hover(
      element,
      (el, startEvent) => {
        handleHoverEvent$1(this.state, startEvent, "Start");
        return (endEvent) => {
          handleHoverEvent$1(this.state, endEvent, "End");
        };
      }
    );
  }
}
const thresholds = {
  some: 0,
  all: 1
};
function inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = "some" } = {}) {
  const elements = resolveElements(elementOrSelector);
  const activeIntersections = /* @__PURE__ */ new WeakMap();
  const onIntersectionChange = (entries) => {
    entries.forEach((entry2) => {
      const onEnd = activeIntersections.get(entry2.target);
      if (entry2.isIntersecting === Boolean(onEnd))
        return;
      if (entry2.isIntersecting) {
        const newOnEnd = onStart(entry2.target, entry2);
        if (typeof newOnEnd === "function") {
          activeIntersections.set(entry2.target, newOnEnd);
        } else {
          observer.unobserve(entry2.target);
        }
      } else if (typeof onEnd === "function") {
        onEnd(entry2);
        activeIntersections.delete(entry2.target);
      }
    });
  };
  const observer = new IntersectionObserver(onIntersectionChange, {
    root,
    rootMargin,
    threshold: typeof amount === "number" ? amount : thresholds[amount]
  });
  elements.forEach((element) => observer.observe(element));
  return () => observer.disconnect();
}
function handleHoverEvent(state2, entry2, lifecycle) {
  const props = state2.options;
  if (props.whileInView) {
    state2.setActive("whileInView", lifecycle === "Enter");
  }
  const eventName = `onViewport${lifecycle}`;
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(entry2));
  }
}
class InViewGesture extends Feature {
  isActive() {
    const { whileInView, onViewportEnter, onViewportLeave } = this.state.options;
    return Boolean(whileInView || onViewportEnter || onViewportLeave);
  }
  constructor(state2) {
    super(state2);
  }
  startObserver() {
    const element = this.state.element;
    if (!element || !this.isActive())
      return;
    this.unmount();
    const { once, ...viewOptions } = this.state.options.inViewOptions || {};
    this.unmount = inView(
      element,
      (_2, entry2) => {
        handleHoverEvent(this.state, entry2, "Enter");
        if (!once) {
          return (endEvent) => {
            handleHoverEvent(this.state, entry2, "Leave");
          };
        }
      },
      viewOptions
    );
  }
  mount() {
    this.startObserver();
  }
  update() {
    const { props, prevProps } = this.state.visualElement;
    const hasOptionsChanged = ["amount", "margin", "root"].some(
      hasViewportOptionChanged(props, prevProps)
    );
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
}
function hasViewportOptionChanged({ inViewOptions = {} }, { inViewOptions: prevViewport = {} } = {}) {
  return (name2) => inViewOptions[name2] !== prevViewport[name2];
}
function addDomEvent$1(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    try {
      isFocusVisible = this.state.element.matches(":focus-visible");
    } catch (e) {
      isFocusVisible = true;
    }
    if (!isFocusVisible)
      return;
    this.state.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive)
      return;
    this.state.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(
      addDomEvent$1(this.state.element, "focus", () => this.onFocus()),
      addDomEvent$1(this.state.element, "blur", () => this.onBlur())
    );
  }
}
const compareByDepth = (a, b) => a.depth - b.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
function resolveMotionValue(value) {
  return isMotionValue(value) ? value.get() : value;
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber$1(0, lead.opacity ?? 1, easeCrossfadeIn(progress2));
    target.opacityExit = mixNumber$1(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mixNumber$1(follow.opacity ?? 1, lead.opacity ?? 1, progress2);
  }
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut);
const easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop);
function compress(min, max, easing) {
  return (p) => {
    if (p < min)
      return 0;
    if (p > max)
      return 1;
    return easing(/* @__PURE__ */ progress(min, max, p));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate;
  delta.scale = originDelta.scale;
  delta.originPoint = originDelta.originPoint;
  delta.origin = originDelta.origin;
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate2, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate2;
}
function applyAxisDelta(axis, translate2 = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate2, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate2, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x, y }) {
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999;
const TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta = node.projectionDelta;
    const { visualElement } = node.options;
    if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
    treeScale.x = 1;
  }
  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
    treeScale.y = 1;
  }
}
function translateAxis$1(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform2) {
  transformAxis(box.x, transform2.x, transform2.scaleX, transform2.scale, transform2.originX);
  transformAxis(box.y, transform2.y, transform2.scaleY, transform2.scale, transform2.originY);
}
const SCALE_PRECISION = 1e-4;
const SCALE_MIN = 1 - SCALE_PRECISION;
const SCALE_MAX = 1 + SCALE_PRECISION;
const TRANSLATE_PRECISION = 0.01;
const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength$1(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
  delta.scale = calcLength$1(target) / calcLength$1(source);
  delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
  if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
    delta.scale = 1;
  }
  if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
    delta.translate = 0;
  }
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength$1(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout, parent) {
  target.min = layout.min - parent.min;
  target.max = target.min + calcLength$1(layout);
}
function calcRelativePosition(target, layout, parent) {
  calcRelativeAxisPosition(target.x, layout.x, parent.x);
  calcRelativeAxisPosition(target.y, layout.y, parent.y);
}
function removePointDelta(point, translate2, scale2, originPoint, boxScale) {
  point -= translate2;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate2 = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate2)) {
    translate2 = parseFloat(translate2);
    const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate2 / 100);
    translate2 = relativeProgress - sourceAxis.min;
  }
  if (typeof translate2 !== "number")
    return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate2;
  axis.min = removePointDelta(axis.min, translate2, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate2, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms2, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms2[key], transforms2[scaleKey], transforms2[originKey], transforms2.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms2, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms2, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms2, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a, b) {
  return a.min === b.min && a.max === b.max;
}
function boxEquals(a, b) {
  return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
}
function axisEqualsRounded(a, b) {
  return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
}
function boxEqualsRounded(a, b) {
  return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
}
function aspectRatio(box) {
  return calcLength$1(box.x) / calcLength$1(box.y);
}
function axisDeltaEquals(a, b) {
  return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node.root && node.root.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      const { options, resumingFrom } = node;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform2 = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  const zTranslate = (latestTransform == null ? void 0 : latestTransform.z) || 0;
  if (xTranslate || yTranslate || zTranslate) {
    transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { transformPerspective, rotate: rotate2, rotateX, rotateY, skewX, skewY } = latestTransform;
    if (transformPerspective)
      transform2 = `perspective(${transformPerspective}px) ${transform2}`;
    if (rotate2)
      transform2 += `rotate(${rotate2}deg) `;
    if (rotateX)
      transform2 += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform2 += `rotateY(${rotateY}deg) `;
    if (skewX)
      transform2 += `skewX(${skewX}deg) `;
    if (skewY)
      transform2 += `skewY(${skewY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform2 += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform2 || "none";
}
function eachAxis$1(callback) {
  return [callback("x"), callback("y")];
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
const transformAxes = ["", "X", "Y", "Z"];
const animationTarget = 1e3;
let id$2 = 0;
function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
  const { latestValues } = visualElement;
  if (latestValues[key]) {
    values[key] = latestValues[key];
    visualElement.setStaticValue(key, 0);
    if (sharedAnimationValues) {
      sharedAnimationValues[key] = 0;
    }
  }
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  projectionNode.hasCheckedOptimisedAppear = true;
  if (projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if ((void 0).MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout, layoutId } = projectionNode.options;
    (void 0).MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout || layoutId));
  }
  const { parent } = projectionNode;
  if (parent && !parent.hasCheckedOptimisedAppear) {
    cancelTreeOptimisedTransformAnimations(parent);
  }
}
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent == null ? void 0 : defaultParent()) {
      this.id = id$2++;
      this.animationId = 0;
      this.animationCommitId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.hasCheckedOptimisedAppear = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.scheduleUpdate = () => this.update();
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
      };
      this.resolvedRelativeTargetAt = 0;
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name2, handler) {
      if (!this.eventHandlers.has(name2)) {
        this.eventHandlers.set(name2, new SubscriptionManager());
      }
      return this.eventHandlers.get(name2).add(handler);
    }
    notifyListeners(name2, ...args) {
      const subscriptionManager = this.eventHandlers.get(name2);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name2) {
      return this.eventHandlers.has(name2);
    }
    /**
     * Lifecycles
     */
    mount(instance) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (this.root.hasTreeAnimated && (layout || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        let innerWidth = 0;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        frame.read(() => {
          innerWidth = (void 0).innerWidth;
        });
        attachResizeListener(instance, () => {
          const newInnerWidth = (void 0).innerWidth;
          if (newInnerWidth === innerWidth)
            return;
          innerWidth = newInnerWidth;
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay$1(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
          if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      this.eventHandlers.clear();
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetSkewAndRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if ((void 0).MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
        cancelTreeOptimisedTransformAnimations(this);
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const { layoutId, layout } = this.options;
      if (layoutId === void 0 && !layout)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(clearIsLayoutDirty);
        return;
      }
      this.animationCommitId = this.animationId;
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      } else {
        this.isUpdating = false;
        this.nodes.forEach(resetTransformStyle);
        this.nodes.forEach(updateLayout);
        this.nodes.forEach(notifyLayoutUpdate);
      }
      this.clearAllSnapshots();
      const now2 = time.now();
      frameData.delta = clamp(0, 1e3 / 60, now2 - frameData.timestamp);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      frameSteps.update.process(frameData);
      frameSteps.preRender.process(frameData);
      frameSteps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(this.scheduleUpdate);
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
      if (this.snapshot && !calcLength$1(this.snapshot.measuredBox.x) && !calcLength$1(this.snapshot.measuredBox.y)) {
        this.snapshot = void 0;
      }
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox$1();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement && this.instance) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var _a;
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox$1();
      const box = visualElement.measureViewportBox();
      const wasInScrollRoot = ((_a = this.scroll) == null ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);
      if (!wasInScrollRoot) {
        const { scroll } = this.root;
        if (scroll) {
          translateAxis$1(box.x, scroll.offset.x);
          translateAxis$1(box.y, scroll.offset.y);
        }
      }
      return box;
    }
    removeElementScroll(box) {
      var _a;
      const boxWithoutScroll = createBox$1();
      copyBoxInto(boxWithoutScroll, box);
      if ((_a = this.scroll) == null ? void 0 : _a.wasRoot) {
        return boxWithoutScroll;
      }
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        const { scroll, options } = node;
        if (node !== this.root && scroll && options.layoutScroll) {
          if (scroll.wasRoot) {
            copyBoxInto(boxWithoutScroll, box);
          }
          translateAxis$1(boxWithoutScroll.x, scroll.offset.x);
          translateAxis$1(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox$1();
      copyBoxInto(withTransforms, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox$1();
      copyBoxInto(boxWithoutTransform, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox$1();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) == null ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
      if (canSkip)
        return;
      const { layout, layoutId } = this.options;
      if (!this.layout || !(layout || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox$1();
          this.relativeTargetOrigin = createBox$1();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox$1();
        this.targetWithTransforms = createBox$1();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox$1();
          this.relativeTargetOrigin = createBox$1();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a = this.parent) == null ? void 0 : _a.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox$1();
      }
      const { target } = lead;
      if (!target) {
        if (this.prevProjectionDelta) {
          this.createProjectionDeltas();
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta || !this.prevProjectionDelta) {
        this.createProjectionDeltas();
      } else {
        copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
        copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
      }
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      var _a;
      (_a = this.options.visualElement) == null ? void 0 : _a.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta();
      this.projectionDelta = createDelta();
      this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox$1();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox$1();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      var _a, _b, _c;
      this.notifyListeners("animationStart");
      (_a = this.currentAnimation) == null ? void 0 : _a.stop();
      (_c = (_b = this.resumingFrom) == null ? void 0 : _b.currentAnimation) == null ? void 0 : _c.stop();
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.motionValue || (this.motionValue = motionValue(0));
        this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
          ...options,
          velocity: 0,
          isSync: true,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onStop: () => {
          },
          onComplete: () => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout)
        return;
      if (this !== lead && this.layout && layout && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {
        target = this.target || createBox$1();
        const xLength = calcLength$1(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength$1(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      const config = node.options.initialPromotionConfig;
      node.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? ((_a = this.getStack()) == null ? void 0 : _a.lead) || this : this;
    }
    getPrevLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? (_a = this.getStack()) == null ? void 0 : _a.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = false;
      const { latestValues } = visualElement;
      if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
        hasDistortingTransform = true;
      }
      if (!hasDistortingTransform)
        return;
      const resetValues = {};
      if (latestValues.z) {
        resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      }
      for (let i = 0; i < transformAxes.length; i++) {
        resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
        resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
      }
      visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
        if (this.animationValues) {
          this.animationValues[key] = resetValues[key];
        }
      }
      visualElement.scheduleRender();
    }
    applyProjectionStyles(targetStyle, styleProp) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        targetStyle.visibility = "hidden";
        return;
      }
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        targetStyle.visibility = "";
        targetStyle.opacity = "";
        targetStyle.pointerEvents = resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "";
        targetStyle.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        if (this.options.layoutId) {
          targetStyle.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          targetStyle.pointerEvents = resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          targetStyle.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return;
      }
      targetStyle.visibility = "";
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      let transform2 = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        transform2 = transformTemplate(valuesToRender, transform2);
      }
      targetStyle.transform = transform2;
      const { x, y } = this.projectionDelta;
      targetStyle.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
      if (lead.animationValues) {
        targetStyle.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        targetStyle.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];
        const corrected = transform2 === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i = 0; i < num; i++) {
            targetStyle[applyTo[i]] = corrected;
          }
        } else {
          if (isCSSVariable) {
            this.options.visualElement.renderState.vars[key] = corrected;
          } else {
            targetStyle[key] = corrected;
          }
        }
      }
      if (this.options.layoutId) {
        targetStyle.pointerEvents = lead === this ? resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "" : "none";
      }
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a;
        return (_a = node.currentAnimation) == null ? void 0 : _a.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a;
  const snapshot = ((_a = node.resumeFrom) == null ? void 0 : _a.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;
    const { animationType } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    if (animationType === "size") {
      eachAxis$1((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength$1(axisSnapshot);
        axisSnapshot.min = layout[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {
      eachAxis$1((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength$1(layout[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
        if (node.relativeTarget && !node.currentAnimation) {
          node.isProjectionDirty = true;
          node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeLayoutChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox$1();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox$1();
          calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeLayoutChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeLayoutChanged
    });
  } else if (node.isLead()) {
    const { onExitComplete } = node.options;
    onExitComplete && onExitComplete();
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node) {
  if (!node.parent)
    return;
  if (!node.isProjecting()) {
    node.isProjectionDirty = node.parent.isProjectionDirty;
  }
  node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
  node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
}
function cleanDirtyNodes(node) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function clearIsLayoutDirty(node) {
  node.isLayoutDirty = false;
}
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
  node.isProjectionDirty = true;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetSkewAndRotation(node) {
  node.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p) {
  output.translate = mixNumber$1(delta.translate, 0, p);
  output.scale = mixNumber$1(delta.scale, 1, p);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to, p) {
  output.min = mixNumber$1(from.min, to.min, p);
  output.max = mixNumber$1(from.max, to.max, p);
}
function mixBox(output, from, to, p) {
  mixAxis(output.x, from.x, to.x, p);
  mixAxis(output.y, from.y, to.y, p);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
const roundPoint = noop;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2);
}
function checkNodeWasScrollRoot(node) {
  var _a;
  return node !== node.root && ((_a = node.scroll) == null ? void 0 : _a.wasRoot);
}
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref2, notify) => addDomEvent(ref2, "resize", notify),
  measureScroll: () => ({
    x: (void 0).documentElement.scrollLeft || (void 0).body.scrollLeft,
    y: (void 0).documentElement.scrollTop || (void 0).body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(void 0);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean((void 0).getComputedStyle(instance).position === "fixed")
});
function getClosestProjectingNode(visualElement) {
  if (!visualElement)
    return void 0;
  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x = pixelsToPercent(latest, node.target.x);
    const y = pixelsToPercent(latest, node.target.y);
    return `${x}% ${y}%`;
  }
};
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= yScale;
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset] === "number")
      shadow[2 + offset] /= averageScale;
    if (typeof shadow[3 + offset] === "number")
      shadow[3 + offset] /= averageScale;
    return template(shadow);
  }
};
const defaultScaleCorrector = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
function isHTMLElement(value) {
  return typeof value === "object" && value !== null && "nodeType" in value;
}
class ProjectionFeature extends Feature {
  constructor(state2) {
    super(state2);
    addScaleCorrector(defaultScaleCorrector);
  }
  initProjection() {
    const options = this.state.options;
    this.state.visualElement.projection = new HTMLProjectionNode(
      this.state.visualElement.latestValues,
      options["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(this.state.visualElement.parent)
    );
    this.state.visualElement.projection.isPresent = true;
    this.setOptions();
  }
  beforeMount() {
    this.initProjection();
  }
  setOptions() {
    const options = this.state.options;
    this.state.visualElement.projection.setOptions({
      layout: options.layout,
      layoutId: options.layoutId,
      alwaysMeasureLayout: Boolean(options.drag) || options.dragConstraints && isHTMLElement(options.dragConstraints),
      visualElement: this.state.visualElement,
      animationType: typeof options.layout === "string" ? options.layout : "both",
      // initialPromotionConfig
      layoutRoot: options.layoutRoot,
      layoutScroll: options.layoutScroll,
      crossfade: options.crossfade,
      onExitComplete: () => {
        var _a;
        if (!((_a = this.state.visualElement.projection) == null ? void 0 : _a.isPresent)) {
          const done = doneCallbacks.get(this.state.element);
          this.state.isSafeToRemove = true;
          if (done) {
            done({
              detail: {
                isExit: true
              }
            }, true);
          }
        }
      }
    });
  }
  update() {
    this.setOptions();
  }
  mount() {
    var _a;
    (_a = this.state.visualElement.projection) == null ? void 0 : _a.mount(this.state.element);
  }
}
function isPrimaryPointer(event) {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
}
function extractEventInfo(event, pointType = "page") {
  return {
    point: {
      x: event[`${pointType}X`],
      y: event[`${pointType}Y`]
    }
  };
}
function addPointerInfo(handler) {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
}
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent$1(target, eventName, addPointerInfo(handler), options);
}
function createLock(name2) {
  let lock = null;
  return () => {
    const openLock = () => {
      lock = null;
    };
    if (lock === null) {
      lock = name2;
      return openLock;
    }
    return false;
  };
}
const globalHorizontalLock = createLock("dragHorizontal");
const globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag) {
  let lock = false;
  if (drag === "y") {
    lock = globalVerticalLock();
  } else if (drag === "x") {
    lock = globalHorizontalLock();
  } else {
    const openHorizontal = globalHorizontalLock();
    const openVertical = globalVerticalLock();
    if (openHorizontal && openVertical) {
      lock = () => {
        openHorizontal();
        openVertical();
      };
    } else {
      if (openHorizontal)
        openHorizontal();
      if (openVertical)
        openVertical();
    }
  }
  return lock;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function applyConstraints(point, { min, max }, elastic) {
  if (min !== void 0 && point < min) {
    point = elastic ? mixNumber$1(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== void 0 && point > max) {
    point = elastic ? mixNumber$1(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
const defaultElastic = 0.35;
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
function rebaseAxisConstraints(layout, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout.min;
  }
  return relativeConstraints;
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min = constraintsAxis.min - layoutAxis.min;
  let max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min, max] = [max, min];
  }
  return { min, max };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = /* @__PURE__ */ progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = /* @__PURE__ */ progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
const distance = (a, b) => Math.abs(a - b);
function distance2D(a, b) {
  const xDelta = distance(a.x, b.x);
  const yDelta = distance(a.y, b.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers2, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.contextWindow = void 0;
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin)
        resumeAnimation && resumeAnimation();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(
        event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint),
        this.history
      );
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin;
    this.handlers = handlers2;
    this.transformPagePoint = transformPagePoint;
    this.contextWindow = contextWindow || void 0;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers2;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(
      addPointerEvent(
        this.contextWindow,
        "pointermove",
        this.handlePointerMove
      ),
      addPointerEvent(
        this.contextWindow,
        "pointerup",
        this.handlePointerUp
      ),
      addPointerEvent(
        this.contextWindow,
        "pointercancel",
        this.handlePointerUp
      )
    );
  }
  updateHandlers(handlers2) {
    this.handlers = handlers2;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > /* @__PURE__ */ secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time2 = /* @__PURE__ */ millisecondsToSeconds(
    lastPoint.timestamp - timestampedPoint.timestamp
  );
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
const createAxis = () => ({ min: 0, max: 0 });
function createBox() {
  return {
    x: createAxis(),
    y: createAxis()
  };
}
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
function addValueToWillChange(visualElement, key) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange)) {
    return willChange.add(key);
  }
}
function convertBoundingBoxToBox({
  top,
  left,
  right,
  bottom
}) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function convertBoxToBoundingBox({ x, y }) {
  return { top: y.min, right: x.max, bottom: y.max, left: x.min };
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(
    transformBoxPoints(instance.getBoundingClientRect(), transformPoint2)
  );
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll } = rootProjectionNode2;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.offset.x);
    translateAxis(viewportBox.y, scroll.offset.y);
  }
  return viewportBox;
}
function isPresent(visualElement) {
  return !doneCallbacks.has(visualElement.current);
}
function getContextWindow({ current }) {
  return current ? current.ownerDocument.defaultView : null;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    if (!isPresent(this.visualElement))
      return;
    const onSessionStart = (event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event, "page").point);
      }
    };
    const onStart = (event, info) => {
      const { drag, dragPropagation, onDragStart } = this.getProps();
      if (drag && !dragPropagation) {
        if (this.openGlobalLock)
          this.openGlobalLock();
        this.openGlobalLock = getGlobalLock(drag);
        if (!this.openGlobalLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection: projection2 } = this.visualElement;
          if (projection2 && projection2.layout) {
            const measuredAxis = projection2.layout.layoutBox[axis];
            if (measuredAxis) {
              const length = calcLength(measuredAxis);
              current = length * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.postRender(() => onDragStart(event, info));
      }
      addValueToWillChange(this.visualElement, "transform");
      const state2 = this.visualElement.state;
      state2.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      const {
        dragPropagation,
        dragDirectionLock,
        onDirectionLock,
        onDrag
      } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset);
      this.updateAxis("y", info.point, offset);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    const resumeAnimation = () => eachAxis(
      (axis) => {
        var _a;
        return this.getAnimationState(axis) === "paused" && ((_a = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a.play());
      }
    );
    const { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(
      originEvent,
      {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd,
        resumeAnimation
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin,
        contextWindow: getContextWindow(this.visualElement)
      }
    );
  }
  stop(event, info) {
    const isDragging2 = this.isDragging;
    this.cancel();
    if (!isDragging2)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.postRender(() => onDragEnd(event, info));
    }
  }
  cancel() {
    this.isDragging = false;
    const { projection: projection2, animationState } = this.visualElement;
    if (projection2) {
      projection2.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    const state2 = this.visualElement.state;
    state2.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset) {
    const { drag } = this.getProps();
    if (!offset || !shouldDrag(axis, drag, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset[axis];
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(
        next,
        this.constraints[axis],
        this.elastic[axis]
      );
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    var _a;
    const { dragConstraints, dragElastic } = this.getProps();
    const layout = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a = this.visualElement.projection) == null ? void 0 : _a.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isHTMLElement(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout) {
        this.constraints = calcRelativeConstraints(
          layout.layoutBox,
          dragConstraints
        );
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.constraints !== false && this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(
            layout.layoutBox[axis],
            this.constraints[axis]
          );
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isHTMLElement(constraints))
      return false;
    const constraintsElement = constraints;
    const { projection: projection2 } = this.visualElement;
    if (!projection2 || !projection2.layout)
      return false;
    const constraintsBox = measurePageBox(
      constraintsElement,
      projection2.root,
      this.visualElement.getTransformPagePoint()
    );
    let measuredConstraints = calcViewportConstraints(
      projection2.layout.layoutBox,
      constraintsBox
    );
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(
        convertBoxToBoundingBox(measuredConstraints)
      );
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const {
      drag,
      dragMomentum,
      dragElastic,
      dragTransition,
      dragSnapToOrigin,
      onDragTransitionEnd
    } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    addValueToWillChange(this.visualElement, axis);
    return axisValue.start(
      animateMotionValue(
        axis,
        axisValue,
        0,
        transition,
        this.visualElement,
        false
      )
    );
  }
  stopAnimation() {
    if (!isPresent(this.visualElement))
      return;
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => {
      var _a;
      return (_a = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a.pause();
    });
  }
  getAnimationState(axis) {
    var _a;
    return (_a = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`;
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue || this.visualElement.getValue(
      axis,
      (props.initial ? props.initial[axis] : void 0) || 0
    );
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag } = this.getProps();
      if (!shouldDrag(axis, drag, this.currentDirection))
        return;
      const { projection: projection2 } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection2 && projection2.layout) {
        const { min, max } = projection2.layout.layoutBox[axis];
        axisValue.set(point[axis] - mixNumber$1(min, max, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag, dragConstraints } = this.getProps();
    const { projection: projection2 } = this.visualElement;
    if (!isHTMLElement(dragConstraints) || !projection2 || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== false) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin(
          { min: latest, max: latest },
          this.constraints[axis]
        );
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection2.root && projection2.root.updateScroll();
    projection2.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min, max } = this.constraints[axis];
      axisValue.set(mixNumber$1(min, max, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(
      element,
      "pointerdown",
      (event) => {
        const { drag, dragListener = true } = this.getProps();
        drag && dragListener && this.start(event);
      }
    );
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isHTMLElement(dragConstraints)) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection: projection2 } = this.visualElement;
    const stopMeasureLayoutListener = projection2.addEventListener(
      "measure",
      measureDragConstraints
    );
    if (projection2 && !projection2.layout) {
      projection2.root && projection2.root.updateScroll();
      projection2.updateLayout();
    }
    frame.read(measureDragConstraints);
    const stopResizeListener = addDomEvent$1(void 0, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection2.addEventListener(
      "didUpdate",
      ({ delta, hasLayoutChanged }) => {
        if (this.isDragging && hasLayoutChanged) {
          eachAxis((axis) => {
            const motionValue2 = this.getAxisMotionValue(axis);
            if (!motionValue2)
              return;
            this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(
              motionValue2.get() + delta[axis].translate
            );
          });
          this.visualElement.render();
        }
      }
    );
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const {
      drag = false,
      dragDirectionLock = false,
      dragPropagation = false,
      dragConstraints = false,
      dragElastic = defaultElastic,
      dragMomentum = true
    } = props;
    return {
      ...props,
      drag,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag, currentDirection) {
  return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
class DragGesture extends Feature {
  constructor(state2) {
    super(state2);
    this.removeGroupControls = noop;
    this.removeListeners = noop;
    this.controls = new VisualElementDragControls(state2.visualElement);
  }
  mount() {
    const { dragControls } = this.state.options;
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
}
class LayoutFeature extends Feature {
  constructor(state2) {
    super(state2);
    addScaleCorrector(defaultScaleCorrector);
  }
  beforeUpdate() {
    this.state.willUpdate("beforeUpdate");
  }
  update() {
    this.didUpdate();
  }
  didUpdate() {
    var _a, _b;
    if (this.state.options.layout || this.state.options.layoutId || this.state.options.drag) {
      (_b = (_a = this.state.visualElement.projection) == null ? void 0 : _a.root) == null ? void 0 : _b.didUpdate();
    }
  }
  mount() {
    var _a;
    const options = this.state.options;
    const layoutGroup = this.state.options.layoutGroup;
    if (options.layout || options.layoutId) {
      const projection2 = this.state.visualElement.projection;
      if (projection2) {
        projection2.promote();
        (_a = layoutGroup == null ? void 0 : layoutGroup.group) == null ? void 0 : _a.add(projection2);
      }
      globalProjectionState.hasEverUpdated = true;
    }
    this.didUpdate();
  }
  beforeUnmount() {
    const projection2 = this.state.visualElement.projection;
    if (projection2) {
      this.state.willUpdate("beforeUnmount");
      if (this.state.options.layoutId) {
        projection2.isPresent = false;
        projection2.relegate();
      } else if (this.state.options.layout) {
        this.state.isSafeToRemove = true;
      }
    }
  }
  unmount() {
    const layoutGroup = this.state.options.layoutGroup;
    const projection2 = this.state.visualElement.projection;
    if (projection2) {
      if ((layoutGroup == null ? void 0 : layoutGroup.group) && (this.state.options.layout || this.state.options.layoutId)) {
        layoutGroup.group.remove(projection2);
      }
      this.didUpdate();
    }
  }
}
function asyncHandler(handler) {
  return (event, info) => {
    if (handler) {
      frame.postRender(() => handler(event, info));
    }
  };
}
class PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(
      pointerDownEvent,
      this.createPanHandlers(),
      {
        transformPagePoint: this.state.visualElement.getTransformPagePoint(),
        contextWindow: getContextWindow(this.state.visualElement)
      }
    );
  }
  createPanHandlers() {
    return {
      onSessionStart: asyncHandler((_2, info) => {
        const { onPanSessionStart } = this.state.options;
        onPanSessionStart && onPanSessionStart(_2, info);
      }),
      onStart: asyncHandler((_2, info) => {
        const { onPanStart } = this.state.options;
        onPanStart && onPanStart(_2, info);
      }),
      onMove: (event, info) => {
        const { onPan } = this.state.options;
        onPan && onPan(event, info);
      },
      onEnd: (event, info) => {
        const { onPanEnd } = this.state.options;
        delete this.session;
        if (onPanEnd) {
          frame.postRender(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(
      this.state.element,
      "pointerdown",
      this.onPointerDown.bind(this)
    );
  }
  update() {
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
}
const domMax = [
  AnimationFeature,
  PressGesture,
  HoverGesture,
  InViewGesture,
  FocusGesture,
  ProjectionFeature,
  PanGesture,
  DragGesture,
  LayoutFeature
];
const defaultConfig = {
  reducedMotion: "never",
  transition: void 0,
  nonce: void 0
};
const [injectMotionConfig] = createContext("MotionConfig");
function useMotionConfig() {
  return injectMotionConfig(computed(() => defaultConfig));
}
function usePopLayout(props) {
  const styles = /* @__PURE__ */ new WeakMap();
  const config = useMotionConfig();
  function addPopStyle(state2) {
    if (props.mode !== "popLayout")
      return;
    const element = state2.element;
    const parent = element.offsetParent;
    const parentWidth = parent instanceof HTMLElement ? parent.offsetWidth || 0 : 0;
    const size = {
      height: element.offsetHeight || 0,
      width: element.offsetWidth || 0,
      top: element.offsetTop,
      left: element.offsetLeft,
      right: 0
    };
    size.right = parentWidth - size.width - size.left;
    const x = props.anchorX === "left" ? `left: ${size.left}` : `right: ${size.right}`;
    state2.element.dataset.motionPopId = state2.id;
    const style2 = (void 0).createElement("style");
    if (config.value.nonce) {
      style2.nonce = config.value.nonce;
    }
    styles.set(state2, style2);
    (void 0).head.appendChild(style2);
    if (style2.sheet) {
      style2.sheet.insertRule(`
    [data-motion-pop-id="${state2.id}"] {
      position: absolute !important;
      width: ${size.width}px !important;
      height: ${size.height}px !important;
      top: ${size.top}px !important;
      ${x}px !important;
      }
      `);
    }
  }
  function removePopStyle(state2) {
    const style2 = styles.get(state2);
    if (!style2)
      return;
    styles.delete(state2);
    frame.render(() => {
      (void 0).head.removeChild(style2);
    });
  }
  return {
    addPopStyle,
    removePopStyle,
    styles
  };
}
function delay(fn) {
  return Promise.resolve().then(() => {
    fn();
  });
}
const _sfc_main$n = /* @__PURE__ */ defineComponent({
  ...{
    name: "AnimatePresence",
    inheritAttrs: true
  },
  __name: "AnimatePresence",
  props: {
    mode: { default: "sync" },
    initial: { type: Boolean, default: true },
    as: {},
    custom: {},
    onExitComplete: {},
    anchorX: { default: "left" }
  },
  setup(__props) {
    const props = __props;
    useAnimatePresence(props);
    const { addPopStyle, removePopStyle, styles } = usePopLayout(props);
    function findMotionElement(el) {
      let current = el;
      while (current) {
        if (mountedStates.get(current)) {
          return current;
        }
        current = current.firstElementChild;
      }
      return null;
    }
    function enter(el) {
      const state2 = mountedStates.get(el);
      if (!state2) {
        return;
      }
      removePopStyle(state2);
      state2.isVShow = true;
      removeDoneCallback(el);
      delay(() => {
        state2.setActive("exit", false);
      });
    }
    const exitDom = /* @__PURE__ */ new Map();
    function exit(el, done) {
      var _a;
      const motionEl = findMotionElement(el);
      const state2 = mountedStates.get(motionEl);
      if (!motionEl || !state2) {
        done();
        if (exitDom.size === 0) {
          (_a = props.onExitComplete) == null ? void 0 : _a.call(props);
        }
        return;
      }
      exitDom.set(motionEl, true);
      removeDoneCallback(motionEl);
      addPopStyle(state2);
      function doneCallback(e) {
        var _a2, _b;
        if ((_a2 = e == null ? void 0 : e.detail) == null ? void 0 : _a2.isExit) {
          const projection2 = state2.visualElement.projection;
          if ((projection2 == null ? void 0 : projection2.animationProgress) > 0 && !state2.isSafeToRemove && !state2.isVShow) {
            return;
          }
          removeDoneCallback(motionEl);
          exitDom.delete(motionEl);
          if (exitDom.size === 0) {
            (_b = props.onExitComplete) == null ? void 0 : _b.call(props);
          }
          if (!styles.has(state2)) {
            state2.willUpdate("done");
          } else {
            removePopStyle(state2);
          }
          done();
          if (!motionEl.isConnected) {
            state2.unmount(true);
          }
        }
      }
      delay(() => {
        state2.setActive("exit", true);
        doneCallbacks.set(motionEl, doneCallback);
        motionEl.addEventListener("motioncomplete", doneCallback);
      });
    }
    const transitionProps = computed(() => {
      if (props.mode !== "wait") {
        return {
          tag: props.as
        };
      }
      return {
        mode: props.mode === "wait" ? "out-in" : void 0
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(_ctx.mode === "wait" ? Transition : TransitionGroup), mergeProps({ css: false }, transitionProps.value, {
        appear: "",
        onEnter: enter,
        onLeave: exit
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16);
    };
  }
});
function getMotionElement(el) {
  if (!el)
    return void 0;
  if (el.nodeType === 3 || el.nodeType === 8) {
    return getMotionElement(el.nextSibling);
  }
  return el;
}
const [useLazyMotionContext] = createContext("LazyMotionContext");
function useMotionState(props) {
  const parentState = injectMotion(null);
  const layoutGroup = injectLayoutGroup({});
  const config = useMotionConfig();
  const animatePresenceContext = injectAnimatePresence({});
  const lazyMotionContext = useLazyMotionContext({
    features: ref([]),
    strict: false
  });
  const attrs = useAttrs();
  function getLayoutId() {
    if (layoutGroup.id && props.layoutId)
      return `${layoutGroup.id}-${props.layoutId}`;
    return props.layoutId || void 0;
  }
  function getProps() {
    return {
      ...props,
      lazyMotionContext,
      layoutId: getLayoutId(),
      transition: props.transition ?? config.value.transition,
      layoutGroup,
      motionConfig: config.value,
      inViewOptions: props.inViewOptions ?? config.value.inViewOptions,
      animatePresenceContext,
      initial: animatePresenceContext.initial === false ? animatePresenceContext.initial : props.initial === true ? void 0 : props.initial
    };
  }
  function getMotionProps() {
    return {
      ...attrs,
      ...getProps()
    };
  }
  const state2 = new MotionState(
    getMotionProps(),
    parentState
  );
  provideMotion(state2);
  function getAttrs() {
    var _a2;
    const isSVG = state2.type === "svg";
    const attrsProps = { ...attrs };
    Object.keys(attrs).forEach((key) => {
      if (isMotionValue(attrs[key]))
        attrsProps[key] = attrs[key].get();
    });
    let styleProps = {
      ...props.style,
      ...isSVG ? {} : ((_a2 = state2.visualElement) == null ? void 0 : _a2.latestValues) || state2.baseTarget
    };
    if (isSVG) {
      const { attrs: attrs2, style: style22 } = convertSvgStyleToAttributes({
        ...state2.isMounted() ? state2.target : state2.baseTarget,
        ...styleProps
      });
      if (style22.transform || attrs2.transformOrigin) {
        style22.transformOrigin = attrs2.transformOrigin ?? "50% 50%";
        delete attrs2.transformOrigin;
      }
      if (style22.transform) {
        style22.transformBox = style22.transformBox ?? "fill-box";
        delete attrs2.transformBox;
      }
      Object.assign(attrsProps, attrs2);
      styleProps = style22;
    }
    if (props.drag && props.dragListener !== false) {
      Object.assign(styleProps, {
        userSelect: "none",
        WebkitUserSelect: "none",
        WebkitTouchCallout: "none",
        touchAction: props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`
      });
    }
    const style2 = createStyles(styleProps);
    if (style2)
      attrsProps.style = style2;
    return attrsProps;
  }
  getCurrentInstance$1().proxy;
  return {
    getProps,
    getAttrs,
    layoutGroup,
    state: state2
  };
}
const MotionComponentProps = {
  "ignoreStrict": { type: Boolean },
  "forwardMotionProps": { type: Boolean, default: false },
  "asChild": { type: Boolean, default: false },
  "hover": { type: [String, Array, Object] },
  "press": { type: [String, Array, Object] },
  "inView": { type: [String, Array, Object] },
  "focus": { type: [String, Array, Object] },
  "whileDrag": { type: [String, Array, Object] },
  "whileHover": { type: [String, Array, Object], default: ({ hover: hover2 }) => {
    return hover2;
  } },
  "whilePress": { type: [String, Array, Object], default: ({ press: press2 }) => {
    return press2;
  } },
  "whileInView": { type: [String, Array, Object], default: ({ inView: inView2 }) => {
    return inView2;
  } },
  "whileFocus": { type: [String, Array, Object], default: ({ focus: focus2 }) => {
    return focus2;
  } },
  "custom": { type: [String, Number, Object, Array] },
  "initial": { type: [String, Array, Object, Boolean], default: void 0 },
  "animate": { type: [String, Array, Object], default: void 0 },
  "exit": { type: [String, Array, Object] },
  "variants": { type: Object },
  "inherit": { type: Boolean },
  "style": { type: Object },
  "transformTemplate": { type: Function },
  "transition": { type: Object },
  "layoutGroup": { type: Object },
  "motionConfig": { type: Object },
  "onAnimationComplete": { type: Function },
  "onUpdate": { type: Function },
  "layout": { type: [Boolean, String], default: false },
  "layoutId": { type: String, default: void 0 },
  "layoutScroll": { type: Boolean, default: false },
  "layoutRoot": { type: Boolean, default: false },
  "data-framer-portal-id": { type: String },
  "crossfade": { type: Boolean, default: true },
  "layoutDependency": { type: null },
  "onBeforeLayoutMeasure": { type: Function },
  "onLayoutMeasure": { type: Function },
  "onLayoutAnimationStart": { type: Function },
  "onLayoutAnimationComplete": { type: Function },
  "globalPressTarget": { type: Boolean },
  "onPressStart": { type: Function },
  "onPress": { type: Function },
  "onPressCancel": { type: Function },
  "onHoverStart": { type: Function },
  "onHoverEnd": { type: Function },
  "inViewOptions": { type: Object },
  "onViewportEnter": { type: Function },
  "onViewportLeave": { type: Function },
  "drag": { type: [Boolean, String] },
  "dragSnapToOrigin": { type: Boolean },
  "dragDirectionLock": { type: Boolean },
  "dragPropagation": { type: Boolean },
  "dragConstraints": { type: [Boolean, Object] },
  "dragElastic": { type: [Boolean, Number, Object], default: 0.5 },
  "dragMomentum": { type: Boolean, default: true },
  "dragTransition": { type: Object },
  "dragListener": { type: Boolean, default: true },
  "dragControls": { type: Object },
  "onDragStart": { type: Function },
  "onDragEnd": { type: Function },
  "onDrag": { type: Function },
  "onDirectionLock": { type: Function },
  "onDragTransitionEnd": { type: Function },
  "onMeasureDragConstraints": { type: Function },
  "onPanSessionStart": { type: Function },
  "onPanStart": { type: Function },
  "onPan": { type: Function },
  "onPanEnd": { type: Function }
};
const componentMaxCache = /* @__PURE__ */ new Map();
const componentMiniCache = /* @__PURE__ */ new Map();
function renderSlotFragments(fragments) {
  if (!Array.isArray(fragments))
    return [fragments];
  const result = [];
  for (const item of fragments) {
    if (Array.isArray(item))
      result.push(...item);
    else
      result.push(item);
  }
  return result;
}
const SELF_CLOSING_TAGS = ["area", "img", "input"];
function handlePrimitiveAndSlot(asTag, allAttrs, slots) {
  var _a, _b;
  if (typeof asTag === "string" && SELF_CLOSING_TAGS.includes(asTag)) {
    return h(asTag, allAttrs);
  }
  if (asTag === "template") {
    if (!slots.default)
      return null;
    const childrens = renderSlotFragments(slots.default());
    const firstNonCommentChildrenIndex = childrens.findIndex((child) => child.type !== Comment);
    if (firstNonCommentChildrenIndex === -1)
      return childrens;
    const firstNonCommentChildren = childrens[firstNonCommentChildrenIndex];
    (_a = firstNonCommentChildren.props) == null ? true : delete _a.ref;
    const mergedProps = firstNonCommentChildren.props ? mergeProps(allAttrs, firstNonCommentChildren.props) : allAttrs;
    if (allAttrs.class && ((_b = firstNonCommentChildren.props) == null ? void 0 : _b.class))
      delete firstNonCommentChildren.props.class;
    const cloned = cloneVNode(firstNonCommentChildren, mergedProps);
    for (const prop in mergedProps) {
      if (prop.startsWith("on")) {
        cloned.props || (cloned.props = {});
        cloned.props[prop] = mergedProps[prop];
      }
    }
    if (childrens.length === 1)
      return cloned;
    childrens[firstNonCommentChildrenIndex] = cloned;
    return childrens;
  }
  return null;
}
function createMotionComponent(component, options = {}) {
  var _a;
  const isString2 = typeof component === "string";
  const name2 = isString2 ? component : component.name || "";
  const componentCache = ((_a = options.features) == null ? void 0 : _a.length) > 0 ? componentMaxCache : componentMiniCache;
  if (isString2 && (componentCache == null ? void 0 : componentCache.has(component))) {
    return componentCache.get(component);
  }
  const motionComponent = defineComponent({
    inheritAttrs: false,
    props: {
      ...MotionComponentProps,
      features: {
        type: Object,
        default: () => options.features || []
      },
      as: { type: [String, Object], default: component || "div" }
    },
    name: name2 ? `motion.${name2}` : "Motion",
    setup(props, { slots }) {
      const { getProps, getAttrs, state: state2 } = useMotionState(props);
      function onVnodeUpdated() {
        const el = state2.element;
        const isComponent = typeof props.as === "object";
        if ((!isComponent || props.asChild) && el) {
          const { style: style2 } = getAttrs();
          if (style2) {
            for (const [key, val] of Object.entries(style2)) {
              el.style[key] = val;
            }
          }
        }
      }
      return () => {
        const motionProps = getProps();
        const motionAttrs = getAttrs();
        const asTag = props.asChild ? "template" : props.as;
        const allAttrs = {
          ...options.forwardMotionProps || props.forwardMotionProps ? motionProps : {},
          ...motionAttrs,
          onVnodeUpdated
        };
        const primitiveOrSlotResult = handlePrimitiveAndSlot(asTag, allAttrs, slots);
        if (primitiveOrSlotResult !== null) {
          return primitiveOrSlotResult;
        }
        return h(asTag, {
          ...allAttrs
        }, slots);
      };
    }
  });
  if (isString2) {
    componentCache == null ? void 0 : componentCache.set(component, motionComponent);
  }
  return motionComponent;
}
function createMotionComponentWithFeatures(features = []) {
  return new Proxy({}, {
    get(target, prop) {
      if (prop === "create") {
        return (component, options) => createMotionComponent(component, {
          ...options,
          features
        });
      }
      return createMotionComponent(prop, {
        features
      });
    }
  });
}
const motion = createMotionComponentWithFeatures(domMax);
motion.create("div");
function useDomRef() {
  const dom = ref(null);
  const domProxy = new Proxy(dom, {
    get(target, key) {
      if (typeof key === "string" || typeof key === "symbol") {
        return Reflect.get(target, key);
      }
      return void 0;
    },
    set(target, key, value) {
      if (key === "value")
        return Reflect.set(target, key, getMotionElement((value == null ? void 0 : value.$el) || value));
      return true;
    }
  });
  return domProxy;
}
const _sfc_main$m = /* @__PURE__ */ defineComponent({
  __name: "LivePhotoIndicator",
  __ssrInlineRender: true,
  props: {
    photo: {},
    isVideoPlaying: { type: Boolean },
    processingState: {}
  },
  setup(__props) {
    return (_ctx, _push, _parent, _attrs) => {
      const _component_Icon = __nuxt_component_0$4;
      if (__props.photo.isLivePhoto) {
        _push(ssrRenderComponent(unref(motion).div, mergeProps({
          class: ["backdrop-blur-md rounded-full pl-1 pr-1.5 py-1 text-[13px] font-bold flex items-center gap-0.5 leading-0 select-none transition-colors duration-300", `${__props.isVideoPlaying ? "text-yellow-300 bg-yellow-300/10" : "text-white bg-black/30"}`],
          animate: {
            scale: __props.isVideoPlaying ? 1.06 : 1
          },
          transition: {
            duration: 0.3,
            ease: "easeInOut"
          }
        }, _attrs), {
          default: withCtx((_2, _push2, _parent2, _scopeId) => {
            if (_push2) {
              if (__props.processingState?.isProcessing) {
                _push2(ssrRenderComponent(_component_Icon, {
                  name: "tabler:loader",
                  class: "size-[17px] animate-spin"
                }, null, _parent2, _scopeId));
              } else {
                _push2(ssrRenderComponent(_component_Icon, {
                  name: "tabler:live-photo",
                  class: "size-[17px]"
                }, null, _parent2, _scopeId));
              }
              _push2(`<span${_scopeId}>${ssrInterpolate(_ctx.$t("ui.livePhoto"))}</span>`);
              if (__props.processingState?.isProcessing) {
                _push2(`<span class="text-[12px] text-white/80 pl-1"${_scopeId}>${ssrInterpolate(Math.round(__props.processingState.progress || 0))}% </span>`);
              } else {
                _push2(`<!---->`);
              }
            } else {
              return [
                __props.processingState?.isProcessing ? (openBlock(), createBlock(_component_Icon, {
                  key: 0,
                  name: "tabler:loader",
                  class: "size-[17px] animate-spin"
                })) : (openBlock(), createBlock(_component_Icon, {
                  key: 1,
                  name: "tabler:live-photo",
                  class: "size-[17px]"
                })),
                createVNode("span", null, toDisplayString$1(_ctx.$t("ui.livePhoto")), 1),
                __props.processingState?.isProcessing ? (openBlock(), createBlock("span", {
                  key: 2,
                  class: "text-[12px] text-white/80 pl-1"
                }, toDisplayString$1(Math.round(__props.processingState.progress || 0)) + "% ", 1)) : createCommentVNode("", true)
              ];
            }
          }),
          _: 1
        }, _parent));
      } else {
        _push(`<!---->`);
      }
    };
  }
});
const _sfc_setup$m = _sfc_main$m.setup;
_sfc_main$m.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/photo/LivePhotoIndicator.vue");
  return _sfc_setup$m ? _sfc_setup$m(props, ctx) : void 0;
};
const __nuxt_component_1$2 = Object.assign(_sfc_main$m, { __name: "PhotoLivePhotoIndicator" });
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  __name: "GlassButton",
  __ssrInlineRender: true,
  props: {
    class: { default: "" },
    size: { default: "md" },
    rounded: { type: Boolean, default: false },
    icon: { default: "" }
  },
  emits: ["click"],
  setup(__props) {
    const sizeClasses = {
      sm: "h-9 min-w-9 text-sm",
      md: "h-12 min-w-12 text-base",
      lg: "h-14 min-w-14 text-lg"
    };
    const iconSizeClasses = {
      sm: "text-lg",
      md: "text-xl",
      lg: "text-2xl"
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_Icon = __nuxt_component_0$4;
      _push(ssrRenderComponent(unref(motion).button, mergeProps({
        initial: { scale: 0.5, opacity: 0 },
        animate: { scale: 1, opacity: 1 },
        "while-hover": { scale: 1.1 },
        "while-press": { scale: 0.95 },
        transition: { type: "spring", stiffness: 300, damping: 20 },
        type: "button",
        class: unref(twMerge)(
          "px-2 cursor-pointer pointer-events-auto font-medium flex items-center justify-center gap-1.5 bg-white/30 text-neutral-700 backdrop-blur-md border border-neutral-100 shadow-md shadow-neutral-300/20 dark:bg-neutral-700/30 dark:text-white/80 dark:border-white/10 dark:shadow-black/20 overflow-hidden",
          sizeClasses[_ctx.$props.size],
          _ctx.$props.rounded ? "rounded-full" : "rounded-xl",
          _ctx.$props.class
        ),
        onClick: ($event) => _ctx.$emit("click")
      }, _attrs), {
        default: withCtx((_2, _push2, _parent2, _scopeId) => {
          if (_push2) {
            if (__props.icon) {
              _push2(ssrRenderComponent(_component_Icon, {
                name: __props.icon,
                class: unref(twMerge)("inline-block shrink-0 -mt-0.5", iconSizeClasses[_ctx.$props.size])
              }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            ssrRenderSlot(_ctx.$slots, "default", {}, null, _push2, _parent2, _scopeId);
          } else {
            return [
              __props.icon ? (openBlock(), createBlock(_component_Icon, {
                key: 0,
                name: __props.icon,
                class: unref(twMerge)("inline-block shrink-0 -mt-0.5", iconSizeClasses[_ctx.$props.size])
              }, null, 8, ["name", "class"])) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "default")
            ];
          }
        }),
        _: 3
      }, _parent));
    };
  }
});
const _sfc_setup$l = _sfc_main$l.setup;
_sfc_main$l.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/GlassButton.vue");
  return _sfc_setup$l ? _sfc_setup$l(props, ctx) : void 0;
};
const __nuxt_component_0$1 = Object.assign(_sfc_main$l, { __name: "GlassButton" });
function resolveTags(options) {
  const _options = toRaw(options);
  const tags = _options.tags.filter(Boolean).map((i) => typeof i === "string" ? { id: i } : i);
  if (_options.id) {
    const { id: id2, config, initCommands } = _options;
    tags.unshift({ id: id2, config, initCommands });
  }
  return tags;
}
function useGtag() {
  const options = (/* @__PURE__ */ useRuntimeConfig()).public.gtag;
  resolveTags(options);
  let _gtag;
  _gtag = () => {
  };
  const initialize = (id2) => {
  };
  function disableAnalytics(id2) {
  }
  function enableAnalytics(id2) {
  }
  return {
    gtag: _gtag,
    initialize,
    disableAnalytics,
    enableAnalytics
  };
}
const kbdKeysMap = {
  meta: "",
  ctrl: "",
  alt: "",
  win: "⊞",
  command: "⌘",
  shift: "⇧",
  control: "⌃",
  option: "⌥",
  enter: "↵",
  delete: "⌦",
  backspace: "⌫",
  escape: "Esc",
  tab: "⇥",
  capslock: "⇪",
  arrowup: "↑",
  arrowright: "→",
  arrowdown: "↓",
  arrowleft: "←",
  pageup: "⇞",
  pagedown: "⇟",
  home: "↖",
  end: "↘"
};
const _useKbd = () => {
  const macOS = computed(() => false);
  const kbdKeysSpecificMap = reactive({
    meta: " ",
    alt: " ",
    ctrl: " "
  });
  function getKbdKey(value) {
    if (!value) {
      return;
    }
    if (["meta", "alt", "ctrl"].includes(value)) {
      return kbdKeysSpecificMap[value];
    }
    return kbdKeysMap[value] || value;
  }
  return {
    macOS,
    getKbdKey
  };
};
const useKbd = /* @__PURE__ */ createSharedComposable(_useKbd);
const chainedShortcutRegex = /^[^-]+.*-.*[^-]+$/;
const combinedShortcutRegex = /^[^_]+.*_.*[^_]+$/;
const shiftableKeys = ["arrowleft", "arrowright", "arrowup", "arrowright", "tab", "escape", "enter", "backspace"];
function convertKeyToCode(key) {
  if (/^[a-z]$/i.test(key)) {
    return `Key${key.toUpperCase()}`;
  }
  if (/^\d$/.test(key)) {
    return `Digit${key}`;
  }
  if (/^f\d+$/i.test(key)) {
    return key.toUpperCase();
  }
  const specialKeys = {
    space: "Space",
    enter: "Enter",
    escape: "Escape",
    tab: "Tab",
    backspace: "Backspace",
    delete: "Delete",
    arrowup: "ArrowUp",
    arrowdown: "ArrowDown",
    arrowleft: "ArrowLeft",
    arrowright: "ArrowRight"
  };
  return specialKeys[key.toLowerCase()] || key;
}
function defineShortcuts(config, options = {}) {
  const chainedInputs = ref([]);
  const clearChainedInput = () => {
    chainedInputs.value.splice(0, chainedInputs.value.length);
  };
  const debouncedClearChainedInput = /* @__PURE__ */ useDebounceFn(clearChainedInput, options.chainDelay ?? 800);
  const { macOS } = useKbd();
  const activeElement = /* @__PURE__ */ useActiveElement();
  const layoutIndependent = options.layoutIndependent ?? false;
  const shiftableCodes = shiftableKeys.map((k2) => convertKeyToCode(k2));
  const onKeyDown = (e) => {
    if (!e.key) {
      return;
    }
    const alphabetKey = layoutIndependent ? /^Key[A-Z]$/i.test(e.code) : /^[a-z]{1}$/i.test(e.key);
    const shiftableKey = layoutIndependent ? shiftableCodes.includes(e.code) : shiftableKeys.includes(e.key.toLowerCase());
    let chainedKey;
    chainedInputs.value.push(layoutIndependent ? e.code : e.key);
    if (chainedInputs.value.length >= 2) {
      chainedKey = chainedInputs.value.slice(-2).join("-");
      for (const shortcut of shortcuts.value.filter((s) => s.chained)) {
        if (shortcut.key !== chainedKey) {
          continue;
        }
        if (shortcut.enabled) {
          e.preventDefault();
          shortcut.handler(e);
        }
        clearChainedInput();
        return;
      }
    }
    for (const shortcut of shortcuts.value.filter((s) => !s.chained)) {
      if (layoutIndependent) {
        if (e.code !== shortcut.key) {
          continue;
        }
      } else {
        if (e.key.toLowerCase() !== shortcut.key) {
          continue;
        }
      }
      if (e.metaKey !== shortcut.metaKey) {
        continue;
      }
      if (e.ctrlKey !== shortcut.ctrlKey) {
        continue;
      }
      if ((alphabetKey || shiftableKey) && e.shiftKey !== shortcut.shiftKey) {
        continue;
      }
      if (shortcut.enabled) {
        e.preventDefault();
        shortcut.handler(e);
      }
      clearChainedInput();
      return;
    }
    debouncedClearChainedInput();
  };
  const usingInput = computed(() => {
    const tagName = activeElement.value?.tagName;
    const contentEditable = activeElement.value?.contentEditable;
    const usingInput2 = !!(tagName === "INPUT" || tagName === "TEXTAREA" || contentEditable === "true" || contentEditable === "plaintext-only");
    if (usingInput2) {
      return activeElement.value?.name || true;
    }
    return false;
  });
  const shortcuts = computed(() => {
    return Object.entries(toValue(config)).map(([key, shortcutConfig]) => {
      if (!shortcutConfig) {
        return null;
      }
      let shortcut;
      if (key.includes("-") && key !== "-" && !key.includes("_") && !key.match(chainedShortcutRegex)?.length) {
        console.trace(`[Shortcut] Invalid key: "${key}"`);
      }
      if (key.includes("_") && key !== "_" && !key.match(combinedShortcutRegex)?.length) {
        console.trace(`[Shortcut] Invalid key: "${key}"`);
      }
      const chained = key.includes("-") && key !== "-" && !key.includes("_");
      if (chained) {
        if (layoutIndependent) {
          const parts = key.split("-").map((p) => convertKeyToCode(p));
          shortcut = {
            key: parts.join("-"),
            metaKey: false,
            ctrlKey: false,
            shiftKey: false,
            altKey: false
          };
        } else {
          shortcut = {
            key: key.toLowerCase(),
            metaKey: false,
            ctrlKey: false,
            shiftKey: false,
            altKey: false
          };
        }
      } else {
        const keySplit = key.toLowerCase().split("_").map((k2) => k2);
        let baseKey = keySplit.filter((k2) => !["meta", "command", "ctrl", "shift", "alt", "option"].includes(k2)).join("_");
        if (layoutIndependent) {
          baseKey = convertKeyToCode(baseKey);
        }
        shortcut = {
          key: baseKey,
          metaKey: keySplit.includes("meta") || keySplit.includes("command"),
          ctrlKey: keySplit.includes("ctrl"),
          shiftKey: keySplit.includes("shift"),
          altKey: keySplit.includes("alt") || keySplit.includes("option")
        };
      }
      shortcut.chained = chained;
      if (!macOS.value && shortcut.metaKey && !shortcut.ctrlKey) {
        shortcut.metaKey = false;
        shortcut.ctrlKey = true;
      }
      if (typeof shortcutConfig === "function") {
        shortcut.handler = shortcutConfig;
      } else if (typeof shortcutConfig === "object") {
        shortcut = { ...shortcut, handler: shortcutConfig.handler };
      }
      if (!shortcut.handler) {
        console.trace("[Shortcut] Invalid value");
        return null;
      }
      let enabled = true;
      if (!shortcutConfig.usingInput) {
        enabled = !usingInput.value;
      } else if (typeof shortcutConfig.usingInput === "string") {
        enabled = usingInput.value === shortcutConfig.usingInput;
      }
      shortcut.enabled = enabled;
      return shortcut;
    }).filter(Boolean);
  });
  return useEventListener("keydown", onKeyDown);
}
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  __name: "ShareModal",
  __ssrInlineRender: true,
  props: {
    isOpen: { type: Boolean },
    photo: {}
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const { t: $t } = useI18n();
    const props = __props;
    const emit = __emit;
    const toast = useToast();
    const { gtag } = useGtag();
    const shareUrl = computed(() => {
      return "";
    });
    const shareText = computed(() => {
      const title = props.photo.title || $t("ui.action.share.fallback.photoTitle");
      const description = props.photo.description || "";
      return `${$t("ui.action.share.text.prefix")} ${title}${description ? " - " + description : ""}`;
    });
    const shareTextAndUrl = computed(() => {
      return `${shareText.value}
${shareUrl.value}`;
    });
    const ogImageLoading = ref(true);
    const ogImageError = ref(false);
    const loadingTimer = ref(null);
    const ogImageUrl = computed(() => {
      return "";
    });
    const resetLoadingState = () => {
      ogImageLoading.value = true;
      ogImageError.value = false;
      if (loadingTimer.value) {
        clearTimeout(loadingTimer.value);
      }
      loadingTimer.value = setTimeout(() => {
        if (ogImageLoading.value) {
          ogImageLoading.value = false;
          ogImageError.value = true;
        }
      }, 1e4);
    };
    watch(() => props.photo.id, resetLoadingState);
    watch(
      () => props.isOpen,
      (newValue) => {
        if (newValue) {
          resetLoadingState();
        }
      }
    );
    const handleOgImageLoad = () => {
      if (loadingTimer.value) {
        clearTimeout(loadingTimer.value);
        loadingTimer.value = null;
      }
      ogImageLoading.value = false;
      ogImageError.value = false;
    };
    const handleOgImageError = () => {
      if (loadingTimer.value) {
        clearTimeout(loadingTimer.value);
        loadingTimer.value = null;
      }
      ogImageLoading.value = false;
      ogImageError.value = true;
    };
    const shareToTwitter = () => {
      gtag("event", "photo_share", {
        photo_id: props.photo.id,
        photo_title: props.photo.title || "Untitled",
        share_method: "twitter"
      });
      const text = encodeURIComponent(shareText.value);
      const url = encodeURIComponent(shareUrl.value);
      (void 0).open(
        `https://twitter.com/intent/tweet?text=${text}&url=${url}`,
        "_blank"
      );
    };
    const shareToTelegram = () => {
      gtag("event", "photo_share", {
        photo_id: props.photo.id,
        photo_title: props.photo.title || "Untitled",
        share_method: "telegram"
      });
      (void 0).open(
        `https://t.me/share/url?url=${encodeURIComponent(shareUrl.value)}&text=${encodeURIComponent(shareText.value)}`,
        "_blank"
      );
    };
    const shareToWeibo = () => {
      gtag("event", "photo_share", {
        photo_id: props.photo.id,
        photo_title: props.photo.title || "Untitled",
        share_method: "weibo"
      });
      const text = encodeURIComponent(shareText.value);
      const url = encodeURIComponent(shareUrl.value);
      (void 0).open(
        `https://service.weibo.com/share/share.php?url=${url}&title=${text}`,
        "_blank"
      );
    };
    const shareToFacebook = () => {
      gtag("event", "photo_share", {
        photo_id: props.photo.id,
        photo_title: props.photo.title || "Untitled",
        share_method: "facebook"
      });
      const url = encodeURIComponent(shareUrl.value);
      (void 0).open(`https://www.facebook.com/sharer/sharer.php?u=${url}`, "_blank");
    };
    const shareToWhatsApp = () => {
      gtag("event", "photo_share", {
        photo_id: props.photo.id,
        photo_title: props.photo.title || "Untitled",
        share_method: "whatsapp"
      });
      const text = encodeURIComponent(`${shareText.value}
${shareUrl.value}`);
      (void 0).open(`https://wa.me/?text=${text}`, "_blank");
    };
    const shareToLinkedIn = () => {
      gtag("event", "photo_share", {
        photo_id: props.photo.id,
        photo_title: props.photo.title || "Untitled",
        share_method: "linkedin"
      });
      const url = encodeURIComponent(shareUrl.value);
      const title = encodeURIComponent(shareText.value);
      (void 0).open(
        `https://www.linkedin.com/sharing/share-offsite/?url=${url}&title=${title}`,
        "_blank"
      );
    };
    const copyLink = async () => {
      try {
        await (void 0).clipboard.writeText(shareTextAndUrl.value);
        toast.add({
          title: $t("ui.action.share.success.linkCopied"),
          color: "success",
          icon: "tabler:check",
          duration: 3e3
        });
      } catch (error) {
        toast.add({
          title: $t("ui.action.share.error.linkCopyFailed"),
          description: error?.message || "Unknown error",
          color: "error",
          icon: "tabler:x",
          duration: 3e3
        });
      }
    };
    const nativeShare = async () => {
      if ((void 0).share) {
        try {
          gtag("event", "photo_share", {
            photo_id: props.photo.id,
            photo_title: props.photo.title || "Untitled",
            share_method: "native_share"
          });
          await (void 0).share({
            title: shareText.value,
            url: shareUrl.value
          });
        } catch (error) {
          console.error($t("ui.action.share.error.nativeShareFailed"), error);
        }
      }
    };
    const downloadOgImage = async () => {
      try {
        const response = await fetch(ogImageUrl.value);
        const blob = await response.blob();
        const url = (void 0).URL.createObjectURL(blob);
        const link = (void 0).createElement("a");
        link.href = url;
        link.download = `${props.photo.title || "photo"}-og.png`;
        (void 0).body.appendChild(link);
        link.click();
        (void 0).body.removeChild(link);
        (void 0).URL.revokeObjectURL(url);
        toast.add({
          title: $t("ui.action.share.success.ogImageDownloaded"),
          color: "success",
          icon: "tabler:download",
          duration: 3e3
        });
      } catch (error) {
        toast.add({
          title: $t("ui.action.share.error.ogImageDownloadFailed"),
          description: error?.message || "Unknown error",
          color: "error",
          icon: "tabler:x",
          duration: 3e3
        });
      }
    };
    const downloadOriginalImage = async () => {
      try {
        const response = await fetch(props.photo.originalUrl);
        const blob = await response.blob();
        const url = (void 0).URL.createObjectURL(blob);
        const link = (void 0).createElement("a");
        link.href = url;
        const extension = props.photo.originalUrl.split(".").pop() || "jpg";
        link.download = `${props.photo.title || "photo"}.${extension}`;
        (void 0).body.appendChild(link);
        link.click();
        (void 0).body.removeChild(link);
        (void 0).URL.revokeObjectURL(url);
        gtag("event", "photo_download", {
          photo_id: props.photo.id,
          photo_title: props.photo.title || "Untitled",
          download_type: "original"
        });
        toast.add({
          title: $t("ui.action.share.success.originalImageDownloaded"),
          color: "success",
          icon: "tabler:download",
          duration: 3e3
        });
      } catch (error) {
        toast.add({
          title: $t("ui.action.share.error.originalImageDownloadFailed"),
          description: error?.message || "Unknown error",
          color: "error",
          icon: "tabler:x",
          duration: 3e3
        });
      }
    };
    const canNativeShare = computed(() => {
      return false;
    });
    const socialPlatforms = computed(() => [
      {
        name: $t("ui.action.share.platforms.twitter"),
        icon: "tabler:brand-twitter",
        color: "text-blue-500",
        action: shareToTwitter
      },
      {
        name: $t("ui.action.share.platforms.telegram"),
        icon: "tabler:brand-telegram",
        color: "text-blue-400",
        action: shareToTelegram
      },
      {
        name: $t("ui.action.share.platforms.weibo"),
        icon: "tabler:brand-weibo",
        color: "text-red-500",
        action: shareToWeibo
      },
      {
        name: $t("ui.action.share.platforms.facebook"),
        icon: "tabler:brand-facebook",
        color: "text-blue-600",
        action: shareToFacebook
      },
      {
        name: $t("ui.action.share.platforms.whatsapp"),
        icon: "tabler:brand-whatsapp",
        color: "text-green-500",
        action: shareToWhatsApp
      },
      {
        name: $t("ui.action.share.platforms.linkedin"),
        icon: "tabler:brand-linkedin",
        color: "text-blue-700",
        action: shareToLinkedIn
      }
    ]);
    const handleBackdropClick = (event) => {
      if (event.target === event.currentTarget) {
        emit("close");
      }
    };
    defineShortcuts({
      escape: () => {
        emit("close");
      }
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_Icon = __nuxt_component_0$4;
      const _component_UButton = _sfc_main$v;
      ssrRenderTeleport(_push, (_push2) => {
        _push2(ssrRenderComponent(unref(_sfc_main$n), null, {
          default: withCtx((_2, _push3, _parent2, _scopeId) => {
            if (_push3) {
              if (__props.isOpen) {
                _push3(ssrRenderComponent(unref(motion).div, {
                  initial: { opacity: 0 },
                  animate: { opacity: 1 },
                  exit: { opacity: 0 },
                  transition: { duration: 0.2 },
                  class: "fixed inset-0 z-[60] flex items-center justify-center bg-black/50 backdrop-blur-sm",
                  onClick: handleBackdropClick
                }, {
                  default: withCtx((_22, _push4, _parent3, _scopeId2) => {
                    if (_push4) {
                      _push4(ssrRenderComponent(unref(motion).div, {
                        initial: { opacity: 0, scale: 0.95, y: 20 },
                        animate: { opacity: 1, scale: 1, y: 0 },
                        exit: { opacity: 0, scale: 0.95, y: 20 },
                        transition: {
                          type: "spring",
                          duration: 0.3,
                          bounce: 0.1
                        },
                        class: "relative mx-4 w-full max-w-md overflow-hidden rounded-2xl border border-white/10 bg-white/90 shadow-2xl backdrop-blur-2xl dark:bg-neutral-900/90",
                        onClick: () => {
                        }
                      }, {
                        default: withCtx((_3, _push5, _parent4, _scopeId3) => {
                          if (_push5) {
                            _push5(`<div class="flex items-center justify-between border-b border-white/10 p-4"${_scopeId3}><div class="flex items-center gap-2"${_scopeId3}>`);
                            _push5(ssrRenderComponent(_component_Icon, {
                              name: "tabler:share-3",
                              class: "size-5 text-neutral-700 dark:text-neutral-300"
                            }, null, _parent4, _scopeId3));
                            _push5(`<h3 class="text-lg font-semibold text-neutral-900 dark:text-white"${_scopeId3}>${ssrInterpolate(unref($t)("ui.action.share.title"))}</h3></div>`);
                            _push5(ssrRenderComponent(_component_UButton, {
                              size: "sm",
                              variant: "ghost",
                              color: "neutral",
                              icon: "tabler:x",
                              onClick: ($event) => emit("close")
                            }, null, _parent4, _scopeId3));
                            _push5(`</div>`);
                            if (__props.photo) {
                              _push5(`<div class="p-4"${_scopeId3}>`);
                              if (unref(canNativeShare)) {
                                _push5(`<div class="mb-4 flex items-center gap-2"${_scopeId3}>`);
                                _push5(ssrRenderComponent(_component_UButton, {
                                  block: "",
                                  size: "lg",
                                  color: "info",
                                  variant: "soft",
                                  icon: "tabler:share-2",
                                  onClick: nativeShare
                                }, {
                                  default: withCtx((_4, _push6, _parent5, _scopeId4) => {
                                    if (_push6) {
                                      _push6(`${ssrInterpolate(unref($t)("ui.action.share.actions.nativeShare"))}`);
                                    } else {
                                      return [
                                        createTextVNode(toDisplayString$1(unref($t)("ui.action.share.actions.nativeShare")), 1)
                                      ];
                                    }
                                  }),
                                  _: 1
                                }, _parent4, _scopeId3));
                                _push5(ssrRenderComponent(_component_UButton, {
                                  block: "",
                                  size: "lg",
                                  color: "info",
                                  variant: "soft",
                                  icon: "tabler:download",
                                  onClick: downloadOriginalImage
                                }, {
                                  default: withCtx((_4, _push6, _parent5, _scopeId4) => {
                                    if (_push6) {
                                      _push6(`${ssrInterpolate(unref($t)("ui.action.share.actions.downloadOriginalImage"))}`);
                                    } else {
                                      return [
                                        createTextVNode(toDisplayString$1(unref($t)("ui.action.share.actions.downloadOriginalImage")), 1)
                                      ];
                                    }
                                  }),
                                  _: 1
                                }, _parent4, _scopeId3));
                                _push5(`</div>`);
                              } else {
                                _push5(`<!---->`);
                              }
                              _push5(`<div class="space-y-4"${_scopeId3}><div class="rounded-lg border border-neutral-200/50 bg-neutral-50/50 p-3 dark:border-neutral-700/50 dark:bg-neutral-800/50"${_scopeId3}><label class="mb-1 block text-xs font-medium text-neutral-600 dark:text-neutral-400"${_scopeId3}>${ssrInterpolate(unref($t)("ui.action.share.actions.shareUrl"))}</label><div class="flex items-center gap-2"${_scopeId3}><input${ssrRenderAttr("value", unref(shareUrl))} readonly class="flex-1 truncate bg-transparent text-sm text-neutral-800 dark:text-neutral-200 resize-none"${_scopeId3}>`);
                              _push5(ssrRenderComponent(_component_UButton, {
                                size: "xs",
                                variant: "ghost",
                                color: "neutral",
                                icon: "tabler:copy",
                                onClick: copyLink
                              }, null, _parent4, _scopeId3));
                              _push5(`</div></div><div class="rounded-lg border border-neutral-200/50 bg-neutral-50/50 p-3 dark:border-neutral-700/50 dark:bg-neutral-800/50"${_scopeId3}><div class="flex items-center justify-between mb-2"${_scopeId3}><label class="block text-xs font-medium text-neutral-600 dark:text-neutral-400"${_scopeId3}>${ssrInterpolate(unref($t)("ui.action.share.ogImage.title"))}</label>`);
                              _push5(ssrRenderComponent(_component_UButton, {
                                size: "xs",
                                variant: "ghost",
                                color: "neutral",
                                icon: "tabler:download",
                                onClick: downloadOgImage
                              }, {
                                default: withCtx((_4, _push6, _parent5, _scopeId4) => {
                                  if (_push6) {
                                    _push6(`${ssrInterpolate(unref($t)("ui.action.share.actions.downloadOgImage"))}`);
                                  } else {
                                    return [
                                      createTextVNode(toDisplayString$1(unref($t)("ui.action.share.actions.downloadOgImage")), 1)
                                    ];
                                  }
                                }),
                                _: 1
                              }, _parent4, _scopeId3));
                              _push5(`</div><div class="relative rounded-md bg-neutral-100/50 dark:bg-neutral-700/50 overflow-hidden"${_scopeId3}>`);
                              if (unref(ogImageLoading)) {
                                _push5(`<div class="flex items-center justify-center bg-neutral-100/50 dark:bg-neutral-700/50 aspect-[2/1]"${_scopeId3}><div class="flex flex-col items-center gap-2"${_scopeId3}>`);
                                _push5(ssrRenderComponent(_component_Icon, {
                                  name: "tabler:loader-2",
                                  class: "size-6 text-neutral-500 animate-spin"
                                }, null, _parent4, _scopeId3));
                                _push5(`<span class="text-xs text-neutral-500 dark:text-neutral-400"${_scopeId3}>${ssrInterpolate(unref($t)("ui.action.share.ogImage.loading"))}</span></div></div>`);
                              } else if (unref(ogImageError)) {
                                _push5(`<div class="flex items-center justify-center bg-neutral-100/50 dark:bg-neutral-700/50 aspect-[2/1]"${_scopeId3}><div class="flex flex-col items-center gap-2"${_scopeId3}>`);
                                _push5(ssrRenderComponent(_component_Icon, {
                                  name: "tabler:photo-off",
                                  class: "size-6 text-neutral-400"
                                }, null, _parent4, _scopeId3));
                                _push5(`<span class="text-xs text-neutral-500 dark:text-neutral-400"${_scopeId3}>${ssrInterpolate(unref($t)("ui.action.share.ogImage.loadError"))}</span></div></div>`);
                              } else {
                                _push5(`<!---->`);
                              }
                              _push5(`<img${ssrRenderAttr("src", unref(ogImageUrl))}${ssrRenderAttr("alt", unref($t)("ui.action.share.ogImage.alt"))} class="w-full h-auto aspect-[2/1] object-cover rounded" loading="eager" style="${ssrRenderStyle(!unref(ogImageLoading) && !unref(ogImageError) ? null : { display: "none" })}"${_scopeId3}></div></div><div class="grid grid-cols-3 gap-3"${_scopeId3}><!--[-->`);
                              ssrRenderList(unref(socialPlatforms), (platform) => {
                                _push5(`<button type="button" class="cursor-pointer flex flex-col items-center justify-center gap-2 rounded-xl border border-neutral-200/50 bg-white/50 p-4 transition-all hover:scale-105 hover:border-neutral-300/50 hover:bg-white/70 dark:border-neutral-700/50 dark:bg-neutral-800/50 dark:hover:border-neutral-600/50 dark:hover:bg-neutral-700/50"${_scopeId3}>`);
                                _push5(ssrRenderComponent(_component_Icon, {
                                  name: platform.icon,
                                  class: ["size-6", platform.color]
                                }, null, _parent4, _scopeId3));
                                _push5(`<span class="text-xs font-medium text-neutral-700 dark:text-neutral-300"${_scopeId3}>${ssrInterpolate(platform.name)}</span></button>`);
                              });
                              _push5(`<!--]--></div></div></div>`);
                            } else {
                              _push5(`<!---->`);
                            }
                          } else {
                            return [
                              createVNode("div", { class: "flex items-center justify-between border-b border-white/10 p-4" }, [
                                createVNode("div", { class: "flex items-center gap-2" }, [
                                  createVNode(_component_Icon, {
                                    name: "tabler:share-3",
                                    class: "size-5 text-neutral-700 dark:text-neutral-300"
                                  }),
                                  createVNode("h3", { class: "text-lg font-semibold text-neutral-900 dark:text-white" }, toDisplayString$1(unref($t)("ui.action.share.title")), 1)
                                ]),
                                createVNode(_component_UButton, {
                                  size: "sm",
                                  variant: "ghost",
                                  color: "neutral",
                                  icon: "tabler:x",
                                  onClick: ($event) => emit("close")
                                }, null, 8, ["onClick"])
                              ]),
                              __props.photo ? (openBlock(), createBlock("div", {
                                key: 0,
                                class: "p-4"
                              }, [
                                unref(canNativeShare) ? (openBlock(), createBlock("div", {
                                  key: 0,
                                  class: "mb-4 flex items-center gap-2"
                                }, [
                                  createVNode(_component_UButton, {
                                    block: "",
                                    size: "lg",
                                    color: "info",
                                    variant: "soft",
                                    icon: "tabler:share-2",
                                    onClick: nativeShare
                                  }, {
                                    default: withCtx(() => [
                                      createTextVNode(toDisplayString$1(unref($t)("ui.action.share.actions.nativeShare")), 1)
                                    ]),
                                    _: 1
                                  }),
                                  createVNode(_component_UButton, {
                                    block: "",
                                    size: "lg",
                                    color: "info",
                                    variant: "soft",
                                    icon: "tabler:download",
                                    onClick: downloadOriginalImage
                                  }, {
                                    default: withCtx(() => [
                                      createTextVNode(toDisplayString$1(unref($t)("ui.action.share.actions.downloadOriginalImage")), 1)
                                    ]),
                                    _: 1
                                  })
                                ])) : createCommentVNode("", true),
                                createVNode("div", { class: "space-y-4" }, [
                                  createVNode("div", { class: "rounded-lg border border-neutral-200/50 bg-neutral-50/50 p-3 dark:border-neutral-700/50 dark:bg-neutral-800/50" }, [
                                    createVNode("label", { class: "mb-1 block text-xs font-medium text-neutral-600 dark:text-neutral-400" }, toDisplayString$1(unref($t)("ui.action.share.actions.shareUrl")), 1),
                                    createVNode("div", { class: "flex items-center gap-2" }, [
                                      createVNode("input", {
                                        value: unref(shareUrl),
                                        readonly: "",
                                        class: "flex-1 truncate bg-transparent text-sm text-neutral-800 dark:text-neutral-200 resize-none"
                                      }, null, 8, ["value"]),
                                      createVNode(_component_UButton, {
                                        size: "xs",
                                        variant: "ghost",
                                        color: "neutral",
                                        icon: "tabler:copy",
                                        onClick: copyLink
                                      })
                                    ])
                                  ]),
                                  createVNode("div", { class: "rounded-lg border border-neutral-200/50 bg-neutral-50/50 p-3 dark:border-neutral-700/50 dark:bg-neutral-800/50" }, [
                                    createVNode("div", { class: "flex items-center justify-between mb-2" }, [
                                      createVNode("label", { class: "block text-xs font-medium text-neutral-600 dark:text-neutral-400" }, toDisplayString$1(unref($t)("ui.action.share.ogImage.title")), 1),
                                      createVNode(_component_UButton, {
                                        size: "xs",
                                        variant: "ghost",
                                        color: "neutral",
                                        icon: "tabler:download",
                                        onClick: downloadOgImage
                                      }, {
                                        default: withCtx(() => [
                                          createTextVNode(toDisplayString$1(unref($t)("ui.action.share.actions.downloadOgImage")), 1)
                                        ]),
                                        _: 1
                                      })
                                    ]),
                                    createVNode("div", { class: "relative rounded-md bg-neutral-100/50 dark:bg-neutral-700/50 overflow-hidden" }, [
                                      unref(ogImageLoading) ? (openBlock(), createBlock("div", {
                                        key: 0,
                                        class: "flex items-center justify-center bg-neutral-100/50 dark:bg-neutral-700/50 aspect-[2/1]"
                                      }, [
                                        createVNode("div", { class: "flex flex-col items-center gap-2" }, [
                                          createVNode(_component_Icon, {
                                            name: "tabler:loader-2",
                                            class: "size-6 text-neutral-500 animate-spin"
                                          }),
                                          createVNode("span", { class: "text-xs text-neutral-500 dark:text-neutral-400" }, toDisplayString$1(unref($t)("ui.action.share.ogImage.loading")), 1)
                                        ])
                                      ])) : unref(ogImageError) ? (openBlock(), createBlock("div", {
                                        key: 1,
                                        class: "flex items-center justify-center bg-neutral-100/50 dark:bg-neutral-700/50 aspect-[2/1]"
                                      }, [
                                        createVNode("div", { class: "flex flex-col items-center gap-2" }, [
                                          createVNode(_component_Icon, {
                                            name: "tabler:photo-off",
                                            class: "size-6 text-neutral-400"
                                          }),
                                          createVNode("span", { class: "text-xs text-neutral-500 dark:text-neutral-400" }, toDisplayString$1(unref($t)("ui.action.share.ogImage.loadError")), 1)
                                        ])
                                      ])) : createCommentVNode("", true),
                                      withDirectives((openBlock(), createBlock("img", {
                                        key: `og-image-${props.photo.id}-${Date.now()}`,
                                        src: unref(ogImageUrl),
                                        alt: unref($t)("ui.action.share.ogImage.alt"),
                                        class: "w-full h-auto aspect-[2/1] object-cover rounded",
                                        loading: "eager",
                                        onLoad: handleOgImageLoad,
                                        onError: handleOgImageError
                                      }, null, 40, ["src", "alt"])), [
                                        [vShow, !unref(ogImageLoading) && !unref(ogImageError)]
                                      ])
                                    ])
                                  ]),
                                  createVNode("div", { class: "grid grid-cols-3 gap-3" }, [
                                    (openBlock(true), createBlock(Fragment, null, renderList(unref(socialPlatforms), (platform) => {
                                      return openBlock(), createBlock("button", {
                                        key: platform.name,
                                        type: "button",
                                        class: "cursor-pointer flex flex-col items-center justify-center gap-2 rounded-xl border border-neutral-200/50 bg-white/50 p-4 transition-all hover:scale-105 hover:border-neutral-300/50 hover:bg-white/70 dark:border-neutral-700/50 dark:bg-neutral-800/50 dark:hover:border-neutral-600/50 dark:hover:bg-neutral-700/50",
                                        onClick: platform.action
                                      }, [
                                        createVNode(_component_Icon, {
                                          name: platform.icon,
                                          class: ["size-6", platform.color]
                                        }, null, 8, ["name", "class"]),
                                        createVNode("span", { class: "text-xs font-medium text-neutral-700 dark:text-neutral-300" }, toDisplayString$1(platform.name), 1)
                                      ], 8, ["onClick"]);
                                    }), 128))
                                  ])
                                ])
                              ])) : createCommentVNode("", true)
                            ];
                          }
                        }),
                        _: 1
                      }, _parent3, _scopeId2));
                    } else {
                      return [
                        createVNode(unref(motion).div, {
                          initial: { opacity: 0, scale: 0.95, y: 20 },
                          animate: { opacity: 1, scale: 1, y: 0 },
                          exit: { opacity: 0, scale: 0.95, y: 20 },
                          transition: {
                            type: "spring",
                            duration: 0.3,
                            bounce: 0.1
                          },
                          class: "relative mx-4 w-full max-w-md overflow-hidden rounded-2xl border border-white/10 bg-white/90 shadow-2xl backdrop-blur-2xl dark:bg-neutral-900/90",
                          onClick: withModifiers(() => {
                          }, ["stop"])
                        }, {
                          default: withCtx(() => [
                            createVNode("div", { class: "flex items-center justify-between border-b border-white/10 p-4" }, [
                              createVNode("div", { class: "flex items-center gap-2" }, [
                                createVNode(_component_Icon, {
                                  name: "tabler:share-3",
                                  class: "size-5 text-neutral-700 dark:text-neutral-300"
                                }),
                                createVNode("h3", { class: "text-lg font-semibold text-neutral-900 dark:text-white" }, toDisplayString$1(unref($t)("ui.action.share.title")), 1)
                              ]),
                              createVNode(_component_UButton, {
                                size: "sm",
                                variant: "ghost",
                                color: "neutral",
                                icon: "tabler:x",
                                onClick: ($event) => emit("close")
                              }, null, 8, ["onClick"])
                            ]),
                            __props.photo ? (openBlock(), createBlock("div", {
                              key: 0,
                              class: "p-4"
                            }, [
                              unref(canNativeShare) ? (openBlock(), createBlock("div", {
                                key: 0,
                                class: "mb-4 flex items-center gap-2"
                              }, [
                                createVNode(_component_UButton, {
                                  block: "",
                                  size: "lg",
                                  color: "info",
                                  variant: "soft",
                                  icon: "tabler:share-2",
                                  onClick: nativeShare
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString$1(unref($t)("ui.action.share.actions.nativeShare")), 1)
                                  ]),
                                  _: 1
                                }),
                                createVNode(_component_UButton, {
                                  block: "",
                                  size: "lg",
                                  color: "info",
                                  variant: "soft",
                                  icon: "tabler:download",
                                  onClick: downloadOriginalImage
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString$1(unref($t)("ui.action.share.actions.downloadOriginalImage")), 1)
                                  ]),
                                  _: 1
                                })
                              ])) : createCommentVNode("", true),
                              createVNode("div", { class: "space-y-4" }, [
                                createVNode("div", { class: "rounded-lg border border-neutral-200/50 bg-neutral-50/50 p-3 dark:border-neutral-700/50 dark:bg-neutral-800/50" }, [
                                  createVNode("label", { class: "mb-1 block text-xs font-medium text-neutral-600 dark:text-neutral-400" }, toDisplayString$1(unref($t)("ui.action.share.actions.shareUrl")), 1),
                                  createVNode("div", { class: "flex items-center gap-2" }, [
                                    createVNode("input", {
                                      value: unref(shareUrl),
                                      readonly: "",
                                      class: "flex-1 truncate bg-transparent text-sm text-neutral-800 dark:text-neutral-200 resize-none"
                                    }, null, 8, ["value"]),
                                    createVNode(_component_UButton, {
                                      size: "xs",
                                      variant: "ghost",
                                      color: "neutral",
                                      icon: "tabler:copy",
                                      onClick: copyLink
                                    })
                                  ])
                                ]),
                                createVNode("div", { class: "rounded-lg border border-neutral-200/50 bg-neutral-50/50 p-3 dark:border-neutral-700/50 dark:bg-neutral-800/50" }, [
                                  createVNode("div", { class: "flex items-center justify-between mb-2" }, [
                                    createVNode("label", { class: "block text-xs font-medium text-neutral-600 dark:text-neutral-400" }, toDisplayString$1(unref($t)("ui.action.share.ogImage.title")), 1),
                                    createVNode(_component_UButton, {
                                      size: "xs",
                                      variant: "ghost",
                                      color: "neutral",
                                      icon: "tabler:download",
                                      onClick: downloadOgImage
                                    }, {
                                      default: withCtx(() => [
                                        createTextVNode(toDisplayString$1(unref($t)("ui.action.share.actions.downloadOgImage")), 1)
                                      ]),
                                      _: 1
                                    })
                                  ]),
                                  createVNode("div", { class: "relative rounded-md bg-neutral-100/50 dark:bg-neutral-700/50 overflow-hidden" }, [
                                    unref(ogImageLoading) ? (openBlock(), createBlock("div", {
                                      key: 0,
                                      class: "flex items-center justify-center bg-neutral-100/50 dark:bg-neutral-700/50 aspect-[2/1]"
                                    }, [
                                      createVNode("div", { class: "flex flex-col items-center gap-2" }, [
                                        createVNode(_component_Icon, {
                                          name: "tabler:loader-2",
                                          class: "size-6 text-neutral-500 animate-spin"
                                        }),
                                        createVNode("span", { class: "text-xs text-neutral-500 dark:text-neutral-400" }, toDisplayString$1(unref($t)("ui.action.share.ogImage.loading")), 1)
                                      ])
                                    ])) : unref(ogImageError) ? (openBlock(), createBlock("div", {
                                      key: 1,
                                      class: "flex items-center justify-center bg-neutral-100/50 dark:bg-neutral-700/50 aspect-[2/1]"
                                    }, [
                                      createVNode("div", { class: "flex flex-col items-center gap-2" }, [
                                        createVNode(_component_Icon, {
                                          name: "tabler:photo-off",
                                          class: "size-6 text-neutral-400"
                                        }),
                                        createVNode("span", { class: "text-xs text-neutral-500 dark:text-neutral-400" }, toDisplayString$1(unref($t)("ui.action.share.ogImage.loadError")), 1)
                                      ])
                                    ])) : createCommentVNode("", true),
                                    withDirectives((openBlock(), createBlock("img", {
                                      key: `og-image-${props.photo.id}-${Date.now()}`,
                                      src: unref(ogImageUrl),
                                      alt: unref($t)("ui.action.share.ogImage.alt"),
                                      class: "w-full h-auto aspect-[2/1] object-cover rounded",
                                      loading: "eager",
                                      onLoad: handleOgImageLoad,
                                      onError: handleOgImageError
                                    }, null, 40, ["src", "alt"])), [
                                      [vShow, !unref(ogImageLoading) && !unref(ogImageError)]
                                    ])
                                  ])
                                ]),
                                createVNode("div", { class: "grid grid-cols-3 gap-3" }, [
                                  (openBlock(true), createBlock(Fragment, null, renderList(unref(socialPlatforms), (platform) => {
                                    return openBlock(), createBlock("button", {
                                      key: platform.name,
                                      type: "button",
                                      class: "cursor-pointer flex flex-col items-center justify-center gap-2 rounded-xl border border-neutral-200/50 bg-white/50 p-4 transition-all hover:scale-105 hover:border-neutral-300/50 hover:bg-white/70 dark:border-neutral-700/50 dark:bg-neutral-800/50 dark:hover:border-neutral-600/50 dark:hover:bg-neutral-700/50",
                                      onClick: platform.action
                                    }, [
                                      createVNode(_component_Icon, {
                                        name: platform.icon,
                                        class: ["size-6", platform.color]
                                      }, null, 8, ["name", "class"]),
                                      createVNode("span", { class: "text-xs font-medium text-neutral-700 dark:text-neutral-300" }, toDisplayString$1(platform.name), 1)
                                    ], 8, ["onClick"]);
                                  }), 128))
                                ])
                              ])
                            ])) : createCommentVNode("", true)
                          ]),
                          _: 1
                        }, 8, ["onClick"])
                      ];
                    }
                  }),
                  _: 1
                }, _parent2, _scopeId));
              } else {
                _push3(`<!---->`);
              }
            } else {
              return [
                __props.isOpen ? (openBlock(), createBlock(unref(motion).div, {
                  key: 0,
                  initial: { opacity: 0 },
                  animate: { opacity: 1 },
                  exit: { opacity: 0 },
                  transition: { duration: 0.2 },
                  class: "fixed inset-0 z-[60] flex items-center justify-center bg-black/50 backdrop-blur-sm",
                  onClick: handleBackdropClick
                }, {
                  default: withCtx(() => [
                    createVNode(unref(motion).div, {
                      initial: { opacity: 0, scale: 0.95, y: 20 },
                      animate: { opacity: 1, scale: 1, y: 0 },
                      exit: { opacity: 0, scale: 0.95, y: 20 },
                      transition: {
                        type: "spring",
                        duration: 0.3,
                        bounce: 0.1
                      },
                      class: "relative mx-4 w-full max-w-md overflow-hidden rounded-2xl border border-white/10 bg-white/90 shadow-2xl backdrop-blur-2xl dark:bg-neutral-900/90",
                      onClick: withModifiers(() => {
                      }, ["stop"])
                    }, {
                      default: withCtx(() => [
                        createVNode("div", { class: "flex items-center justify-between border-b border-white/10 p-4" }, [
                          createVNode("div", { class: "flex items-center gap-2" }, [
                            createVNode(_component_Icon, {
                              name: "tabler:share-3",
                              class: "size-5 text-neutral-700 dark:text-neutral-300"
                            }),
                            createVNode("h3", { class: "text-lg font-semibold text-neutral-900 dark:text-white" }, toDisplayString$1(unref($t)("ui.action.share.title")), 1)
                          ]),
                          createVNode(_component_UButton, {
                            size: "sm",
                            variant: "ghost",
                            color: "neutral",
                            icon: "tabler:x",
                            onClick: ($event) => emit("close")
                          }, null, 8, ["onClick"])
                        ]),
                        __props.photo ? (openBlock(), createBlock("div", {
                          key: 0,
                          class: "p-4"
                        }, [
                          unref(canNativeShare) ? (openBlock(), createBlock("div", {
                            key: 0,
                            class: "mb-4 flex items-center gap-2"
                          }, [
                            createVNode(_component_UButton, {
                              block: "",
                              size: "lg",
                              color: "info",
                              variant: "soft",
                              icon: "tabler:share-2",
                              onClick: nativeShare
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString$1(unref($t)("ui.action.share.actions.nativeShare")), 1)
                              ]),
                              _: 1
                            }),
                            createVNode(_component_UButton, {
                              block: "",
                              size: "lg",
                              color: "info",
                              variant: "soft",
                              icon: "tabler:download",
                              onClick: downloadOriginalImage
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString$1(unref($t)("ui.action.share.actions.downloadOriginalImage")), 1)
                              ]),
                              _: 1
                            })
                          ])) : createCommentVNode("", true),
                          createVNode("div", { class: "space-y-4" }, [
                            createVNode("div", { class: "rounded-lg border border-neutral-200/50 bg-neutral-50/50 p-3 dark:border-neutral-700/50 dark:bg-neutral-800/50" }, [
                              createVNode("label", { class: "mb-1 block text-xs font-medium text-neutral-600 dark:text-neutral-400" }, toDisplayString$1(unref($t)("ui.action.share.actions.shareUrl")), 1),
                              createVNode("div", { class: "flex items-center gap-2" }, [
                                createVNode("input", {
                                  value: unref(shareUrl),
                                  readonly: "",
                                  class: "flex-1 truncate bg-transparent text-sm text-neutral-800 dark:text-neutral-200 resize-none"
                                }, null, 8, ["value"]),
                                createVNode(_component_UButton, {
                                  size: "xs",
                                  variant: "ghost",
                                  color: "neutral",
                                  icon: "tabler:copy",
                                  onClick: copyLink
                                })
                              ])
                            ]),
                            createVNode("div", { class: "rounded-lg border border-neutral-200/50 bg-neutral-50/50 p-3 dark:border-neutral-700/50 dark:bg-neutral-800/50" }, [
                              createVNode("div", { class: "flex items-center justify-between mb-2" }, [
                                createVNode("label", { class: "block text-xs font-medium text-neutral-600 dark:text-neutral-400" }, toDisplayString$1(unref($t)("ui.action.share.ogImage.title")), 1),
                                createVNode(_component_UButton, {
                                  size: "xs",
                                  variant: "ghost",
                                  color: "neutral",
                                  icon: "tabler:download",
                                  onClick: downloadOgImage
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString$1(unref($t)("ui.action.share.actions.downloadOgImage")), 1)
                                  ]),
                                  _: 1
                                })
                              ]),
                              createVNode("div", { class: "relative rounded-md bg-neutral-100/50 dark:bg-neutral-700/50 overflow-hidden" }, [
                                unref(ogImageLoading) ? (openBlock(), createBlock("div", {
                                  key: 0,
                                  class: "flex items-center justify-center bg-neutral-100/50 dark:bg-neutral-700/50 aspect-[2/1]"
                                }, [
                                  createVNode("div", { class: "flex flex-col items-center gap-2" }, [
                                    createVNode(_component_Icon, {
                                      name: "tabler:loader-2",
                                      class: "size-6 text-neutral-500 animate-spin"
                                    }),
                                    createVNode("span", { class: "text-xs text-neutral-500 dark:text-neutral-400" }, toDisplayString$1(unref($t)("ui.action.share.ogImage.loading")), 1)
                                  ])
                                ])) : unref(ogImageError) ? (openBlock(), createBlock("div", {
                                  key: 1,
                                  class: "flex items-center justify-center bg-neutral-100/50 dark:bg-neutral-700/50 aspect-[2/1]"
                                }, [
                                  createVNode("div", { class: "flex flex-col items-center gap-2" }, [
                                    createVNode(_component_Icon, {
                                      name: "tabler:photo-off",
                                      class: "size-6 text-neutral-400"
                                    }),
                                    createVNode("span", { class: "text-xs text-neutral-500 dark:text-neutral-400" }, toDisplayString$1(unref($t)("ui.action.share.ogImage.loadError")), 1)
                                  ])
                                ])) : createCommentVNode("", true),
                                withDirectives((openBlock(), createBlock("img", {
                                  key: `og-image-${props.photo.id}-${Date.now()}`,
                                  src: unref(ogImageUrl),
                                  alt: unref($t)("ui.action.share.ogImage.alt"),
                                  class: "w-full h-auto aspect-[2/1] object-cover rounded",
                                  loading: "eager",
                                  onLoad: handleOgImageLoad,
                                  onError: handleOgImageError
                                }, null, 40, ["src", "alt"])), [
                                  [vShow, !unref(ogImageLoading) && !unref(ogImageError)]
                                ])
                              ])
                            ]),
                            createVNode("div", { class: "grid grid-cols-3 gap-3" }, [
                              (openBlock(true), createBlock(Fragment, null, renderList(unref(socialPlatforms), (platform) => {
                                return openBlock(), createBlock("button", {
                                  key: platform.name,
                                  type: "button",
                                  class: "cursor-pointer flex flex-col items-center justify-center gap-2 rounded-xl border border-neutral-200/50 bg-white/50 p-4 transition-all hover:scale-105 hover:border-neutral-300/50 hover:bg-white/70 dark:border-neutral-700/50 dark:bg-neutral-800/50 dark:hover:border-neutral-600/50 dark:hover:bg-neutral-700/50",
                                  onClick: platform.action
                                }, [
                                  createVNode(_component_Icon, {
                                    name: platform.icon,
                                    class: ["size-6", platform.color]
                                  }, null, 8, ["name", "class"]),
                                  createVNode("span", { class: "text-xs font-medium text-neutral-700 dark:text-neutral-300" }, toDisplayString$1(platform.name), 1)
                                ], 8, ["onClick"]);
                              }), 128))
                            ])
                          ])
                        ])) : createCommentVNode("", true)
                      ]),
                      _: 1
                    }, 8, ["onClick"])
                  ]),
                  _: 1
                })) : createCommentVNode("", true)
              ];
            }
          }),
          _: 1
        }, _parent));
      }, "body", false, _parent);
    };
  }
});
const _sfc_setup$k = _sfc_main$k.setup;
_sfc_main$k.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/photo/ShareModal.vue");
  return _sfc_setup$k ? _sfc_setup$k(props, ctx) : void 0;
};
const __nuxt_component_4 = Object.assign(_sfc_main$k, { __name: "PhotoShareModal" });
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "LoadingIndicator",
  __ssrInlineRender: true,
  setup(__props, { expose: __expose }) {
    const defaultLoadingState = {
      isVisible: false,
      isConverting: false,
      isHeic: false,
      progress: 0,
      bytesLoaded: 0,
      bytesTotal: 0,
      codec: void 0,
      isWebGLLoading: false,
      webglMessage: void 0,
      webglQuality: "unknown",
      isError: false,
      message: void 0,
      errorMessage: void 0
    };
    const loadingState = ref(defaultLoadingState);
    const updateLoadingState = (state2) => {
      loadingState.value = state2.isVisible === false ? defaultLoadingState : { ...loadingState.value, ...state2 };
    };
    const resetLoadingState = () => {
      loadingState.value = defaultLoadingState;
    };
    __expose({
      updateLoadingState,
      resetLoadingState
    });
    const loadingVariants = {
      initial: {
        opacity: 0,
        x: 20,
        y: 10,
        scale: 0.9
      },
      animate: {
        opacity: 1,
        x: 0,
        y: 0,
        scale: 1
      }
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_Icon = __nuxt_component_0$4;
      _push(ssrRenderComponent(unref(_sfc_main$n), _attrs, {
        default: withCtx((_2, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent(unref(motion).div, {
              style: unref(loadingState).isVisible ? null : { display: "none" },
              key: "loading-indicator",
              class: "absolute bottom-4 right-4 z-40 pointer-events-none bg-black/40 backdrop-blur-3xl rounded-xl border border-white/10 p-3 shadow-2xl",
              initial: loadingVariants.initial,
              animate: loadingVariants.animate,
              exit: loadingVariants.initial,
              transition: {
                type: "spring",
                duration: 0.3,
                bounce: 0
              }
            }, {
              default: withCtx((_22, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(`<div class="flex items-start gap-2 text-white"${_scopeId2}>`);
                  _push3(ssrRenderComponent(_component_Icon, {
                    name: "tabler:loader-2",
                    class: "text-lg animate-spin"
                  }, null, _parent3, _scopeId2));
                  _push3(`<div class="flex flex-col min-w-0 gap-0.5"${_scopeId2}>`);
                  if (unref(loadingState).isError) {
                    _push3(`<!--[--><p class="text-xs font-medium text-red-400"${_scopeId2}>${ssrInterpolate(unref(loadingState).errorMessage || _ctx.$t("viewer.photoload.loadError"))}</p><p class="text-xs text-white/70"${_scopeId2}>${ssrInterpolate(_ctx.$t("viewer.photoload.loading"))}</p><!--]-->`);
                  } else if (unref(loadingState).isConverting) {
                    _push3(`<p class="text-xs font-medium text-white tabular-nums"${_scopeId2}>${ssrInterpolate(unref(loadingState).message || _ctx.$t("viewer.photoload.converting"))}</p>`);
                  } else if (unref(loadingState).isWebGLLoading) {
                    _push3(`<!--[--><div class="flex items-center gap-2"${_scopeId2}><p class="text-xs font-medium text-white"${_scopeId2}>${ssrInterpolate(unref(loadingState).webglMessage || _ctx.$t("viewer.photoload.loadingWebGL"))}</p>`);
                    if (unref(loadingState).webglQuality !== "unknown") {
                      _push3(`<span class="text-xs tabular-nums" style="${ssrRenderStyle({
                        color: unref(loadingState).webglQuality === "high" ? "#4ade80" : unref(loadingState).webglQuality === "medium" ? "#fbbf24" : unref(loadingState).webglQuality === "low" ? "#f87171" : "#94a3b8"
                      })}"${_scopeId2}>${ssrInterpolate(unref(loadingState).webglQuality)}</span>`);
                    } else {
                      _push3(`<!---->`);
                    }
                    _push3(`</div><p class="text-xs text-white/70"${_scopeId2}>${ssrInterpolate(_ctx.$t("viewer.photoload.loadingTexture"))}</p><!--]-->`);
                  } else {
                    _push3(`<!--[--><div class="flex items-center gap-2"${_scopeId2}><p class="text-xs font-medium text-white"${_scopeId2}>${ssrInterpolate(unref(loadingState).isHeic ? _ctx.$t("viewer.photoload.loadingHEIC") : _ctx.$t("viewer.photoload.loading"))}</p><span class="text-xs text-white/60 tabular-nums"${_scopeId2}>${ssrInterpolate(Math.round(unref(loadingState).progress))}% </span></div>`);
                    if (unref(loadingState).bytesTotal > 0) {
                      _push3(`<p class="text-xs text-white/70 tabular-nums"${_scopeId2}>${ssrInterpolate((unref(loadingState).bytesLoaded / 1024 / 1024).toFixed(1))}MB / ${ssrInterpolate((unref(loadingState).bytesTotal / 1024 / 1024).toFixed(1))}MB </p>`);
                    } else {
                      _push3(`<!---->`);
                    }
                    _push3(`<!--]-->`);
                  }
                  _push3(`</div></div>`);
                } else {
                  return [
                    createVNode("div", { class: "flex items-start gap-2 text-white" }, [
                      createVNode(_component_Icon, {
                        name: "tabler:loader-2",
                        class: "text-lg animate-spin"
                      }),
                      createVNode("div", { class: "flex flex-col min-w-0 gap-0.5" }, [
                        unref(loadingState).isError ? (openBlock(), createBlock(Fragment, { key: 0 }, [
                          createVNode("p", { class: "text-xs font-medium text-red-400" }, toDisplayString$1(unref(loadingState).errorMessage || _ctx.$t("viewer.photoload.loadError")), 1),
                          createVNode("p", { class: "text-xs text-white/70" }, toDisplayString$1(_ctx.$t("viewer.photoload.loading")), 1)
                        ], 64)) : unref(loadingState).isConverting ? (openBlock(), createBlock("p", {
                          key: 1,
                          class: "text-xs font-medium text-white tabular-nums"
                        }, toDisplayString$1(unref(loadingState).message || _ctx.$t("viewer.photoload.converting")), 1)) : unref(loadingState).isWebGLLoading ? (openBlock(), createBlock(Fragment, { key: 2 }, [
                          createVNode("div", { class: "flex items-center gap-2" }, [
                            createVNode("p", { class: "text-xs font-medium text-white" }, toDisplayString$1(unref(loadingState).webglMessage || _ctx.$t("viewer.photoload.loadingWebGL")), 1),
                            unref(loadingState).webglQuality !== "unknown" ? (openBlock(), createBlock("span", {
                              key: 0,
                              class: "text-xs tabular-nums",
                              style: {
                                color: unref(loadingState).webglQuality === "high" ? "#4ade80" : unref(loadingState).webglQuality === "medium" ? "#fbbf24" : unref(loadingState).webglQuality === "low" ? "#f87171" : "#94a3b8"
                              }
                            }, toDisplayString$1(unref(loadingState).webglQuality), 5)) : createCommentVNode("", true)
                          ]),
                          createVNode("p", { class: "text-xs text-white/70" }, toDisplayString$1(_ctx.$t("viewer.photoload.loadingTexture")), 1)
                        ], 64)) : (openBlock(), createBlock(Fragment, { key: 3 }, [
                          createVNode("div", { class: "flex items-center gap-2" }, [
                            createVNode("p", { class: "text-xs font-medium text-white" }, toDisplayString$1(unref(loadingState).isHeic ? _ctx.$t("viewer.photoload.loadingHEIC") : _ctx.$t("viewer.photoload.loading")), 1),
                            createVNode("span", { class: "text-xs text-white/60 tabular-nums" }, toDisplayString$1(Math.round(unref(loadingState).progress)) + "% ", 1)
                          ]),
                          unref(loadingState).bytesTotal > 0 ? (openBlock(), createBlock("p", {
                            key: 0,
                            class: "text-xs text-white/70 tabular-nums"
                          }, toDisplayString$1((unref(loadingState).bytesLoaded / 1024 / 1024).toFixed(1)) + "MB / " + toDisplayString$1((unref(loadingState).bytesTotal / 1024 / 1024).toFixed(1)) + "MB ", 1)) : createCommentVNode("", true)
                        ], 64))
                      ])
                    ])
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
          } else {
            return [
              withDirectives(createVNode(unref(motion).div, {
                key: "loading-indicator",
                class: "absolute bottom-4 right-4 z-40 pointer-events-none bg-black/40 backdrop-blur-3xl rounded-xl border border-white/10 p-3 shadow-2xl",
                initial: loadingVariants.initial,
                animate: loadingVariants.animate,
                exit: loadingVariants.initial,
                transition: {
                  type: "spring",
                  duration: 0.3,
                  bounce: 0
                }
              }, {
                default: withCtx(() => [
                  createVNode("div", { class: "flex items-start gap-2 text-white" }, [
                    createVNode(_component_Icon, {
                      name: "tabler:loader-2",
                      class: "text-lg animate-spin"
                    }),
                    createVNode("div", { class: "flex flex-col min-w-0 gap-0.5" }, [
                      unref(loadingState).isError ? (openBlock(), createBlock(Fragment, { key: 0 }, [
                        createVNode("p", { class: "text-xs font-medium text-red-400" }, toDisplayString$1(unref(loadingState).errorMessage || _ctx.$t("viewer.photoload.loadError")), 1),
                        createVNode("p", { class: "text-xs text-white/70" }, toDisplayString$1(_ctx.$t("viewer.photoload.loading")), 1)
                      ], 64)) : unref(loadingState).isConverting ? (openBlock(), createBlock("p", {
                        key: 1,
                        class: "text-xs font-medium text-white tabular-nums"
                      }, toDisplayString$1(unref(loadingState).message || _ctx.$t("viewer.photoload.converting")), 1)) : unref(loadingState).isWebGLLoading ? (openBlock(), createBlock(Fragment, { key: 2 }, [
                        createVNode("div", { class: "flex items-center gap-2" }, [
                          createVNode("p", { class: "text-xs font-medium text-white" }, toDisplayString$1(unref(loadingState).webglMessage || _ctx.$t("viewer.photoload.loadingWebGL")), 1),
                          unref(loadingState).webglQuality !== "unknown" ? (openBlock(), createBlock("span", {
                            key: 0,
                            class: "text-xs tabular-nums",
                            style: {
                              color: unref(loadingState).webglQuality === "high" ? "#4ade80" : unref(loadingState).webglQuality === "medium" ? "#fbbf24" : unref(loadingState).webglQuality === "low" ? "#f87171" : "#94a3b8"
                            }
                          }, toDisplayString$1(unref(loadingState).webglQuality), 5)) : createCommentVNode("", true)
                        ]),
                        createVNode("p", { class: "text-xs text-white/70" }, toDisplayString$1(_ctx.$t("viewer.photoload.loadingTexture")), 1)
                      ], 64)) : (openBlock(), createBlock(Fragment, { key: 3 }, [
                        createVNode("div", { class: "flex items-center gap-2" }, [
                          createVNode("p", { class: "text-xs font-medium text-white" }, toDisplayString$1(unref(loadingState).isHeic ? _ctx.$t("viewer.photoload.loadingHEIC") : _ctx.$t("viewer.photoload.loading")), 1),
                          createVNode("span", { class: "text-xs text-white/60 tabular-nums" }, toDisplayString$1(Math.round(unref(loadingState).progress)) + "% ", 1)
                        ]),
                        unref(loadingState).bytesTotal > 0 ? (openBlock(), createBlock("p", {
                          key: 0,
                          class: "text-xs text-white/70 tabular-nums"
                        }, toDisplayString$1((unref(loadingState).bytesLoaded / 1024 / 1024).toFixed(1)) + "MB / " + toDisplayString$1((unref(loadingState).bytesTotal / 1024 / 1024).toFixed(1)) + "MB ", 1)) : createCommentVNode("", true)
                      ], 64))
                    ])
                  ])
                ]),
                _: 1
              }, 8, ["initial", "animate", "exit"]), [
                [vShow, unref(loadingState).isVisible]
              ])
            ];
          }
        }),
        _: 1
      }, _parent));
    };
  }
});
const _sfc_setup$j = _sfc_main$j.setup;
_sfc_main$j.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/photo/LoadingIndicator.vue");
  return _sfc_setup$j ? _sfc_setup$j(props, ctx) : void 0;
};
const LoadingIndicator = Object.assign(_sfc_main$j, { __name: "PhotoLoadingIndicator" });
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "ThumbImage",
  __ssrInlineRender: true,
  props: {
    src: {},
    alt: {},
    thumbhash: { default: null },
    class: { default: "" },
    thumbhashClass: { default: "" },
    style: { default: void 0 },
    threshold: { default: 0.1 },
    rootMargin: { default: "50px" },
    imageContain: { type: Boolean, default: false },
    lazy: { type: Boolean, default: true }
  },
  emits: ["load", "error"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const elemRef = useTemplateRef("elemRef");
    const isElemVisible = ref(false);
    const isLoaded = ref(false);
    const isError = ref(false);
    const { stop } = useIntersectionObserver(
      elemRef,
      ([entry2], _observerElement) => {
        isElemVisible.value = entry2?.isIntersecting || false;
        if (isElemVisible.value) {
          stop();
        }
      },
      {
        threshold: props.threshold,
        rootMargin: props.rootMargin,
        immediate: props.lazy
      }
    );
    return (_ctx, _push, _parent, _attrs) => {
      const _component_ThumbHash = __nuxt_component_0$2;
      const _component_Icon = __nuxt_component_0$4;
      _push(`<div${ssrRenderAttrs(mergeProps({
        ref_key: "elemRef",
        ref: elemRef,
        class: unref(twMerge)("relative overflow-hidden", _ctx.$props.class),
        style: __props.style
      }, _attrs))}>`);
      if (__props.thumbhash) {
        _push(ssrRenderComponent(_component_ThumbHash, {
          thumbhash: __props.thumbhash,
          class: unref(twMerge)("absolute inset-0 scale-110 blur-sm", __props.thumbhashClass)
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      if (unref(isElemVisible)) {
        _push(`<img loading="lazy"${ssrRenderAttr("src", __props.src)}${ssrRenderAttr("alt", __props.alt)} class="${ssrRenderClass(
          unref(twMerge)(
            "absolute inset-0 w-full h-full transition-opacity duration-300",
            __props.imageContain ? "object-contain" : "object-cover",
            unref(isLoaded) ? "opacity-100" : "opacity-0"
          )
        )}">`);
      } else {
        _push(`<!---->`);
      }
      if (unref(isError)) {
        _push(`<div class="absolute inset-0 flex justify-center items-center bg-neutral-200 dark:bg-neutral-800">`);
        _push(ssrRenderComponent(_component_Icon, {
          name: "tabler:photo-off",
          class: "size-6 text-neutral-400"
        }, null, _parent));
        _push(`<p class="mt-2 text-sm text-neutral-500 dark:text-neutral-400"> 加载图片失败 </p></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$i = _sfc_main$i.setup;
_sfc_main$i.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/ThumbImage.vue");
  return _sfc_setup$i ? _sfc_setup$i(props, ctx) : void 0;
};
const __nuxt_component_2$1 = Object.assign(_sfc_main$i, { __name: "ThumbImage" });
class LRUCache {
  capacity;
  storage = /* @__PURE__ */ new Map();
  onEvict;
  constructor(maxSize = 10, cleanupFn) {
    this.capacity = Math.max(1, maxSize);
    this.onEvict = cleanupFn;
  }
  get(key) {
    const item = this.storage.get(key);
    if (item === void 0) {
      return void 0;
    }
    this.storage.delete(key);
    this.storage.set(key, item);
    return item;
  }
  set(key, value) {
    if (this.storage.has(key)) {
      const existingValue = this.storage.get(key);
      this.executeCleanup(existingValue, key, `更新缓存项: ${String(key)}`);
      this.storage.delete(key);
    } else {
      this.ensureCapacity();
    }
    this.storage.set(key, value);
    this.logCacheOperation("添加", key);
  }
  delete(key) {
    const item = this.storage.get(key);
    if (item === void 0) {
      return false;
    }
    this.executeCleanup(item, key, `手动删除: ${String(key)}`);
    return this.storage.delete(key);
  }
  has(key) {
    return this.storage.has(key);
  }
  clear() {
    const itemCount = this.storage.size;
    for (const [key, item] of this.storage.entries()) {
      this.executeCleanup(item, key, `清空缓存: ${String(key)}`);
    }
    this.storage.clear();
    console.info(`缓存已清空，共释放 ${itemCount} 个项目`);
  }
  size() {
    return this.storage.size;
  }
  getStats() {
    return {
      size: this.storage.size,
      maxSize: this.capacity,
      keys: [...this.storage.keys()]
    };
  }
  values() {
    return this.storage.values();
  }
  entries() {
    return this.storage.entries();
  }
  /**
   * 确保缓存容量不超限
   */
  ensureCapacity() {
    while (this.storage.size >= this.capacity) {
      const oldestKey = this.storage.keys().next().value;
      if (oldestKey !== void 0) {
        const oldestValue = this.storage.get(oldestKey);
        this.executeCleanup(oldestValue, oldestKey, `容量限制淘汰: ${String(oldestKey)}`);
        this.storage.delete(oldestKey);
      }
    }
  }
  /**
   * 安全执行清理回调
   */
  executeCleanup(item, key, context) {
    if (!this.onEvict) return;
    try {
      this.onEvict(item, key, context);
    } catch (err) {
      console.warn(`缓存清理失败 (${context}):`, err);
    }
  }
  /**
   * 记录缓存操作日志
   */
  logCacheOperation(action, key) {
    console.info(
      `LRU 缓存: ${action} ${String(key)}，当前大小: ${this.storage.size}/${this.capacity}`
    );
  }
}
const normalImageCache = new LRUCache(6, (v, k2, reason) => {
  try {
    URL.revokeObjectURL(v.blobSrc);
    console.log(`已释放 Blob URL - ${k2} (${reason})`);
  } catch (err) {
    console.warn(`Blob URL 释放失败 (${k2}):`, err);
  }
});
class ImageLoaderManager {
  lastXHR = null;
  timer = null;
  async isValidImageBlob(blob) {
    if (blob.size === 0) return false;
    try {
      const fileType = await fileTypeFromBlob(blob);
      if (!fileType) return false;
      if (!fileType.mime.startsWith("image/")) return false;
      return true;
    } catch {
      return false;
    }
  }
  async loadImage(src, callbacks = {}) {
    const { onProgress, onError, onUpdateLoadingState } = callbacks;
    onUpdateLoadingState?.({
      isVisible: true
    });
    return new Promise((resolve, reject) => {
      this.timer = setTimeout(async () => {
        const xhr = new (void 0)();
        xhr.open("GET", src);
        xhr.responseType = "blob";
        xhr.onload = async () => {
          if (xhr.status === 200) {
            try {
              const blob = xhr.response;
              if (!await this.isValidImageBlob(blob)) {
                onError?.();
                onUpdateLoadingState?.({
                  isVisible: false
                });
                return;
              }
              const processResult = await this.processNormalImage(
                blob,
                src,
                callbacks
              );
              resolve(processResult);
            } catch (err) {
              onError?.();
              onUpdateLoadingState?.({
                isVisible: false
              });
              reject(err);
            }
          } else {
            onError?.();
            onUpdateLoadingState?.({
              isVisible: false
            });
            reject(new Error(`Failed to load image: ${xhr.status}`));
          }
        };
        xhr.onprogress = (event) => {
          if (event.lengthComputable) {
            const progress2 = event.loaded / event.total * 100;
            onProgress?.(progress2);
            onUpdateLoadingState?.({
              progress: progress2,
              bytesLoaded: event.loaded,
              bytesTotal: event.total
            });
          }
        };
        xhr.onerror = () => {
          onError?.();
          onUpdateLoadingState?.({
            isVisible: false
          });
          reject(new Error(`Failed to load image`));
        };
        xhr.send();
        this.lastXHR = xhr;
      }, 300);
    });
  }
  async processNormalImage(blob, originalUrl, callbacks) {
    const { onUpdateLoadingState } = callbacks;
    const cacheKey = originalUrl;
    const cacheResult = normalImageCache.get(cacheKey);
    if (cacheResult) {
      onUpdateLoadingState?.({
        isVisible: false
      });
      return {
        blobSrc: cacheResult.blobSrc
      };
    }
    const url = URL.createObjectURL(blob);
    const result = {
      blobSrc: url,
      originalSize: blob.size,
      format: blob.type
    };
    normalImageCache.set(cacheKey, result);
    onUpdateLoadingState?.({
      isVisible: false
    });
    return {
      blobSrc: originalUrl
    };
  }
  cleanup() {
    if (this.lastXHR) {
      this.lastXHR.abort();
      this.lastXHR = null;
    }
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
  }
}
const useImageLoader = (src, isCurrentImage, highResLoaded, error, loadingIndicatorRef, onProgress, onError, updateBlobSrc, updateHighResLoaded, updateError, updateHighResImageRendered, onImageLoaded) => {
  if (highResLoaded || !isCurrentImage || error) return null;
  const loaderManager = new ImageLoaderManager();
  const cleanup = () => {
    loaderManager.cleanup();
    updateBlobSrc?.(null);
    updateHighResImageRendered?.(false);
    updateHighResLoaded?.(false);
    updateError?.(false);
  };
  const loadImage = async () => {
    try {
      const loadResult = await loaderManager.loadImage(src, {
        onProgress,
        onError,
        onUpdateLoadingState: (state2) => {
          loadingIndicatorRef?.updateLoadingState(state2);
        }
      });
      updateBlobSrc?.(loadResult.blobSrc);
      updateHighResLoaded?.(true);
      onImageLoaded?.();
    } catch {
      updateError?.(true);
      loadingIndicatorRef?.updateLoadingState({
        isVisible: true,
        isError: true,
        message: "载入图片失败"
      });
    }
  };
  cleanup();
  loadImage();
  return loaderManager;
};
const useWebGLWorkState = (loadingIndicatorRef) => {
  const { t } = useI18n();
  return (isLoading, state2, quality) => {
    let message = "";
    if (state2 === E.TEXTURE_LOADING) {
      message = t("viewer.photoload.loadingTexture");
    } else if (state2 === E.IMAGE_LOADING) {
      message = t("viewer.photoload.loading");
    }
    loadingIndicatorRef?.updateLoadingState({
      isVisible: isLoading,
      isWebGLLoading: isLoading,
      webglMessage: message,
      webglQuality: quality
    });
  };
};
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  __name: "ProgressiveImage",
  __ssrInlineRender: true,
  props: {
    src: {},
    thumbnailSrc: { default: "" },
    thumbhash: { default: null },
    alt: { default: "Image" },
    width: { default: void 0 },
    height: { default: void 0 },
    className: { default: "" },
    enablePan: { type: Boolean, default: true },
    enableZoom: { type: Boolean, default: true },
    isCurrentImage: { type: Boolean, default: true },
    loadingIndicatorRef: {},
    onProgress: { type: Function, default: void 0 },
    onError: { type: Function, default: void 0 },
    onZoomChange: { type: Function, default: void 0 },
    onBlobSrcChange: { type: Function, default: void 0 },
    onImageLoaded: { type: Function, default: void 0 },
    isLivePhoto: { type: Boolean, default: false },
    livePhotoVideoUrl: { default: "" },
    isHDR: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const containerRef = ref();
    const highResLoaded = ref(false);
    const highResRendered = ref(false);
    const hasError = ref(false);
    const currentSrc = ref();
    const isDev = computed(() => false);
    const showDebugInfo = computed(() => isDev.value && false);
    const webglViewerRef = ref();
    const loaderManagerRef = ref(null);
    const showThumbnail = computed(() => {
      return props.thumbnailSrc && (!highResRendered.value || hasError.value);
    });
    const showWebGLViewer = computed(() => {
      return highResLoaded.value && currentSrc.value && props.isCurrentImage && !hasError.value;
    });
    const loadImage = () => {
      loaderManagerRef.value = useImageLoader(
        props.src,
        props.isCurrentImage,
        highResLoaded.value,
        hasError.value,
        props.loadingIndicatorRef,
        props.onProgress,
        props.onError,
        (src) => currentSrc.value = src,
        (loaded) => highResLoaded.value = loaded,
        (error) => hasError.value = error,
        (rendered) => highResRendered.value = rendered,
        props.onImageLoaded
      );
    };
    watch(
      () => props.isCurrentImage,
      (isCurrent, wasCurrent) => {
        if (!isCurrent && wasCurrent) {
          loaderManagerRef.value?.cleanup();
          loaderManagerRef.value = null;
        } else if (isCurrent && !wasCurrent && !highResLoaded.value && !hasError.value) {
          loadImage();
        }
      },
      { immediate: false }
    );
    watch(
      () => props.src,
      (newSrc, oldSrc) => {
        if (newSrc !== oldSrc) {
          loaderManagerRef.value?.cleanup();
          loaderManagerRef.value = null;
          highResLoaded.value = false;
          highResRendered.value = false;
          hasError.value = false;
          currentSrc.value = null;
          if (props.isCurrentImage) {
            loadImage();
          }
        }
      },
      { immediate: false }
    );
    loadImage();
    const handleWebGLStateChange = useWebGLWorkState(props.loadingIndicatorRef);
    const handleZoomChange = (originalScale, relativeScale) => {
      const isZoomed = relativeScale > 1.1;
      if (props.onZoomChange) {
        props.onZoomChange(isZoomed, Math.round(originalScale * 10) / 10);
      }
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_ThumbImage = __nuxt_component_2$1;
      const _component_Icon = __nuxt_component_0$4;
      _push(`<div${ssrRenderAttrs(mergeProps({
        ref_key: "containerRef",
        ref: containerRef,
        class: "relative w-full h-full flex items-center justify-center"
      }, _attrs))}>`);
      if (unref(showThumbnail)) {
        _push(ssrRenderComponent(_component_ThumbImage, {
          src: __props.thumbnailSrc,
          thumbhash: __props.thumbhash,
          alt: __props.alt,
          class: "absolute inset-0 w-full h-full object-contain",
          "thumbhash-class": "opacity-50",
          "image-contain": ""
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      if (unref(showWebGLViewer)) {
        _push(ssrRenderComponent(unref(Ct), {
          ref_key: "webglViewerRef",
          ref: webglViewerRef,
          src: unref(currentSrc),
          class: [__props.className, "w-full h-full"],
          width: __props.width,
          height: __props.height,
          "center-on-init": true,
          "limit-to-bounds": true,
          smooth: true,
          "min-scale": 1,
          "max-scale": 12,
          wheel: { step: 0.2, wheelDisabled: false, touchPadDisabled: false },
          pinch: { step: 0.2 },
          "double-click": { mode: "toggle", step: 2.4, animationTime: 400 },
          panning: { velocityDisabled: false },
          debug: unref(showDebugInfo),
          onZoomChange: handleZoomChange,
          onLoadingStateChange: unref(handleWebGLStateChange)
        }, null, _parent));
      } else {
        _push(`<!---->`);
      }
      if (unref(hasError)) {
        _push(`<div class="flex flex-col items-center justify-center text-white/70 gap-2">`);
        _push(ssrRenderComponent(_component_Icon, {
          name: "tabler:photo-off",
          class: "w-12 h-12"
        }, null, _parent));
        _push(`<p class="text-sm">图片加载失败</p></div>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$h = _sfc_main$h.setup;
_sfc_main$h.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/photo/ProgressiveImage.vue");
  return _sfc_setup$h ? _sfc_setup$h(props, ctx) : void 0;
};
const ProgressiveImage = Object.assign(_sfc_main$h, { __name: "PhotoProgressiveImage" });
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  __name: "GalleryThumbnail",
  __ssrInlineRender: true,
  props: {
    photos: {},
    currentIndex: {}
  },
  emits: ["indexChange"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const galleryScrollContainer = ref();
    const containerClientWidth = ref(0);
    const isMobile = useMediaQuery("(max-width: 768px)");
    const THUMBNAIL_CONFIG = {
      size: { sm: 48, lg: 64 },
      gap: { sm: 8, lg: 12 },
      padding: { sm: 12, lg: 16 }
    };
    const currentThumbnailSize = computed(
      () => isMobile.value ? THUMBNAIL_CONFIG.size.sm : THUMBNAIL_CONFIG.size.lg
    );
    const currentGapSize = computed(
      () => isMobile.value ? THUMBNAIL_CONFIG.gap.sm : THUMBNAIL_CONFIG.gap.lg
    );
    const currentPaddingSize = computed(
      () => isMobile.value ? THUMBNAIL_CONFIG.padding.sm : THUMBNAIL_CONFIG.padding.lg
    );
    const thumbnailList = computed(() => {
      return props.photos.map((photo, index2) => ({
        ...photo,
        index: index2,
        isActive: index2 === props.currentIndex
      }));
    });
    const onThumbnailClick = (index2) => {
      emit("indexChange", index2);
    };
    const scrollToActiveThumbnail = async () => {
      if (!galleryScrollContainer.value) return;
      await nextTick();
      const containerWidth = containerClientWidth.value;
      const thumbnailSize = currentThumbnailSize.value;
      const gapSize = currentGapSize.value;
      const thumbnailLeftPosition = props.currentIndex * thumbnailSize + gapSize * props.currentIndex;
      const targetScrollLeft = thumbnailLeftPosition - containerWidth / 2 + thumbnailSize / 2;
      galleryScrollContainer.value.scrollTo({
        left: targetScrollLeft,
        behavior: "smooth"
      });
    };
    watch(
      () => props.currentIndex,
      (_newIndex, _oldIndex) => {
        scrollToActiveThumbnail();
      },
      { immediate: true }
    );
    watch(isMobile, scrollToActiveThumbnail);
    return (_ctx, _push, _parent, _attrs) => {
      const _component_ThumbHash = __nuxt_component_0$2;
      const _component_Icon = __nuxt_component_0$4;
      _push(ssrRenderComponent(unref(motion).div, mergeProps({
        initial: { opacity: 0, y: 100 },
        animate: { opacity: 1, y: 0 },
        exit: { opacity: 0, y: 100 },
        transition: { type: "spring", duration: 0.4, bounce: 0, delay: 0.1 },
        class: "gallery-thumbnail-container bg-black/20 dark:bg-black/30 backdrop-blur-xl border-t border-white/10 shrink-0 z-10"
      }, _attrs), {
        default: withCtx((_2, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="gallery-scroll-area overflow-x-auto scrollbar-none flex" style="${ssrRenderStyle({
              gap: `${currentGapSize.value}px`,
              padding: `${currentPaddingSize.value}px`
            })}" data-v-e12e3d31${_scopeId}><!--[-->`);
            ssrRenderList(thumbnailList.value, (photo) => {
              _push2(`<button type="button" class="${ssrRenderClass([{
                "thumbnail-active border-white shadow-lg scale-110": photo.isActive,
                "thumbnail-inactive border-white/20 hover:border-white/40 grayscale-50 hover:grayscale-0": !photo.isActive
              }, "thumbnail-item relative flex-shrink-0 rounded-lg overflow-hidden border-2 transition-all duration-200 contain-intrinsic-size"])}" style="${ssrRenderStyle({
                width: `${currentThumbnailSize.value}px`,
                height: `${currentThumbnailSize.value}px`
              })}" data-v-e12e3d31${_scopeId}>`);
              if (photo.thumbnailHash) {
                _push2(ssrRenderComponent(_component_ThumbHash, {
                  thumbhash: photo.thumbnailHash,
                  class: "absolute inset-0 w-full h-full"
                }, null, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
              if (photo.thumbnailUrl) {
                _push2(`<img${ssrRenderAttr("src", photo.thumbnailUrl)}${ssrRenderAttr("alt", photo.title || "Photo thumbnail")} class="absolute inset-0 w-full h-full object-cover" loading="lazy" data-v-e12e3d31${_scopeId}>`);
              } else if (!photo.thumbnailHash) {
                _push2(`<div class="absolute inset-0 w-full h-full bg-gray-700 flex items-center justify-center" data-v-e12e3d31${_scopeId}>`);
                _push2(ssrRenderComponent(_component_Icon, {
                  name: "tabler:photo",
                  class: "w-6 h-6 text-gray-400"
                }, null, _parent2, _scopeId));
                _push2(`</div>`);
              } else {
                _push2(`<!---->`);
              }
              _push2(`</button>`);
            });
            _push2(`<!--]--></div>`);
          } else {
            return [
              createVNode("div", {
                ref_key: "galleryScrollContainer",
                ref: galleryScrollContainer,
                class: "gallery-scroll-area overflow-x-auto scrollbar-none flex",
                style: {
                  gap: `${currentGapSize.value}px`,
                  padding: `${currentPaddingSize.value}px`
                }
              }, [
                (openBlock(true), createBlock(Fragment, null, renderList(thumbnailList.value, (photo) => {
                  return openBlock(), createBlock("button", {
                    key: photo.id,
                    type: "button",
                    class: ["thumbnail-item relative flex-shrink-0 rounded-lg overflow-hidden border-2 transition-all duration-200 contain-intrinsic-size", {
                      "thumbnail-active border-white shadow-lg scale-110": photo.isActive,
                      "thumbnail-inactive border-white/20 hover:border-white/40 grayscale-50 hover:grayscale-0": !photo.isActive
                    }],
                    style: {
                      width: `${currentThumbnailSize.value}px`,
                      height: `${currentThumbnailSize.value}px`
                    },
                    onClick: ($event) => onThumbnailClick(photo.index)
                  }, [
                    photo.thumbnailHash ? (openBlock(), createBlock(_component_ThumbHash, {
                      key: 0,
                      thumbhash: photo.thumbnailHash,
                      class: "absolute inset-0 w-full h-full"
                    }, null, 8, ["thumbhash"])) : createCommentVNode("", true),
                    photo.thumbnailUrl ? (openBlock(), createBlock("img", {
                      key: 1,
                      src: photo.thumbnailUrl,
                      alt: photo.title || "Photo thumbnail",
                      class: "absolute inset-0 w-full h-full object-cover",
                      loading: "lazy"
                    }, null, 8, ["src", "alt"])) : !photo.thumbnailHash ? (openBlock(), createBlock("div", {
                      key: 2,
                      class: "absolute inset-0 w-full h-full bg-gray-700 flex items-center justify-center"
                    }, [
                      createVNode(_component_Icon, {
                        name: "tabler:photo",
                        class: "w-6 h-6 text-gray-400"
                      })
                    ])) : createCommentVNode("", true)
                  ], 14, ["onClick"]);
                }), 128))
              ], 4)
            ];
          }
        }),
        _: 1
      }, _parent));
    };
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_setup$g = _sfc_main$g.setup;
_sfc_main$g.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/photo/GalleryThumbnail.vue");
  return _sfc_setup$g ? _sfc_setup$g(props, ctx) : void 0;
};
const GalleryThumbnail = /* @__PURE__ */ Object.assign(_export_sfc(_sfc_main$g, [["__scopeId", "data-v-e12e3d31"]]), { __name: "PhotoGalleryThumbnail" });
const version$1 = 8;
const name$1 = "ChronoFrame Light";
const metadata$1 = { "mapbox:autocomposite": false, "mapbox:type": "template", "maputnik:renderer": "mbgljs", "openmaptiles:version": "3.x", "openmaptiles:mapbox:owner": "openmaptiles", "openmaptiles:mapbox:source:url": "mapbox://openmaptiles.4qljc88t" };
const center$1 = [116.4074, 39.9042];
const zoom$1 = 2;
const projection$1 = { "type": "globe" };
const sources$1 = { "openmaptiles": { "type": "vector", "url": "https://api.maptiler.com/tiles/v3-openmaptiles/tiles.json?key=" } };
const sprite$1 = "https://openmaptiles.github.io/maptiler-basic-gl-style/sprite";
const glyphs$1 = "https://api.maptiler.com/fonts/{fontstack}/{range}.pbf?key=";
const layers$1 = /* @__PURE__ */ JSON.parse('[{"id":"background","type":"background","paint":{"background-color":"hsl(47, 26%, 88%)"}},{"id":"landuse-residential","type":"fill","source":"openmaptiles","source-layer":"landuse","filter":["all",["==","$type","Polygon"],["in","class","residential","suburb","neighbourhood"]],"layout":{"visibility":"visible"},"paint":{"fill-color":"hsl(47, 13%, 86%)","fill-opacity":0.7}},{"id":"landcover_grass","type":"fill","source":"openmaptiles","source-layer":"landcover","filter":["==","class","grass"],"paint":{"fill-color":"hsl(82, 46%, 72%)","fill-opacity":0.45}},{"id":"landcover_wood","type":"fill","source":"openmaptiles","source-layer":"landcover","filter":["==","class","wood"],"paint":{"fill-color":"hsl(82, 46%, 72%)","fill-opacity":{"base":1,"stops":[[8,0.6],[22,1]]}}},{"id":"water","type":"fill","source":"openmaptiles","source-layer":"water","filter":["all",["==","$type","Polygon"],["!=","intermittent",1],["!=","brunnel","tunnel"]],"layout":{"visibility":"visible"},"paint":{"fill-color":"hsl(205, 56%, 73%)"}},{"id":"water_intermittent","type":"fill","source":"openmaptiles","source-layer":"water","filter":["all",["==","$type","Polygon"],["==","intermittent",1]],"layout":{"visibility":"visible"},"paint":{"fill-color":"hsl(205, 56%, 73%)","fill-opacity":0.7}},{"id":"landcover-ice-shelf","type":"fill","source":"openmaptiles","source-layer":"landcover","filter":["==","subclass","ice_shelf"],"layout":{"visibility":"visible"},"paint":{"fill-color":"hsl(47, 26%, 88%)","fill-opacity":0.8}},{"id":"landcover-glacier","type":"fill","source":"openmaptiles","source-layer":"landcover","filter":["==","subclass","glacier"],"layout":{"visibility":"visible"},"paint":{"fill-color":"hsl(47, 22%, 94%)","fill-opacity":{"base":1,"stops":[[0,1],[8,0.5]]}}},{"id":"landcover_sand","type":"fill","metadata":{},"source":"openmaptiles","source-layer":"landcover","filter":["all",["in","class","sand"]],"paint":{"fill-antialias":false,"fill-color":"rgba(232, 214, 38, 1)","fill-opacity":0.3}},{"id":"landuse","type":"fill","source":"openmaptiles","source-layer":"landuse","filter":["==","class","agriculture"],"layout":{"visibility":"visible"},"paint":{"fill-color":"#eae0d0"}},{"id":"landuse_overlay_national_park","type":"fill","source":"openmaptiles","source-layer":"landcover","filter":["==","class","national_park"],"paint":{"fill-color":"#E1EBB0","fill-opacity":{"base":1,"stops":[[5,0],[9,0.75]]}}},{"id":"waterway-tunnel","type":"line","source":"openmaptiles","source-layer":"waterway","filter":["all",["==","$type","LineString"],["==","brunnel","tunnel"]],"layout":{"visibility":"visible"},"paint":{"line-color":"hsl(205, 56%, 73%)","line-dasharray":[3,3],"line-gap-width":{"stops":[[12,0],[20,6]]},"line-opacity":1,"line-width":{"base":1.4,"stops":[[8,1],[20,2]]}}},{"id":"waterway","type":"line","source":"openmaptiles","source-layer":"waterway","filter":["all",["==","$type","LineString"],["!in","brunnel","tunnel","bridge"],["!=","intermittent",1]],"layout":{"visibility":"visible"},"paint":{"line-color":"hsl(205, 56%, 73%)","line-opacity":1,"line-width":{"base":1.4,"stops":[[8,1],[20,8]]}}},{"id":"waterway_intermittent","type":"line","source":"openmaptiles","source-layer":"waterway","filter":["all",["==","$type","LineString"],["!in","brunnel","tunnel","bridge"],["==","intermittent",1]],"layout":{"visibility":"visible"},"paint":{"line-color":"hsl(205, 56%, 73%)","line-dasharray":[2,1],"line-opacity":1,"line-width":{"base":1.4,"stops":[[8,1],[20,8]]}}},{"id":"tunnel_railway_transit","type":"line","source":"openmaptiles","source-layer":"transportation","minzoom":0,"filter":["all",["==","$type","LineString"],["==","brunnel","tunnel"],["==","class","transit"]],"layout":{"line-cap":"butt","line-join":"miter"},"paint":{"line-color":"hsl(34, 12%, 66%)","line-dasharray":[3,3],"line-opacity":{"base":1,"stops":[[11,0],[16,1]]}}},{"id":"building","type":"fill","source":"openmaptiles","source-layer":"building","paint":{"fill-antialias":true,"fill-color":"rgba(222, 211, 190, 1)","fill-opacity":{"base":1,"stops":[[13,0],[15,1]]},"fill-outline-color":{"stops":[[15,"rgba(212, 177, 146, 0)"],[16,"rgba(212, 177, 146, 0.5)"]]}}},{"id":"housenumber","type":"symbol","source":"openmaptiles","source-layer":"housenumber","minzoom":17,"filter":["==","$type","Point"],"layout":{"text-field":"{housenumber}","text-font":["Noto Sans Regular"],"text-size":10},"paint":{"text-color":"rgba(212, 177, 146, 1)"}},{"id":"road_area_pier","type":"fill","metadata":{},"source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","Polygon"],["==","class","pier"]],"layout":{"visibility":"visible"},"paint":{"fill-antialias":true,"fill-color":"hsl(47, 26%, 88%)"}},{"id":"road_pier","type":"line","metadata":{},"source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["in","class","pier"]],"layout":{"line-cap":"round","line-join":"round"},"paint":{"line-color":"hsl(47, 26%, 88%)","line-width":{"base":1.2,"stops":[[15,1],[17,4]]}}},{"id":"road_bridge_area","type":"fill","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","Polygon"],["in","brunnel","bridge"]],"layout":{},"paint":{"fill-color":"hsl(47, 26%, 88%)","fill-opacity":0.5}},{"id":"road_path","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["in","class","path","track"]],"layout":{"line-cap":"square","line-join":"bevel"},"paint":{"line-color":"hsl(0, 0%, 97%)","line-dasharray":[1,1],"line-width":{"base":1.55,"stops":[[4,0.25],[20,10]]}}},{"id":"road_minor","type":"line","source":"openmaptiles","source-layer":"transportation","minzoom":13,"filter":["all",["==","$type","LineString"],["in","class","minor","service"]],"layout":{"line-cap":"round","line-join":"round"},"paint":{"line-color":"hsl(0, 0%, 97%)","line-width":{"base":1.55,"stops":[[4,0.25],[20,30]]}}},{"id":"tunnel_minor","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["==","brunnel","tunnel"],["==","class","minor_road"]],"layout":{"line-cap":"butt","line-join":"miter"},"paint":{"line-color":"#efefef","line-dasharray":[0.36,0.18],"line-width":{"base":1.55,"stops":[[4,0.25],[20,30]]}}},{"id":"tunnel_major","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["==","brunnel","tunnel"],["in","class","primary","secondary","tertiary","trunk"]],"layout":{"line-cap":"butt","line-join":"miter"},"paint":{"line-color":"#fff","line-dasharray":[0.28,0.14],"line-width":{"base":1.4,"stops":[[6,0.5],[20,30]]}}},{"id":"aeroway-area","type":"fill","metadata":{"mapbox:group":"1444849345966.4436"},"source":"openmaptiles","source-layer":"aeroway","minzoom":4,"filter":["all",["==","$type","Polygon"],["in","class","runway","taxiway"]],"layout":{"visibility":"visible"},"paint":{"fill-color":"rgba(255, 255, 255, 1)","fill-opacity":{"base":1,"stops":[[13,0],[14,1]]}}},{"id":"aeroway-taxiway","type":"line","metadata":{"mapbox:group":"1444849345966.4436"},"source":"openmaptiles","source-layer":"aeroway","minzoom":12,"filter":["all",["in","class","taxiway"],["==","$type","LineString"]],"layout":{"line-cap":"round","line-join":"round","visibility":"visible"},"paint":{"line-color":"rgba(255, 255, 255, 1)","line-opacity":1,"line-width":{"base":1.5,"stops":[[12,1],[17,10]]}}},{"id":"aeroway-runway","type":"line","metadata":{"mapbox:group":"1444849345966.4436"},"source":"openmaptiles","source-layer":"aeroway","minzoom":4,"filter":["all",["in","class","runway"],["==","$type","LineString"]],"layout":{"line-cap":"round","line-join":"round","visibility":"visible"},"paint":{"line-color":"rgba(255, 255, 255, 1)","line-opacity":1,"line-width":{"base":1.5,"stops":[[11,4],[17,50]]}}},{"id":"road_trunk_primary","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["in","class","trunk","primary"]],"layout":{"line-cap":"round","line-join":"round"},"paint":{"line-color":"#fff","line-width":{"base":1.4,"stops":[[6,0.5],[20,30]]}}},{"id":"road_secondary_tertiary","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["in","class","secondary","tertiary"]],"layout":{"line-cap":"round","line-join":"round"},"paint":{"line-color":"#fff","line-width":{"base":1.4,"stops":[[6,0.5],[20,20]]}}},{"id":"road_major_motorway","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["==","class","motorway"]],"layout":{"line-cap":"round","line-join":"round"},"paint":{"line-color":"hsl(0, 0%, 100%)","line-offset":0,"line-width":{"base":1.4,"stops":[[8,1],[16,10]]}}},{"id":"railway-transit","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","class","transit"],["!=","brunnel","tunnel"]],"layout":{"visibility":"visible"},"paint":{"line-color":"hsl(34, 12%, 66%)","line-opacity":{"base":1,"stops":[[11,0],[16,1]]}}},{"id":"railway","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["==","class","rail"],"layout":{"visibility":"visible"},"paint":{"line-color":"hsl(34, 12%, 66%)","line-opacity":{"base":1,"stops":[[11,0],[16,1]]}}},{"id":"waterway-bridge-case","type":"line","source":"openmaptiles","source-layer":"waterway","filter":["all",["==","$type","LineString"],["==","brunnel","bridge"]],"layout":{"line-cap":"butt","line-join":"miter"},"paint":{"line-color":"#bbbbbb","line-gap-width":{"base":1.55,"stops":[[4,0.25],[20,30]]},"line-width":{"base":1.6,"stops":[[12,0.5],[20,10]]}}},{"id":"waterway-bridge","type":"line","source":"openmaptiles","source-layer":"waterway","filter":["all",["==","$type","LineString"],["==","brunnel","bridge"]],"layout":{"line-cap":"round","line-join":"round"},"paint":{"line-color":"hsl(205, 56%, 73%)","line-width":{"base":1.55,"stops":[[4,0.25],[20,30]]}}},{"id":"bridge_minor case","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["==","brunnel","bridge"],["==","class","minor_road"]],"layout":{"line-cap":"butt","line-join":"miter"},"paint":{"line-color":"#dedede","line-gap-width":{"base":1.55,"stops":[[4,0.25],[20,30]]},"line-width":{"base":1.6,"stops":[[12,0.5],[20,10]]}}},{"id":"bridge_major case","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["==","brunnel","bridge"],["in","class","primary","secondary","tertiary","trunk"]],"layout":{"line-cap":"butt","line-join":"miter"},"paint":{"line-color":"#dedede","line-gap-width":{"base":1.55,"stops":[[4,0.25],[20,30]]},"line-width":{"base":1.6,"stops":[[12,0.5],[20,10]]}}},{"id":"bridge_minor","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["==","brunnel","bridge"],["==","class","minor_road"]],"layout":{"line-cap":"round","line-join":"round"},"paint":{"line-color":"#efefef","line-width":{"base":1.55,"stops":[[4,0.25],[20,30]]}}},{"id":"bridge_major","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["==","brunnel","bridge"],["in","class","primary","secondary","tertiary","trunk"]],"layout":{"line-cap":"round","line-join":"round"},"paint":{"line-color":"#fff","line-width":{"base":1.4,"stops":[[6,0.5],[20,30]]}}},{"id":"admin_sub","type":"line","source":"openmaptiles","source-layer":"boundary","filter":["in","admin_level",4,6,8],"layout":{"visibility":"visible"},"paint":{"line-color":"hsla(0, 0%, 60%, 0.5)","line-dasharray":[2,1]}},{"id":"admin_country_z0-4","type":"line","source":"openmaptiles","source-layer":"boundary","minzoom":0,"maxzoom":5,"filter":["all",["<=","admin_level",2],["==","$type","LineString"],["!has","claimed_by"]],"layout":{"line-cap":"round","line-join":"round","visibility":"visible"},"paint":{"line-color":"hsl(0, 0%, 60%)","line-width":{"base":1.3,"stops":[[3,0.5],[22,15]]}}},{"id":"admin_country_z5-","type":"line","source":"openmaptiles","source-layer":"boundary","minzoom":5,"filter":["all",["<=","admin_level",2],["==","$type","LineString"]],"layout":{"line-cap":"round","line-join":"round","visibility":"visible"},"paint":{"line-color":"hsl(0, 0%, 60%)","line-width":{"base":1.3,"stops":[[3,0.5],[22,15]]}}},{"id":"poi_label","type":"symbol","source":"openmaptiles","source-layer":"poi","minzoom":14,"filter":["all",["==","$type","Point"],["==","rank",1]],"layout":{"icon-size":1,"text-anchor":"top","text-field":"{name:latin}\\n{name:nonlatin}","text-font":["Noto Sans Regular"],"text-max-width":8,"text-offset":[0,0.5],"text-size":11,"visibility":"visible"},"paint":{"text-color":"#666","text-halo-blur":1,"text-halo-color":"rgba(255,255,255,0.75)","text-halo-width":1}},{"id":"airport-label","type":"symbol","source":"openmaptiles","source-layer":"aerodrome_label","minzoom":10,"filter":["all",["has","iata"]],"layout":{"icon-size":1,"text-anchor":"top","text-field":"{name:latin}\\n{name:nonlatin}","text-font":["Noto Sans Regular"],"text-max-width":8,"text-offset":[0,0.5],"text-size":11,"visibility":"visible"},"paint":{"text-color":"#666","text-halo-blur":1,"text-halo-color":"rgba(255,255,255,0.75)","text-halo-width":1}},{"id":"road_major_label","type":"symbol","source":"openmaptiles","source-layer":"transportation_name","minzoom":13,"filter":["==","$type","LineString"],"layout":{"symbol-placement":"line","text-field":"{name:latin} {name:nonlatin}","text-font":["Noto Sans Regular"],"text-letter-spacing":0.1,"text-rotation-alignment":"map","text-size":{"base":1.4,"stops":[[10,8],[20,14]]},"text-transform":"uppercase","visibility":"visible"},"paint":{"text-color":"#000","text-halo-color":"hsl(0, 0%, 100%)","text-halo-width":2}},{"id":"place_label_other","type":"symbol","source":"openmaptiles","source-layer":"place","minzoom":8,"filter":["all",["==","$type","Point"],["!in","class","city","state","country","continent"]],"layout":{"text-anchor":"center","text-field":"{name:nonlatin}","text-font":["Noto Sans Regular"],"text-max-width":6,"text-size":{"stops":[[6,10],[12,14]]},"visibility":"visible"},"paint":{"text-color":"hsl(0, 0%, 25%)","text-halo-blur":0,"text-halo-color":"hsl(0, 0%, 100%)","text-halo-width":2}},{"id":"place_label_state","type":"symbol","source":"openmaptiles","source-layer":"place","minzoom":3,"maxzoom":16,"filter":["all",["==","$type","Point"],["in","class","state","region","province"]],"layout":{"text-field":"{name:nonlatin}","text-font":["Noto Sans Regular"],"text-max-width":10,"text-size":{"stops":[[3,14],[8,20]]},"symbol-sort-key":10},"paint":{"text-color":"hsl(0, 0%, 0%)","text-halo-blur":0,"text-halo-color":"hsla(0, 0%, 100%, 0.75)","text-halo-width":2}},{"id":"place_label_state_tw","type":"symbol","source":"openmaptiles","source-layer":"place","minzoom":3,"maxzoom":16,"filter":["all",["==","$type","Point"],["==","class","country"],["any",["==","iso_a2","TW"],["==","wikidata","Q865"],["==","name:en","Taiwan"],["==","name","Taiwan"]]],"layout":{"text-field":"台湾省","text-font":["Noto Sans Regular"],"text-max-width":10,"text-size":{"stops":[[3,14],[8,20]]},"symbol-sort-key":10},"paint":{"text-color":"hsl(0, 0%, 0%)","text-halo-blur":0,"text-halo-color":"hsla(0, 0%, 100%, 0.75)","text-halo-width":2}},{"id":"place_label_city","type":"symbol","source":"openmaptiles","source-layer":"place","minzoom":5,"maxzoom":16,"filter":["all",["==","$type","Point"],["==","class","city"]],"layout":{"text-field":"{name:nonlatin}","text-font":["Noto Sans Regular"],"text-max-width":10,"text-size":{"stops":[[6,12],[10,16]]},"symbol-sort-key":1},"paint":{"text-color":"hsl(0, 0%, 0%)","text-halo-blur":0,"text-halo-color":"hsla(0, 0%, 100%, 0.75)","text-halo-width":2}},{"id":"country_label-other","type":"symbol","source":"openmaptiles","source-layer":"place","maxzoom":12,"filter":["all",["==","$type","Point"],["==","class","country"],["!has","iso_a2"]],"layout":{"text-field":"{name:latin}","text-font":["Noto Sans Regular"],"text-max-width":10,"text-size":{"stops":[[3,12],[8,22]]},"visibility":"visible"},"paint":{"text-color":"hsl(0, 0%, 13%)","text-halo-blur":0,"text-halo-color":"rgba(255,255,255,0.75)","text-halo-width":2}},{"id":"country_label","type":"symbol","source":"openmaptiles","source-layer":"place","maxzoom":12,"filter":["all",["==","$type","Point"],["==","class","country"],["has","iso_a2"],["!=","iso_a2","TW"]],"layout":{"text-field":"{name:latin}","text-font":["Noto Sans Bold"],"text-max-width":10,"text-size":{"stops":[[3,12],[8,22]]},"visibility":"visible"},"paint":{"text-color":"hsl(0, 0%, 13%)","text-halo-blur":0,"text-halo-color":"rgba(255,255,255,0.75)","text-halo-width":2}}]');
const id$1 = "basic";
const owner$1 = "ChronoFrame";
const ChronoFrameLightStyle = {
  version: version$1,
  name: name$1,
  metadata: metadata$1,
  center: center$1,
  zoom: zoom$1,
  projection: projection$1,
  sources: sources$1,
  sprite: sprite$1,
  glyphs: glyphs$1,
  layers: layers$1,
  id: id$1,
  owner: owner$1
};
const version = 8;
const name = "ChronoFrame Dark";
const metadata = { "mapbox:autocomposite": false, "mapbox:type": "template", "maputnik:renderer": "mbgljs", "openmaptiles:version": "3.x", "openmaptiles:mapbox:owner": "openmaptiles", "openmaptiles:mapbox:source:url": "mapbox://openmaptiles.4qljc88t" };
const center = [116.4074, 39.9042];
const zoom = 2;
const projection = { "type": "globe" };
const sources = { "openmaptiles": { "type": "vector", "url": "https://api.maptiler.com/tiles/v3-openmaptiles/tiles.json?key=" } };
const sprite = "https://openmaptiles.github.io/maptiler-basic-gl-style/sprite";
const glyphs = "https://api.maptiler.com/fonts/{fontstack}/{range}.pbf?key=";
const layers = /* @__PURE__ */ JSON.parse('[{"id":"background","type":"background","paint":{"background-color":"rgba(51, 51, 51, 1)"}},{"id":"landuse-residential","type":"fill","source":"openmaptiles","source-layer":"landuse","filter":["all",["==","$type","Polygon"],["in","class","residential","suburb","neighbourhood"]],"layout":{"visibility":"visible"},"paint":{"fill-color":"rgba(74, 74, 74, 0.64)","fill-opacity":0.7}},{"id":"landcover_grass","type":"fill","source":"openmaptiles","source-layer":"landcover","filter":["==","class","grass"],"paint":{"fill-color":"rgba(150, 189, 109, 0.66)","fill-opacity":0.45}},{"id":"landcover_wood","type":"fill","source":"openmaptiles","source-layer":"landcover","filter":["==","class","wood"],"paint":{"fill-color":"rgba(94, 109, 75, 0.44)","fill-opacity":{"base":1,"stops":[[8,0.6],[22,1]]}}},{"id":"water","type":"fill","source":"openmaptiles","source-layer":"water","filter":["all",["==","$type","Polygon"],["!=","intermittent",1],["!=","brunnel","tunnel"]],"layout":{"visibility":"visible"},"paint":{"fill-color":"rgba(148, 193, 225, 0.19)"}},{"id":"water_intermittent","type":"fill","source":"openmaptiles","source-layer":"water","filter":["all",["==","$type","Polygon"],["==","intermittent",1]],"layout":{"visibility":"visible"},"paint":{"fill-color":"rgba(30, 30, 30, 1)","fill-opacity":0.7}},{"id":"landcover-ice-shelf","type":"fill","source":"openmaptiles","source-layer":"landcover","filter":["==","subclass","ice_shelf"],"layout":{"visibility":"visible"},"paint":{"fill-color":"hsl(47, 26%, 88%)","fill-opacity":0.8}},{"id":"landcover-glacier","type":"fill","source":"openmaptiles","source-layer":"landcover","filter":["==","subclass","glacier"],"layout":{"visibility":"visible"},"paint":{"fill-color":"rgba(90, 90, 90, 1)","fill-opacity":{"base":1,"stops":[[0,1],[8,0.5]]}}},{"id":"landcover_sand","type":"fill","metadata":{},"source":"openmaptiles","source-layer":"landcover","filter":["all",["in","class","sand"]],"paint":{"fill-antialias":false,"fill-color":"rgba(232, 214, 38, 1)","fill-opacity":0.3}},{"id":"landuse","type":"fill","source":"openmaptiles","source-layer":"landuse","filter":["==","class","agriculture"],"layout":{"visibility":"visible"},"paint":{"fill-color":"#eae0d0"}},{"id":"landuse_overlay_national_park","type":"fill","source":"openmaptiles","source-layer":"landcover","filter":["==","class","national_park"],"paint":{"fill-color":"#E1EBB0","fill-opacity":{"base":1,"stops":[[5,0],[9,0.75]]}}},{"id":"waterway-tunnel","type":"line","source":"openmaptiles","source-layer":"waterway","filter":["all",["==","$type","LineString"],["==","brunnel","tunnel"]],"layout":{"visibility":"visible"},"paint":{"line-color":"hsl(205, 56%, 73%)","line-dasharray":[3,3],"line-gap-width":{"stops":[[12,0],[20,6]]},"line-opacity":1,"line-width":{"base":1.4,"stops":[[8,1],[20,2]]}}},{"id":"waterway","type":"line","source":"openmaptiles","source-layer":"waterway","filter":["all",["==","$type","LineString"],["!in","brunnel","tunnel","bridge"],["!=","intermittent",1]],"layout":{"visibility":"visible"},"paint":{"line-color":"rgba(148, 193, 225, 0.35)","line-opacity":1,"line-width":{"base":1.4,"stops":[[8,1],[20,8]]}}},{"id":"waterway_intermittent","type":"line","source":"openmaptiles","source-layer":"waterway","filter":["all",["==","$type","LineString"],["!in","brunnel","tunnel","bridge"],["==","intermittent",1]],"layout":{"visibility":"visible"},"paint":{"line-color":"hsl(205, 56%, 73%)","line-dasharray":[2,1],"line-opacity":1,"line-width":{"base":1.4,"stops":[[8,1],[20,8]]}}},{"id":"tunnel_railway_transit","type":"line","source":"openmaptiles","source-layer":"transportation","minzoom":0,"filter":["all",["==","$type","LineString"],["==","brunnel","tunnel"],["==","class","transit"]],"layout":{"line-cap":"butt","line-join":"miter"},"paint":{"line-color":"hsl(34, 12%, 66%)","line-dasharray":[3,3],"line-opacity":{"base":1,"stops":[[11,0],[16,1]]}}},{"id":"building","type":"fill","source":"openmaptiles","source-layer":"building","layout":{"visibility":"visible"},"paint":{"fill-antialias":true,"fill-color":"rgba(135, 135, 135, 1)","fill-opacity":{"base":1,"stops":[[13,0],[15,1]]},"fill-outline-color":{"stops":[[15,"rgba(212, 177, 146, 0)"],[16,"rgba(212, 177, 146, 0.5)"]]}}},{"id":"housenumber","type":"symbol","source":"openmaptiles","source-layer":"housenumber","minzoom":17,"filter":["==","$type","Point"],"layout":{"text-field":"{housenumber}","text-font":["Noto Sans Regular"],"text-size":10},"paint":{"text-color":"rgba(212, 177, 146, 1)"}},{"id":"road_area_pier","type":"fill","metadata":{},"source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","Polygon"],["==","class","pier"]],"layout":{"visibility":"visible"},"paint":{"fill-antialias":true,"fill-color":"hsl(47, 26%, 88%)"}},{"id":"road_pier","type":"line","metadata":{},"source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["in","class","pier"]],"layout":{"line-cap":"round","line-join":"round","visibility":"visible"},"paint":{"line-color":"hsl(47, 26%, 88%)","line-width":{"base":1.2,"stops":[[15,1],[17,4]]}}},{"id":"road_bridge_area","type":"fill","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","Polygon"],["in","brunnel","bridge"]],"layout":{"visibility":"visible"},"paint":{"fill-color":"rgba(90, 90, 90, 0.56)","fill-opacity":0.5}},{"id":"road_path","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["in","class","path","track"]],"layout":{"line-cap":"square","line-join":"bevel","visibility":"visible"},"paint":{"line-color":"rgba(125, 125, 125, 1)","line-dasharray":[1,1],"line-width":{"base":1.55,"stops":[[4,0.25],[20,10]]}}},{"id":"road_minor","type":"line","source":"openmaptiles","source-layer":"transportation","minzoom":13,"filter":["all",["==","$type","LineString"],["in","class","minor","service"]],"layout":{"line-cap":"round","line-join":"round","visibility":"visible"},"paint":{"line-color":"rgba(88, 88, 88, 1)","line-width":{"base":1.55,"stops":[[4,0.25],[20,30]]}}},{"id":"tunnel_minor","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["==","brunnel","tunnel"],["==","class","minor_road"]],"layout":{"line-cap":"butt","line-join":"miter"},"paint":{"line-color":"#efefef","line-dasharray":[0.36,0.18],"line-width":{"base":1.55,"stops":[[4,0.25],[20,30]]}}},{"id":"tunnel_major","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["==","brunnel","tunnel"],["in","class","primary","secondary","tertiary","trunk"]],"layout":{"line-cap":"butt","line-join":"miter"},"paint":{"line-color":"#fff","line-dasharray":[0.28,0.14],"line-width":{"base":1.4,"stops":[[6,0.5],[20,30]]}}},{"id":"aeroway-area","type":"fill","metadata":{"mapbox:group":"1444849345966.4436"},"source":"openmaptiles","source-layer":"aeroway","minzoom":4,"filter":["all",["==","$type","Polygon"],["in","class","runway","taxiway"]],"layout":{"visibility":"visible"},"paint":{"fill-color":"rgba(80, 80, 80, 1)","fill-opacity":{"base":1,"stops":[[13,0],[14,1]]}}},{"id":"aeroway-taxiway","type":"line","metadata":{"mapbox:group":"1444849345966.4436"},"source":"openmaptiles","source-layer":"aeroway","minzoom":12,"filter":["all",["in","class","taxiway"],["==","$type","LineString"]],"layout":{"line-cap":"round","line-join":"round","visibility":"visible"},"paint":{"line-color":"rgba(103, 89, 41, 1)","line-opacity":1,"line-width":{"base":1.5,"stops":[[12,1],[17,10]]}}},{"id":"aeroway-runway","type":"line","metadata":{"mapbox:group":"1444849345966.4436"},"source":"openmaptiles","source-layer":"aeroway","minzoom":4,"filter":["all",["in","class","runway"],["==","$type","LineString"]],"layout":{"line-cap":"round","line-join":"round","visibility":"visible"},"paint":{"line-color":"rgba(80, 80, 80, 1)","line-opacity":1,"line-width":{"base":1.5,"stops":[[11,4],[17,50]]}}},{"id":"road_trunk_primary","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["in","class","trunk","primary"]],"layout":{"line-cap":"round","line-join":"round","visibility":"visible"},"paint":{"line-color":"rgba(88, 88, 88, 1)","line-width":{"base":1.4,"stops":[[6,0.5],[20,30]]}}},{"id":"road_secondary_tertiary","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["in","class","secondary","tertiary"]],"layout":{"line-cap":"round","line-join":"round","visibility":"visible"},"paint":{"line-color":"rgba(88, 88, 88, 1)","line-width":{"base":1.4,"stops":[[6,0.5],[20,20]]}}},{"id":"road_major_motorway","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["==","class","motorway"]],"layout":{"line-cap":"round","line-join":"round","visibility":"visible"},"paint":{"line-color":"rgba(88, 88, 88, 1)","line-offset":0,"line-width":{"base":1.4,"stops":[[8,1],[16,10]]}}},{"id":"railway-transit","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","class","transit"],["!=","brunnel","tunnel"]],"layout":{"visibility":"visible"},"paint":{"line-color":"hsl(34, 12%, 66%)","line-opacity":{"base":1,"stops":[[11,0],[16,1]]}}},{"id":"railway","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["==","class","rail"],"layout":{"visibility":"visible"},"paint":{"line-color":"hsl(34, 12%, 66%)","line-opacity":{"base":1,"stops":[[11,0],[16,1]]}}},{"id":"waterway-bridge-case","type":"line","source":"openmaptiles","source-layer":"waterway","filter":["all",["==","$type","LineString"],["==","brunnel","bridge"]],"layout":{"line-cap":"butt","line-join":"miter"},"paint":{"line-color":"#bbbbbb","line-gap-width":{"base":1.55,"stops":[[4,0.25],[20,30]]},"line-width":{"base":1.6,"stops":[[12,0.5],[20,10]]}}},{"id":"waterway-bridge","type":"line","source":"openmaptiles","source-layer":"waterway","filter":["all",["==","$type","LineString"],["==","brunnel","bridge"]],"layout":{"line-cap":"round","line-join":"round"},"paint":{"line-color":"hsl(205, 56%, 73%)","line-width":{"base":1.55,"stops":[[4,0.25],[20,30]]}}},{"id":"bridge_minor case","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["==","brunnel","bridge"],["==","class","minor_road"]],"layout":{"line-cap":"butt","line-join":"miter"},"paint":{"line-color":"#dedede","line-gap-width":{"base":1.55,"stops":[[4,0.25],[20,30]]},"line-width":{"base":1.6,"stops":[[12,0.5],[20,10]]}}},{"id":"bridge_major case","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["==","brunnel","bridge"],["in","class","primary","secondary","tertiary","trunk"]],"layout":{"line-cap":"butt","line-join":"miter","visibility":"visible"},"paint":{"line-color":"rgba(154, 154, 154, 1)","line-gap-width":{"base":1.55,"stops":[[4,0.25],[20,30]]},"line-width":{"base":1.6,"stops":[[12,0.5],[20,10]]}}},{"id":"bridge_minor","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["==","brunnel","bridge"],["==","class","minor_road"]],"layout":{"line-cap":"round","line-join":"round","visibility":"visible"},"paint":{"line-color":"rgba(135, 135, 135, 1)","line-width":{"base":1.55,"stops":[[4,0.25],[20,30]]}}},{"id":"bridge_major","type":"line","source":"openmaptiles","source-layer":"transportation","filter":["all",["==","$type","LineString"],["==","brunnel","bridge"],["in","class","primary","secondary","tertiary","trunk"]],"layout":{"line-cap":"round","line-join":"round","visibility":"visible"},"paint":{"line-color":"rgba(119, 119, 119, 1)","line-width":{"base":1.4,"stops":[[6,0.5],[20,30]]}}},{"id":"admin_sub","type":"line","source":"openmaptiles","source-layer":"boundary","filter":["in","admin_level",4,6,8],"layout":{"visibility":"visible"},"paint":{"line-color":"hsla(0, 0%, 60%, 0.5)","line-dasharray":[2,1]}},{"id":"admin_country_z0-4","type":"line","source":"openmaptiles","source-layer":"boundary","minzoom":0,"maxzoom":5,"filter":["all",["<=","admin_level",2],["==","$type","LineString"],["!has","claimed_by"]],"layout":{"line-cap":"round","line-join":"round","visibility":"none"},"paint":{"line-color":"hsl(0, 0%, 60%)","line-width":{"base":1.3,"stops":[[3,0.5],[22,15]]}}},{"id":"admin_country_z5-","type":"line","source":"openmaptiles","source-layer":"boundary","minzoom":5,"filter":["all",["<=","admin_level",2],["==","$type","LineString"]],"layout":{"line-cap":"round","line-join":"round","visibility":"visible"},"paint":{"line-color":"hsl(0, 0%, 60%)","line-width":{"base":1.3,"stops":[[3,0.5],[22,15]]}}},{"id":"poi_label","type":"symbol","source":"openmaptiles","source-layer":"poi","minzoom":14,"filter":["all",["==","$type","Point"],["==","rank",1]],"layout":{"icon-size":1,"text-anchor":"top","text-field":"{name:latin}\\n{name:nonlatin}","text-font":["Noto Sans Regular"],"text-max-width":8,"text-offset":[0,0.5],"text-size":11,"visibility":"visible"},"paint":{"text-color":"rgba(135, 135, 135, 1)","text-halo-blur":1,"text-halo-color":"rgba(47, 47, 47, 0.75)","text-halo-width":1}},{"id":"airport-label","type":"symbol","source":"openmaptiles","source-layer":"aerodrome_label","minzoom":10,"filter":["all",["has","iata"]],"layout":{"icon-size":1,"text-anchor":"top","text-field":"{name:latin}\\n{name:nonlatin}","text-font":["Noto Sans Regular"],"text-max-width":8,"text-offset":[0,0.5],"text-size":11,"visibility":"visible"},"paint":{"text-color":"rgba(135, 135, 135, 1)","text-halo-blur":1,"text-halo-color":"rgba(47, 47, 47, 0.75)","text-halo-width":1}},{"id":"road_major_label","type":"symbol","source":"openmaptiles","source-layer":"transportation_name","minzoom":13,"filter":["==","$type","LineString"],"layout":{"symbol-placement":"line","text-field":"{name:latin} {name:nonlatin}","text-font":["Noto Sans Regular"],"text-letter-spacing":0.1,"text-rotation-alignment":"map","text-size":{"base":1.4,"stops":[[10,8],[20,14]]},"text-transform":"uppercase","visibility":"visible"},"paint":{"text-color":"rgba(135, 135, 135, 1)","text-halo-color":"rgba(47, 47, 47, 0.75)","text-halo-width":2}},{"id":"place_label_other","type":"symbol","source":"openmaptiles","source-layer":"place","minzoom":8,"filter":["all",["==","$type","Point"],["!in","class","city","state","country","continent"]],"layout":{"text-anchor":"center","text-field":"{name:nonlatin}","text-font":["Noto Sans Regular"],"text-max-width":6,"text-size":{"stops":[[6,10],[12,14]]},"visibility":"visible"},"paint":{"text-color":"rgba(135, 135, 135, 1)","text-halo-blur":0,"text-halo-color":"rgba(47, 47, 47, 0.75)","text-halo-width":2}},{"id":"place_label_state","type":"symbol","source":"openmaptiles","source-layer":"place","minzoom":3,"maxzoom":16,"filter":["all",["==","$type","Point"],["in","class","state","region","province"]],"layout":{"text-field":"{name:nonlatin}","text-font":["Noto Sans Regular"],"text-max-width":10,"text-size":{"stops":[[3,14],[8,20]]},"symbol-sort-key":10},"paint":{"text-color":"rgba(135, 135, 135, 1)","text-halo-blur":0,"text-halo-color":"rgba(47, 47, 47, 0.75)","text-halo-width":2}},{"id":"place_label_state_tw","type":"symbol","source":"openmaptiles","source-layer":"place","minzoom":3,"maxzoom":16,"filter":["all",["==","$type","Point"],["==","class","country"],["any",["==","iso_a2","TW"],["==","wikidata","Q865"],["==","name:en","Taiwan"],["==","name","Taiwan"]]],"layout":{"text-field":"台湾省","text-font":["Noto Sans Regular"],"text-max-width":10,"text-size":{"stops":[[3,14],[8,20]]},"symbol-sort-key":10},"paint":{"text-color":"rgba(135, 135, 135, 1)","text-halo-blur":0,"text-halo-color":"rgba(47, 47, 47, 0.75)","text-halo-width":2}},{"id":"place_label_city","type":"symbol","source":"openmaptiles","source-layer":"place","minzoom":5,"maxzoom":16,"filter":["all",["==","$type","Point"],["==","class","city"]],"layout":{"text-field":"{name:nonlatin}","text-font":["Noto Sans Regular"],"text-max-width":10,"text-size":{"stops":[[6,12],[10,16]]},"symbol-sort-key":1},"paint":{"text-color":"rgba(135, 135, 135, 1)","text-halo-blur":0,"text-halo-color":"rgba(47, 47, 47, 0.75)","text-halo-width":2}},{"id":"country_label-other","type":"symbol","source":"openmaptiles","source-layer":"place","maxzoom":12,"filter":["all",["==","$type","Point"],["==","class","country"],["!has","iso_a2"]],"layout":{"text-field":"{name:latin}","text-font":["Noto Sans Regular"],"text-max-width":10,"text-size":{"stops":[[3,12],[8,22]]},"visibility":"visible"},"paint":{"text-color":"hsl(0, 0%, 13%)","text-halo-blur":0,"text-halo-color":"rgba(255,255,255,0.75)","text-halo-width":2}},{"id":"country_label","type":"symbol","source":"openmaptiles","source-layer":"place","maxzoom":12,"filter":["all",["==","$type","Point"],["==","class","country"],["has","iso_a2"],["!=","iso_a2","TW"]],"layout":{"text-field":"{name:latin}","text-font":["Noto Sans Bold"],"text-max-width":10,"text-size":{"stops":[[3,15],[8,22]]},"visibility":"visible"},"paint":{"text-color":"rgba(133, 133, 133, 1)","text-halo-blur":0,"text-halo-color":"rgba(65, 65, 65, 0.75)","text-halo-width":2}}]');
const id = "basic";
const owner = "ChronoFrame";
const ChronoFrameDarkStyle = {
  version,
  name,
  metadata,
  center,
  zoom,
  projection,
  sources,
  sprite,
  glyphs,
  layers,
  id,
  owner
};
const useColorMode = () => {
  return useState("color-mode").value;
};
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "Provider",
  __ssrInlineRender: true,
  props: {
    class: { default: void 0 },
    mapId: { default: void 0 },
    center: { default: void 0 },
    zoom: { default: 2 },
    interactive: { type: Boolean, default: true },
    attributionControl: { type: [Boolean, Object], default: false },
    language: { default: void 0 }
  },
  emits: ["load", "zoom"],
  setup(__props, { emit: __emit }) {
    const colorMode = useColorMode();
    const mapConfig = computed(() => {
      const config = getSetting("map");
      return typeof config === "object" && config ? config : {};
    });
    const provider = computed(() => mapConfig.value.provider || "maplibre");
    computed(() => {
      if (provider.value === "mapbox") {
        return mapConfig.value["mapbox.style"] || `mapbox://styles/mapbox/standard`;
      } else {
        const styleConfig = colorMode.value === "dark" ? ChronoFrameDarkStyle : ChronoFrameLightStyle;
        return mapConfig.value["maplibre.style"] || {
          ...styleConfig,
          sources: {
            openmaptiles: {
              ...styleConfig.sources?.openmaptiles,
              url: `https://api.maptiler.com/tiles/v3-openmaptiles/tiles.json?key=${mapConfig.value["maplibre.token"]}`
            }
          },
          glyphs: `https://api.maptiler.com/fonts/{fontstack}/{range}.pbf?key=${mapConfig.value["maplibre.token"]}`
        };
      }
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_ClientOnly = __nuxt_component_0$6;
      _push(`<div${ssrRenderAttrs(mergeProps({
        class: unref(twMerge)("w-full h-full", _ctx.$props.class)
      }, _attrs))}>`);
      _push(ssrRenderComponent(_component_ClientOnly, null, {}, _parent));
      _push(`</div>`);
    };
  }
});
const _sfc_setup$f = _sfc_main$f.setup;
_sfc_main$f.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/map/Provider.vue");
  return _sfc_setup$f ? _sfc_setup$f(props, ctx) : void 0;
};
const __nuxt_component_0 = Object.assign(_sfc_main$f, { __name: "MapProvider" });
const MAPID = "minimap-info-panel";
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "MiniMap",
  __ssrInlineRender: true,
  props: {
    photo: {},
    latitude: {},
    longitude: {}
  },
  setup(__props) {
    const props = __props;
    const config = /* @__PURE__ */ useRuntimeConfig();
    const loaded = ref(false);
    const isAnimating = ref(false);
    const mapInstance = ref(null);
    let animationTimer = null;
    const onMapLoad = (map) => {
      mapInstance.value = map;
      map.setCenter([props.longitude, props.latitude]);
      setTimeout(() => {
        loaded.value = true;
      }, 100);
    };
    const moveMapTo = (newLat, newLng) => {
      const DURATION = 1e3;
      if (mapInstance.value && loaded.value) {
        if (animationTimer) {
          clearTimeout(animationTimer);
          animationTimer = null;
        }
        isAnimating.value = true;
        mapInstance.value.flyTo({
          duration: DURATION,
          center: [newLng, newLat],
          zoom: 12,
          essential: true
        });
        animationTimer = setTimeout(() => {
          isAnimating.value = false;
          animationTimer = null;
        }, DURATION);
      }
    };
    watch([() => props.latitude, () => props.longitude], ([newLat, newLng]) => {
      moveMapTo(newLat, newLng);
      const map = mapInstance.value;
      if (map && isMapboxMap(map, config.public.map.provider)) {
        const photoDate = new Date(props.photo.dateTaken || 0);
        const hours = photoDate.getHours();
        if (hours >= 5 && hours < 7) {
          map.setConfigProperty("basemap", "lightPreset", "dawn");
        } else if (hours >= 7 && hours < 17) {
          map.setConfigProperty("basemap", "lightPreset", "day");
        } else if (hours >= 17 && hours < 21) {
          map.setConfigProperty("basemap", "lightPreset", "dusk");
        } else {
          map.setConfigProperty("basemap", "lightPreset", "night");
        }
      }
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_MapProvider = __nuxt_component_0;
      const _component_AnimatePresence = _sfc_main$n;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "relative w-full h-44 overflow-hidden rounded-lg border border-white/10 dark:border-white/10" }, _attrs))}>`);
      _push(ssrRenderComponent(_component_MapProvider, {
        class: "w-full h-full relative overflow-hidden",
        "map-id": MAPID,
        zoom: 12,
        interactive: false,
        language: _ctx.$i18n.locale,
        onLoad: onMapLoad
      }, {
        default: withCtx((_2, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent(_component_AnimatePresence, null, {
              default: withCtx((_22, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  if (!unref(isAnimating)) {
                    _push3(ssrRenderComponent(unref(motion).div, {
                      initial: { scale: 0, opacity: 0 },
                      animate: { scale: 1, opacity: 1 },
                      exit: { scale: 0.5, opacity: 0 },
                      class: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2"
                    }, {
                      default: withCtx((_3, _push4, _parent4, _scopeId3) => {
                        if (_push4) {
                          _push4(`<div class="relative"${_scopeId3}><div class="absolute top-1/2 left-1/2 h-3 w-3 -translate-x-1/2 -translate-y-1/2 animate-ping rounded-full bg-primary/70"${_scopeId3}></div><div class="relative h-2 w-2 rounded-full bg-primary ring-2 ring-white/80"${_scopeId3}></div></div>`);
                        } else {
                          return [
                            createVNode("div", { class: "relative" }, [
                              createVNode("div", { class: "absolute top-1/2 left-1/2 h-3 w-3 -translate-x-1/2 -translate-y-1/2 animate-ping rounded-full bg-primary/70" }),
                              createVNode("div", { class: "relative h-2 w-2 rounded-full bg-primary ring-2 ring-white/80" })
                            ])
                          ];
                        }
                      }),
                      _: 1
                    }, _parent3, _scopeId2));
                  } else {
                    _push3(`<!---->`);
                  }
                } else {
                  return [
                    !unref(isAnimating) ? (openBlock(), createBlock(unref(motion).div, {
                      key: 0,
                      initial: { scale: 0, opacity: 0 },
                      animate: { scale: 1, opacity: 1 },
                      exit: { scale: 0.5, opacity: 0 },
                      class: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2"
                    }, {
                      default: withCtx(() => [
                        createVNode("div", { class: "relative" }, [
                          createVNode("div", { class: "absolute top-1/2 left-1/2 h-3 w-3 -translate-x-1/2 -translate-y-1/2 animate-ping rounded-full bg-primary/70" }),
                          createVNode("div", { class: "relative h-2 w-2 rounded-full bg-primary ring-2 ring-white/80" })
                        ])
                      ]),
                      _: 1
                    })) : createCommentVNode("", true)
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
            if (!unref(loaded)) {
              _push2(`<div class="absolute inset-0 bg-default/80 flex items-center justify-center backdrop-blur-sm"${_scopeId}><p class="text-xs font-medium text-white/60"${_scopeId}>${ssrInterpolate(_ctx.$t("minimap.loading"))}</p></div>`);
            } else {
              _push2(`<!---->`);
            }
          } else {
            return [
              createVNode(_component_AnimatePresence, null, {
                default: withCtx(() => [
                  !unref(isAnimating) ? (openBlock(), createBlock(unref(motion).div, {
                    key: 0,
                    initial: { scale: 0, opacity: 0 },
                    animate: { scale: 1, opacity: 1 },
                    exit: { scale: 0.5, opacity: 0 },
                    class: "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2"
                  }, {
                    default: withCtx(() => [
                      createVNode("div", { class: "relative" }, [
                        createVNode("div", { class: "absolute top-1/2 left-1/2 h-3 w-3 -translate-x-1/2 -translate-y-1/2 animate-ping rounded-full bg-primary/70" }),
                        createVNode("div", { class: "relative h-2 w-2 rounded-full bg-primary ring-2 ring-white/80" })
                      ])
                    ]),
                    _: 1
                  })) : createCommentVNode("", true)
                ]),
                _: 1
              }),
              !unref(loaded) ? (openBlock(), createBlock("div", {
                key: 0,
                class: "absolute inset-0 bg-default/80 flex items-center justify-center backdrop-blur-sm"
              }, [
                createVNode("p", { class: "text-xs font-medium text-white/60" }, toDisplayString$1(_ctx.$t("minimap.loading")), 1)
              ])) : createCommentVNode("", true)
            ];
          }
        }),
        _: 1
      }, _parent));
      _push(`</div>`);
    };
  }
});
const _sfc_setup$e = _sfc_main$e.setup;
_sfc_main$e.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/photo/MiniMap.vue");
  return _sfc_setup$e ? _sfc_setup$e(props, ctx) : void 0;
};
const __nuxt_component_1$1 = Object.assign(_sfc_main$e, { __name: "PhotoMiniMap" });
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "KVRenderer",
  __ssrInlineRender: true,
  props: {
    data: {}
  },
  setup(__props) {
    return (_ctx, _push, _parent, _attrs) => {
      const _component_Icon = __nuxt_component_0$4;
      _push(`<!--[-->`);
      ssrRenderList(__props.data, (section, index2) => {
        _push(`<!--[-->`);
        if (section.items.some((item) => item?.value)) {
          _push(`<div class="space-y-3"><h4 class="text-sm font-medium text-white uppercase tracking-wide">${ssrInterpolate(section.title)}</h4><div class="space-y-2"><!--[-->`);
          ssrRenderList(section.items.filter(Boolean), (item, itemIdx) => {
            _push(`<div class="flex items-start gap-1 text-xs">`);
            if (item.icon === "placeholder") {
              _push(`<div class="size-4 -mt-[1px]"></div>`);
            } else if (item.icon) {
              _push(ssrRenderComponent(_component_Icon, {
                name: item.icon,
                class: "size-4 -mt-[1px] text-white/80 flex-shrink-0"
              }, null, _parent));
            } else {
              _push(`<!---->`);
            }
            _push(`<div class="flex-1 min-w-0 flex gap-6 items-start justify-between font-medium"><div class="text-white/80 text-nowrap">${ssrInterpolate(item.label)}</div><div class="text-white text-wrap tracking-tight wrap-anywhere text-end whitespace-pre-line">${ssrInterpolate(item.value)}</div></div></div>`);
          });
          _push(`<!--]--></div></div>`);
        } else {
          _push(`<!---->`);
        }
        _push(`<!--]-->`);
      });
      _push(`<!--]-->`);
    };
  }
});
const _sfc_setup$d = _sfc_main$d.setup;
_sfc_main$d.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/photo/KVRenderer.vue");
  return _sfc_setup$d ? _sfc_setup$d(props, ctx) : void 0;
};
const __nuxt_component_2 = Object.assign(_sfc_main$d, { __name: "PhotoKVRenderer" });
const _sfc_main$c = {
  name: "TablerStar"
};
function _sfc_ssrRender$2(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<svg${ssrRenderAttrs(mergeProps({
    xmlns: "http://www.w3.org/2000/svg",
    width: "1em",
    height: "1em",
    viewBox: "0 0 24 24"
  }, _attrs))}><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m12 17.75l-6.172 3.245l1.179-6.873l-5-4.867l6.9-1l3.086-6.253l3.086 6.253l6.9 1l-5 4.867l1.179 6.873z"></path></svg>`);
}
const _sfc_setup$c = _sfc_main$c.setup;
_sfc_main$c.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/icon/TablerStar.vue");
  return _sfc_setup$c ? _sfc_setup$c(props, ctx) : void 0;
};
const TablerStar = /* @__PURE__ */ Object.assign(_export_sfc(_sfc_main$c, [["ssrRender", _sfc_ssrRender$2]]), { __name: "IconTablerStar" });
const _sfc_main$b = {
  name: "TablerStarFilled"
};
function _sfc_ssrRender$1(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<svg${ssrRenderAttrs(mergeProps({
    xmlns: "http://www.w3.org/2000/svg",
    width: "1em",
    height: "1em",
    viewBox: "0 0 24 24"
  }, _attrs))}><path fill="currentColor" d="m8.243 7.34l-6.38.925l-.113.023a1 1 0 0 0-.44 1.684l4.622 4.499l-1.09 6.355l-.013.11a1 1 0 0 0 1.464.944l5.706-3l5.693 3l.1.046a1 1 0 0 0 1.352-1.1l-1.091-6.355l4.624-4.5l.078-.085a1 1 0 0 0-.633-1.62l-6.38-.926l-2.852-5.78a1 1 0 0 0-1.794 0z"></path></svg>`);
}
const _sfc_setup$b = _sfc_main$b.setup;
_sfc_main$b.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/icon/TablerStarFilled.vue");
  return _sfc_setup$b ? _sfc_setup$b(props, ctx) : void 0;
};
const TablerStarFilled = /* @__PURE__ */ Object.assign(_export_sfc(_sfc_main$b, [["ssrRender", _sfc_ssrRender$1]]), { __name: "IconTablerStarFilled" });
const _sfc_main$a = {
  name: "TablerStarHalfFilled"
};
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<svg${ssrRenderAttrs(mergeProps({
    xmlns: "http://www.w3.org/2000/svg",
    width: "1em",
    height: "1em",
    viewBox: "0 0 24 24"
  }, _attrs))}><path fill="currentColor" d="M12 1a1 1 0 0 1 .823.443l.067.116l2.852 5.781l6.38.925c.741.108 1.08.94.703 1.526l-.07.095l-.078.086l-4.624 4.499l1.09 6.355a1 1 0 0 1-1.249 1.135l-.101-.035l-.101-.046l-5.693-3l-5.706 3q-.158.082-.32.106l-.106.01a1.003 1.003 0 0 1-1.038-1.06l.013-.11l1.09-6.355l-4.623-4.5a1 1 0 0 1 .328-1.647l.113-.036l.114-.023l6.379-.925l2.853-5.78A.97.97 0 0 1 12 1m0 3.274V16.75a1 1 0 0 1 .239.029l.115.036l.112.05l4.363 2.299l-.836-4.873a1 1 0 0 1 .136-.696l.07-.099l.082-.09l3.546-3.453l-4.891-.708a1 1 0 0 1-.62-.344l-.073-.097l-.06-.106z"></path></svg>`);
}
const _sfc_setup$a = _sfc_main$a.setup;
_sfc_main$a.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/icon/TablerStarHalfFilled.vue");
  return _sfc_setup$a ? _sfc_setup$a(props, ctx) : void 0;
};
const TablerStarHalfFilled = /* @__PURE__ */ Object.assign(_export_sfc(_sfc_main$a, [["ssrRender", _sfc_ssrRender]]), { __name: "IconTablerStarHalfFilled" });
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  __name: "Rating",
  __ssrInlineRender: true,
  props: {
    modelValue: {},
    allowHalf: { type: Boolean, default: true },
    allowClear: { type: Boolean, default: true },
    size: { default: "md" },
    readonly: { type: Boolean, default: false }
  },
  emits: ["update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const sizeClasses = {
      xs: "text-sm",
      sm: "text-base",
      md: "text-lg",
      lg: "text-xl",
      xl: "text-2xl"
    };
    const getStarType = (index2) => {
      const value = props.modelValue;
      if (value >= index2 + 1) {
        return "filled";
      } else if (props.allowHalf && value >= index2 + 0.5) {
        return "half";
      } else {
        return "empty";
      }
    };
    return (_ctx, _push, _parent, _attrs) => {
      _push(`<div${ssrRenderAttrs(mergeProps({
        class: ["rating flex items-center gap-1", [sizeClasses[props.size], { "cursor-pointer": !props.readonly }]]
      }, _attrs))} data-v-ff746135>`);
      if (!props.allowHalf) {
        _push(`<!--[-->`);
        ssrRenderList(5, (i) => {
          _push(`<div class="${ssrRenderClass([{ readonly: props.readonly }, "star relative"])}" data-v-ff746135>`);
          if (getStarType(i - 1) === "empty") {
            _push(ssrRenderComponent(TablerStar, { class: "text-neutral-500 dark:text-neutral-300" }, null, _parent));
          } else if (getStarType(i - 1) === "filled") {
            _push(ssrRenderComponent(TablerStarFilled, { class: "text-yellow-400" }, null, _parent));
          } else {
            _push(ssrRenderComponent(TablerStarHalfFilled, { class: "text-yellow-400" }, null, _parent));
          }
          _push(`</div>`);
        });
        _push(`<!--]-->`);
      } else {
        _push(`<!--[-->`);
        ssrRenderList(5, (i) => {
          _push(`<div class="${ssrRenderClass([{ readonly: props.readonly }, "star relative"])}" data-v-ff746135>`);
          if (getStarType(i - 1) === "empty") {
            _push(ssrRenderComponent(TablerStar, { class: "text-neutral-500 dark:text-neutral-300" }, null, _parent));
          } else if (getStarType(i - 1) === "filled") {
            _push(ssrRenderComponent(TablerStarFilled, { class: "text-yellow-400" }, null, _parent));
          } else {
            _push(ssrRenderComponent(TablerStarHalfFilled, { class: "text-yellow-400" }, null, _parent));
          }
          _push(`<div class="absolute inset-0 flex" data-v-ff746135><div class="w-1/2" data-v-ff746135></div><div class="w-1/2" data-v-ff746135></div></div></div>`);
        });
        _push(`<!--]-->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$9 = _sfc_main$9.setup;
_sfc_main$9.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/ui/Rating.vue");
  return _sfc_setup$9 ? _sfc_setup$9(props, ctx) : void 0;
};
const __nuxt_component_1 = /* @__PURE__ */ Object.assign(_export_sfc(_sfc_main$9, [["__scopeId", "data-v-ff746135"]]), { __name: "Rating" });
const theme = {
  "slots": {
    "base": "font-medium inline-flex items-center",
    "label": "truncate",
    "leadingIcon": "shrink-0",
    "leadingAvatar": "shrink-0",
    "leadingAvatarSize": "",
    "trailingIcon": "shrink-0"
  },
  "variants": {
    "fieldGroup": {
      "horizontal": "not-only:first:rounded-e-none not-only:last:rounded-s-none not-last:not-first:rounded-none focus-visible:z-[1]",
      "vertical": "not-only:first:rounded-b-none not-only:last:rounded-t-none not-last:not-first:rounded-none focus-visible:z-[1]"
    },
    "color": {
      "primary": "",
      "secondary": "",
      "success": "",
      "info": "",
      "warning": "",
      "error": "",
      "neutral": ""
    },
    "variant": {
      "solid": "",
      "outline": "",
      "soft": "",
      "subtle": ""
    },
    "size": {
      "xs": {
        "base": "text-[8px]/3 px-1 py-0.5 gap-1 rounded-sm",
        "leadingIcon": "size-3",
        "leadingAvatarSize": "3xs",
        "trailingIcon": "size-3"
      },
      "sm": {
        "base": "text-[10px]/3 px-1.5 py-1 gap-1 rounded-sm",
        "leadingIcon": "size-3",
        "leadingAvatarSize": "3xs",
        "trailingIcon": "size-3"
      },
      "md": {
        "base": "text-xs px-2 py-1 gap-1 rounded-md",
        "leadingIcon": "size-4",
        "leadingAvatarSize": "3xs",
        "trailingIcon": "size-4"
      },
      "lg": {
        "base": "text-sm px-2 py-1 gap-1.5 rounded-md",
        "leadingIcon": "size-5",
        "leadingAvatarSize": "2xs",
        "trailingIcon": "size-5"
      },
      "xl": {
        "base": "text-base px-2.5 py-1 gap-1.5 rounded-md",
        "leadingIcon": "size-6",
        "leadingAvatarSize": "2xs",
        "trailingIcon": "size-6"
      }
    },
    "square": {
      "true": ""
    }
  },
  "compoundVariants": [
    {
      "color": "primary",
      "variant": "solid",
      "class": "bg-primary text-inverted"
    },
    {
      "color": "secondary",
      "variant": "solid",
      "class": "bg-secondary text-inverted"
    },
    {
      "color": "success",
      "variant": "solid",
      "class": "bg-success text-inverted"
    },
    {
      "color": "info",
      "variant": "solid",
      "class": "bg-info text-inverted"
    },
    {
      "color": "warning",
      "variant": "solid",
      "class": "bg-warning text-inverted"
    },
    {
      "color": "error",
      "variant": "solid",
      "class": "bg-error text-inverted"
    },
    {
      "color": "primary",
      "variant": "outline",
      "class": "text-primary ring ring-inset ring-primary/50"
    },
    {
      "color": "secondary",
      "variant": "outline",
      "class": "text-secondary ring ring-inset ring-secondary/50"
    },
    {
      "color": "success",
      "variant": "outline",
      "class": "text-success ring ring-inset ring-success/50"
    },
    {
      "color": "info",
      "variant": "outline",
      "class": "text-info ring ring-inset ring-info/50"
    },
    {
      "color": "warning",
      "variant": "outline",
      "class": "text-warning ring ring-inset ring-warning/50"
    },
    {
      "color": "error",
      "variant": "outline",
      "class": "text-error ring ring-inset ring-error/50"
    },
    {
      "color": "primary",
      "variant": "soft",
      "class": "bg-primary/10 text-primary"
    },
    {
      "color": "secondary",
      "variant": "soft",
      "class": "bg-secondary/10 text-secondary"
    },
    {
      "color": "success",
      "variant": "soft",
      "class": "bg-success/10 text-success"
    },
    {
      "color": "info",
      "variant": "soft",
      "class": "bg-info/10 text-info"
    },
    {
      "color": "warning",
      "variant": "soft",
      "class": "bg-warning/10 text-warning"
    },
    {
      "color": "error",
      "variant": "soft",
      "class": "bg-error/10 text-error"
    },
    {
      "color": "primary",
      "variant": "subtle",
      "class": "bg-primary/10 text-primary ring ring-inset ring-primary/25"
    },
    {
      "color": "secondary",
      "variant": "subtle",
      "class": "bg-secondary/10 text-secondary ring ring-inset ring-secondary/25"
    },
    {
      "color": "success",
      "variant": "subtle",
      "class": "bg-success/10 text-success ring ring-inset ring-success/25"
    },
    {
      "color": "info",
      "variant": "subtle",
      "class": "bg-info/10 text-info ring ring-inset ring-info/25"
    },
    {
      "color": "warning",
      "variant": "subtle",
      "class": "bg-warning/10 text-warning ring ring-inset ring-warning/25"
    },
    {
      "color": "error",
      "variant": "subtle",
      "class": "bg-error/10 text-error ring ring-inset ring-error/25"
    },
    {
      "color": "neutral",
      "variant": "solid",
      "class": "text-inverted bg-inverted"
    },
    {
      "color": "neutral",
      "variant": "outline",
      "class": "ring ring-inset ring-accented text-default bg-default"
    },
    {
      "color": "neutral",
      "variant": "soft",
      "class": "text-default bg-elevated"
    },
    {
      "color": "neutral",
      "variant": "subtle",
      "class": "ring ring-inset ring-accented text-default bg-elevated"
    },
    {
      "size": "xs",
      "square": true,
      "class": "p-0.5"
    },
    {
      "size": "sm",
      "square": true,
      "class": "p-1"
    },
    {
      "size": "md",
      "square": true,
      "class": "p-1"
    },
    {
      "size": "lg",
      "square": true,
      "class": "p-1"
    },
    {
      "size": "xl",
      "square": true,
      "class": "p-1"
    }
  ],
  "defaultVariants": {
    "color": "primary",
    "variant": "solid",
    "size": "md"
  }
};
const _sfc_main$8 = {
  __name: "UBadge",
  __ssrInlineRender: true,
  props: {
    as: { type: null, required: false, default: "span" },
    label: { type: [String, Number], required: false },
    color: { type: null, required: false },
    variant: { type: null, required: false },
    size: { type: null, required: false },
    square: { type: Boolean, required: false },
    class: { type: null, required: false },
    ui: { type: null, required: false },
    icon: { type: null, required: false },
    avatar: { type: Object, required: false },
    leading: { type: Boolean, required: false },
    leadingIcon: { type: null, required: false },
    trailing: { type: Boolean, required: false },
    trailingIcon: { type: null, required: false }
  },
  setup(__props) {
    const props = __props;
    const slots = useSlots();
    const appConfig2 = useAppConfig();
    const { orientation, size: fieldGroupSize } = useFieldGroup(props);
    const { isLeading, isTrailing, leadingIconName, trailingIconName } = useComponentIcons(props);
    const ui = computed(() => tv({ extend: tv(theme), ...appConfig2.ui?.badge || {} })({
      color: props.color,
      variant: props.variant,
      size: fieldGroupSize.value || props.size,
      square: props.square || !slots.default && !props.label,
      fieldGroup: orientation.value
    }));
    return (_ctx, _push, _parent, _attrs) => {
      _push(ssrRenderComponent(unref(Primitive), mergeProps({
        as: __props.as,
        "data-slot": "base",
        class: ui.value.base({ class: [props.ui?.base, props.class] })
      }, _attrs), {
        default: withCtx((_2, _push2, _parent2, _scopeId) => {
          if (_push2) {
            ssrRenderSlot(_ctx.$slots, "leading", { ui: ui.value }, () => {
              if (unref(isLeading) && unref(leadingIconName)) {
                _push2(ssrRenderComponent(_sfc_main$B, {
                  name: unref(leadingIconName),
                  "data-slot": "leadingIcon",
                  class: ui.value.leadingIcon({ class: props.ui?.leadingIcon })
                }, null, _parent2, _scopeId));
              } else if (!!__props.avatar) {
                _push2(ssrRenderComponent(_sfc_main$y, mergeProps({
                  size: props.ui?.leadingAvatarSize || ui.value.leadingAvatarSize()
                }, __props.avatar, {
                  "data-slot": "leadingAvatar",
                  class: ui.value.leadingAvatar({ class: props.ui?.leadingAvatar })
                }), null, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
            }, _push2, _parent2, _scopeId);
            ssrRenderSlot(_ctx.$slots, "default", { ui: ui.value }, () => {
              if (__props.label !== void 0 && __props.label !== null) {
                _push2(`<span data-slot="label" class="${ssrRenderClass(ui.value.label({ class: props.ui?.label }))}"${_scopeId}>${ssrInterpolate(__props.label)}</span>`);
              } else {
                _push2(`<!---->`);
              }
            }, _push2, _parent2, _scopeId);
            ssrRenderSlot(_ctx.$slots, "trailing", { ui: ui.value }, () => {
              if (unref(isTrailing) && unref(trailingIconName)) {
                _push2(ssrRenderComponent(_sfc_main$B, {
                  name: unref(trailingIconName),
                  "data-slot": "trailingIcon",
                  class: ui.value.trailingIcon({ class: props.ui?.trailingIcon })
                }, null, _parent2, _scopeId));
              } else {
                _push2(`<!---->`);
              }
            }, _push2, _parent2, _scopeId);
          } else {
            return [
              renderSlot(_ctx.$slots, "leading", { ui: ui.value }, () => [
                unref(isLeading) && unref(leadingIconName) ? (openBlock(), createBlock(_sfc_main$B, {
                  key: 0,
                  name: unref(leadingIconName),
                  "data-slot": "leadingIcon",
                  class: ui.value.leadingIcon({ class: props.ui?.leadingIcon })
                }, null, 8, ["name", "class"])) : !!__props.avatar ? (openBlock(), createBlock(_sfc_main$y, mergeProps({
                  key: 1,
                  size: props.ui?.leadingAvatarSize || ui.value.leadingAvatarSize()
                }, __props.avatar, {
                  "data-slot": "leadingAvatar",
                  class: ui.value.leadingAvatar({ class: props.ui?.leadingAvatar })
                }), null, 16, ["size", "class"])) : createCommentVNode("", true)
              ]),
              renderSlot(_ctx.$slots, "default", { ui: ui.value }, () => [
                __props.label !== void 0 && __props.label !== null ? (openBlock(), createBlock("span", {
                  key: 0,
                  "data-slot": "label",
                  class: ui.value.label({ class: props.ui?.label })
                }, toDisplayString$1(__props.label), 3)) : createCommentVNode("", true)
              ]),
              renderSlot(_ctx.$slots, "trailing", { ui: ui.value }, () => [
                unref(isTrailing) && unref(trailingIconName) ? (openBlock(), createBlock(_sfc_main$B, {
                  key: 0,
                  name: unref(trailingIconName),
                  "data-slot": "trailingIcon",
                  class: ui.value.trailingIcon({ class: props.ui?.trailingIcon })
                }, null, 8, ["name", "class"])) : createCommentVNode("", true)
              ])
            ];
          }
        }),
        _: 3
      }, _parent));
    };
  }
};
const _sfc_setup$8 = _sfc_main$8.setup;
_sfc_main$8.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/@nuxt+ui@4.3.0_ce70e36b2b2e96ffad445540e21eec42/node_modules/@nuxt/ui/dist/runtime/components/Badge.vue");
  return _sfc_setup$8 ? _sfc_setup$8(props, ctx) : void 0;
};
const zeroArray = (length) => new Array(length).fill(0);
const compressHistogramBin = (data) => {
  const compressed = zeroArray(128);
  for (let i = 0; i < data.length; i++) {
    compressed[Math.floor(i / 2)] += data[i] ?? 0;
  }
  return compressed;
};
const calculateHistogramCompressed = (imageData) => {
  const histogram = {
    red: zeroArray(256),
    green: zeroArray(256),
    blue: zeroArray(256),
    gray: zeroArray(256)
  };
  const { data } = imageData;
  for (let i = 0; i < data.length; i += 4) {
    const r = data[i];
    const g2 = data[i + 1];
    const b = data[i + 2];
    const gray = Math.round(0.299 * r + 0.587 * g2 + 0.114 * b);
    histogram.red[r]++;
    histogram.green[g2]++;
    histogram.blue[b]++;
    histogram.gray[gray]++;
  }
  return {
    red: compressHistogramBin(histogram.red),
    green: compressHistogramBin(histogram.green),
    blue: compressHistogramBin(histogram.blue),
    gray: compressHistogramBin(histogram.gray)
  };
};
const easeOutCubic = (t) => {
  return 1 - Math.pow(1 - t, 3);
};
const canvasAnimationStates = /* @__PURE__ */ new WeakMap();
const drawHistogramToCanvas = (canvas, histogram, options = {
  padding: 0,
  colors: {
    background: "rgba(36, 36, 38, .65)",
    border: "rgba(255, 255, 255, .1)",
    grid: "rgba(255, 255, 255, .3)",
    red: "rgba(255, 98, 89, 1)",
    green: "rgba(46, 209, 87, 1)",
    blue: "rgba(59, 154, 255, 1)",
    gray: "rgba(255, 255, 255, 1)"
  }
}) => {
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    console.error("Failed to get canvas context");
    return;
  }
  let animationState = canvasAnimationStates.get(canvas);
  if (!animationState) {
    animationState = { animationId: null, isAnimating: false };
    canvasAnimationStates.set(canvas, animationState);
  }
  if (animationState.isAnimating && animationState.animationId) {
    clearTimeout(animationState.animationId);
  }
  const canvasRect = canvas.getBoundingClientRect();
  const { width, height } = canvasRect;
  const dpr = (void 0).devicePixelRatio || 1;
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  ctx.scale(dpr, dpr);
  canvas.style.width = `${width}px`;
  canvas.style.height = `${height}px`;
  const maxCount = Math.max(
    ...histogram.red,
    ...histogram.green,
    ...histogram.blue,
    ...histogram.gray
  );
  if (maxCount === 0) return;
  const logicalWidth = width;
  const logicalHeight = height;
  const chartWidth = logicalWidth - options.padding * 2;
  const chartHeight = logicalHeight - options.padding * 2;
  const drawBars = (data, color2, opacity = 1, progress2 = 1) => {
    const barWidth = chartWidth / data.length;
    for (let i = 0; i < data.length; i++) {
      const fullBarHeight = (data[i] ?? 0) / maxCount * chartHeight;
      const barHeight = fullBarHeight * progress2;
      const gradient = ctx.createLinearGradient(
        0,
        options.padding + chartHeight - barHeight,
        0,
        options.padding + chartHeight
      );
      gradient.addColorStop(0, color2.replace(/[\d.]+\)$/, `${opacity})`));
      gradient.addColorStop(1, color2.replace(/[\d.]+\)$/, `${opacity * 0.3})`));
      ctx.fillStyle = gradient;
      ctx.globalAlpha = opacity;
      const x = options.padding + i * barWidth;
      const y = options.padding + chartHeight - barHeight;
      const w = barWidth * 0.8;
      const h2 = barHeight;
      const radius = Math.min(w / 2, 2);
      ctx.beginPath();
      ctx.roundRect(x, y, w, h2, [radius, radius, 0, 0]);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  };
  const renderFrame = (progress2) => {
    ctx.clearRect(0, 0, logicalWidth, logicalHeight);
    ctx.fillStyle = options.colors.background;
    ctx.fillRect(0, 0, logicalWidth, logicalHeight);
    ctx.lineWidth = 0.2;
    ctx.strokeStyle = options.colors.grid;
    for (let i = 1; i <= 3; i++) {
      ctx.beginPath();
      ctx.moveTo(options.padding, options.padding + chartHeight / 4 * i);
      ctx.lineTo(
        logicalWidth - options.padding,
        options.padding + chartHeight / 4 * i
      );
      ctx.stroke();
    }
    drawBars(histogram.gray, options.colors.gray, 0.4, progress2);
    ctx.globalCompositeOperation = "screen";
    drawBars(histogram.red, options.colors.red, 0.8, progress2);
    drawBars(histogram.green, options.colors.green, 0.8, progress2);
    drawBars(histogram.blue, options.colors.blue, 0.8, progress2);
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = options.colors.border;
    ctx.lineWidth = 1;
    ctx.strokeRect(
      options.padding - 0.5,
      options.padding - 0.5,
      chartWidth + 1,
      chartHeight + 1
    );
  };
  animationState.isAnimating = true;
  const startTime = Date.now();
  const duration2 = 600;
  const animate2 = () => {
    const elapsed = Date.now() - startTime;
    const rawProgress = Math.min(elapsed / duration2, 1);
    const easedProgress = easeOutCubic(rawProgress);
    renderFrame(easedProgress);
    if (rawProgress < 1) {
      animationState.animationId = (void 0).setTimeout(animate2, 16);
    } else {
      animationState.isAnimating = false;
      animationState.animationId = null;
    }
  };
  renderFrame(0);
  animate2();
};
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  __name: "Histogram",
  __ssrInlineRender: true,
  props: {
    thumbnailUrl: {},
    options: {},
    class: {}
  },
  setup(__props) {
    const props = __props;
    const canvasRef = useTemplateRef("canvasRef");
    const isLoading = ref(true);
    const isError = ref(false);
    const histogramData = ref(null);
    let currentImage = null;
    const cleanup = () => {
      if (currentImage) {
        currentImage.onload = null;
        currentImage.onerror = null;
        currentImage.src = "";
        currentImage = null;
      }
    };
    watchEffect(() => {
      isLoading.value = true;
      isError.value = false;
      histogramData.value = null;
      cleanup();
      const img = new Image();
      currentImage = img;
      img.crossOrigin = "anonymous";
      const url = new URL(props.thumbnailUrl, (void 0).location.origin);
      url.searchParams.set("_cors", Date.now().toString());
      img.src = url.toString();
      img.onload = () => {
        if (img !== currentImage) {
          return;
        }
        const canvas = (void 0).createElement("canvas");
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          isError.value = true;
          isLoading.value = false;
          return;
        }
        const scale2 = 360 / Math.max(img.width, img.height);
        const [w, h2] = [
          Math.floor(img.width * scale2),
          Math.floor(img.height * scale2)
        ];
        canvas.width = w;
        canvas.height = h2;
        ctx.drawImage(img, 0, 0, w, h2);
        try {
          const imageData = ctx.getImageData(0, 0, w, h2);
          histogramData.value = calculateHistogramCompressed(imageData);
        } catch (e) {
          isError.value = true;
          console.error("Failed to calculate histogram", e);
        } finally {
          isLoading.value = false;
          currentImage = null;
        }
      };
      img.onerror = () => {
        if (img !== currentImage) {
          return;
        }
        isError.value = true;
        isLoading.value = false;
        currentImage = null;
      };
    });
    watchEffect(() => {
      if (histogramData.value && canvasRef.value) {
        drawHistogramToCanvas(canvasRef.value, histogramData.value, props.options);
      }
    });
    return (_ctx, _push, _parent, _attrs) => {
      const _component_Icon = __nuxt_component_0$4;
      _push(`<div${ssrRenderAttrs(mergeProps({
        class: unref(twMerge)("relative w-full h-32 group overflow-hidden", _ctx.$props.class)
      }, _attrs))} data-v-f65ed064>`);
      if (unref(isLoading)) {
        _push(`<div class="absolute inset-0 bg-neutral-900/50 flex flex-col gap-2 items-center justify-center rounded-lg backdrop-blur-xl z-10 text-white" data-v-f65ed064>`);
        _push(ssrRenderComponent(_component_Icon, {
          name: "tabler:loader",
          class: "text-xl animate-spin"
        }, null, _parent));
        _push(`<span class="text-xs font-medium" data-v-f65ed064>Rendering</span></div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(isError)) {
        _push(`<div class="absolute inset-0 bg-neutral-900/50 flex flex-col gap-2 items-center justify-center rounded-lg backdrop-blur-xl z-10 text-white" data-v-f65ed064>`);
        _push(ssrRenderComponent(_component_Icon, {
          name: "tabler:alert-triangle",
          class: "text-xl"
        }, null, _parent));
        _push(`<span class="text-xs font-medium" data-v-f65ed064>直方图加载失败</span></div>`);
      } else {
        _push(`<!---->`);
      }
      if (unref(histogramData)) {
        _push(`<canvas class="w-full h-full rounded-lg backdrop-blur-xl" data-v-f65ed064></canvas>`);
      } else {
        _push(`<!---->`);
      }
      _push(`</div>`);
    };
  }
});
const _sfc_setup$7 = _sfc_main$7.setup;
_sfc_main$7.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/Histogram.vue");
  return _sfc_setup$7 ? _sfc_setup$7(props, ctx) : void 0;
};
const __nuxt_component_5 = /* @__PURE__ */ Object.assign(_export_sfc(_sfc_main$7, [["__scopeId", "data-v-f65ed064"]]), { __name: "Histogram" });
function formatCameraInfo(make, model) {
  if (!make && !model) return "";
  if (!make) return model || "";
  if (!model) return make;
  const brandMap = {
    "Canon": ["canon", "eos"],
    "Nikon": ["nikon"],
    "Sony": ["sony", "ilce", "dsc"],
    "Fujifilm": ["fujifilm", "fuji", "x-"],
    "Olympus": ["olympus", "om-", "e-"],
    "Panasonic": ["panasonic", "lumix", "dc-", "dmc-"],
    "Leica": ["leica"],
    "Pentax": ["pentax", "k-"],
    "Ricoh": ["ricoh", "gr"],
    "Hasselblad": ["hasselblad"],
    "Phase One": ["phase one"],
    "Mamiya": ["mamiya"],
    "Apple": ["apple"],
    "Samsung": ["samsung", "galaxy", "sm-"],
    "Google": ["pixel"],
    "Xiaomi": ["xiaomi", "mi ", "redmi"],
    "Huawei": ["huawei", "p30", "p40", "p50", "mate"],
    "OnePlus": ["oneplus"],
    "OPPO": ["oppo"],
    "Vivo": ["vivo"],
    "Realme": ["realme"],
    "Honor": ["honor"]
  };
  const makeNormalized = make.toLowerCase().trim();
  const modelNormalized = model.toLowerCase().trim();
  const brandKeywords = brandMap[make] || [makeNormalized];
  const modelContainsBrand = brandKeywords.some(
    (keyword) => modelNormalized.includes(keyword.toLowerCase())
  );
  if (modelContainsBrand) {
    return model;
  } else {
    return `${make} ${model}`;
  }
}
function formatLensInfo(lensMake, lensModel) {
  if (!lensMake && !lensModel) return "";
  if (!lensMake) return lensModel || "";
  if (!lensModel) return lensMake;
  const lensBrandMap = {
    "Canon": ["canon", "ef", "rf"],
    "Nikon": ["nikon", "nikkor"],
    "Sony": ["sony", "fe", "e "],
    "Sigma": ["sigma"],
    "Tamron": ["tamron"],
    "Tokina": ["tokina"],
    "Samyang": ["samyang"],
    "Zeiss": ["zeiss"],
    "Voigtländer": ["voigtlander", "voigtländer"],
    "Leica": ["leica"],
    "Panasonic": ["panasonic", "lumix"],
    "Olympus": ["olympus", "zuiko"],
    "Fujifilm": ["fujifilm", "fujinon", "xf", "xc"]
  };
  const lensMakeNormalized = lensMake.toLowerCase().trim();
  const lensModelNormalized = lensModel.toLowerCase().trim();
  const brandKeywords = lensBrandMap[lensMake] || [lensMakeNormalized];
  const modelContainsBrand = brandKeywords.some(
    (keyword) => lensModelNormalized.includes(keyword.toLowerCase())
  );
  if (modelContainsBrand) {
    return lensModel;
  } else {
    return `${lensMake} ${lensModel}`;
  }
}
function useDayjs() {
  return dayjs;
}
function toCamelCaseKey(label) {
  return label.replace(/[^a-zA-Z0-9 ]+/g, " ").trim().split(/\s+/).map((word, index2) => {
    const lower = word.toLowerCase();
    return index2 === 0 ? lower : lower.charAt(0).toUpperCase() + lower.slice(1);
  }).join("");
}
function translateExifValue(category, value, $t) {
  if (!value) return "";
  const stringValue = String(value);
  const camelCaseKey = toCamelCaseKey(stringValue);
  const translationKey = `exif.values.${category}.${camelCaseKey}`;
  return $t(translationKey);
}
function useExifLocalization() {
  const { $i18n } = useNuxtApp();
  const localizeExif = (category, value) => {
    return translateExifValue(category, value, $i18n.t);
  };
  return {
    localizeExif
  };
}
const formatBytes = (bytes) => {
  if (bytes === 0) return "0 B";
  const k2 = 1024;
  const sizes = ["B", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k2));
  return parseFloat((bytes / Math.pow(k2, i)).toFixed(2)) + " " + sizes[i];
};
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  __name: "InfoPanel",
  __ssrInlineRender: true,
  props: {
    currentPhoto: {},
    exifData: {},
    onClose: { type: Function }
  },
  setup(__props) {
    const { t: $t } = useI18n();
    const dayjs2 = useDayjs();
    const router = useRouter();
    const { localizeExif } = useExifLocalization();
    const props = __props;
    const { data: _albums } = useFetch(
      () => `/api/photos/${props.currentPhoto.id}/albums`,
      {
        watch: [() => props.currentPhoto.id]
      },
      "$g3KCOMe2wn"
    );
    const albums = computed(() => _albums.value || []);
    const formatExposureTime = (exposureTime) => {
      if (!exposureTime) return "";
      let seconds;
      if (typeof exposureTime === "string") {
        if (exposureTime.includes("/")) {
          const parts = exposureTime.split("/");
          if (parts.length === 2 && parts[0] && parts[1]) {
            const numerator = parseFloat(parts[0]);
            const denominator = parseFloat(parts[1]);
            if (!isNaN(numerator) && !isNaN(denominator) && denominator !== 0) {
              seconds = numerator / denominator;
            } else {
              return exposureTime;
            }
          } else {
            return exposureTime;
          }
        } else {
          seconds = parseFloat(exposureTime);
          if (isNaN(seconds)) {
            return exposureTime;
          }
        }
      } else {
        seconds = exposureTime;
      }
      if (seconds >= 1) {
        return `${seconds}s`;
      } else {
        const denominator = Math.round(1 / seconds);
        return `1/${denominator}`;
      }
    };
    const formatGPSCoordinatesMultiLine = (latitude, longitude) => {
      const latDirection = latitude >= 0 ? "N" : "S";
      const lngDirection = longitude >= 0 ? "E" : "W";
      const latDegrees = Math.abs(latitude);
      const lngDegrees = Math.abs(longitude);
      const latDeg = Math.floor(latDegrees);
      const latMin = Math.floor((latDegrees - latDeg) * 60);
      const latSec = ((latDegrees - latDeg) * 60 - latMin) * 60;
      const lngDeg = Math.floor(lngDegrees);
      const lngMin = Math.floor((lngDegrees - lngDeg) * 60);
      const lngSec = ((lngDegrees - lngDeg) * 60 - lngMin) * 60;
      return `${latDeg}°${latMin}'${latSec.toFixed(2)}"${latDirection}
${lngDeg}°${lngMin}'${lngSec.toFixed(2)}"${lngDirection}`;
    };
    const gpsCoordinates = computed(() => {
      if (props.currentPhoto.latitude && props.currentPhoto.longitude) {
        return {
          latitude: props.currentPhoto.latitude,
          longitude: props.currentPhoto.longitude
        };
      }
      if (!props.exifData) return null;
      const { GPSLatitude, GPSLongitude } = props.exifData;
      if (GPSLatitude && GPSLongitude) {
        return {
          latitude: parseFloat(`${GPSLatitude}`),
          longitude: parseFloat(`${GPSLongitude}`)
        };
      }
      return null;
    });
    const formatedExifData = computed(() => {
      const sections = {};
      sections.basicInfo = [
        {
          title: $t("exif.sections.basic"),
          items: [
            props.currentPhoto.storageKey ? {
              label: $t("exif.filename"),
              value: props.currentPhoto.storageKey.split("/").pop() || props.currentPhoto.storageKey,
              icon: "tabler:file"
            } : null,
            props.currentPhoto.fileSize ? {
              label: $t("exif.fileSize"),
              value: formatBytes(props.currentPhoto.fileSize),
              icon: "tabler:database"
            } : null,
            props.currentPhoto.width && props.currentPhoto.height ? {
              label: $t("exif.resolution"),
              value: `${props.currentPhoto.width} × ${props.currentPhoto.height}`,
              icon: "tabler:dimensions"
            } : null,
            props.currentPhoto.width && props.currentPhoto.height ? {
              label: $t("exif.pixels"),
              value: `${(props.currentPhoto.width * props.currentPhoto.height / 1e6).toFixed(2)} MP`,
              icon: "tabler:grid-dots"
            } : null,
            props.exifData?.DateTimeOriginal ? {
              label: $t("exif.dateTaken.title"),
              value: dayjs2(props.exifData.DateTimeOriginal).format("L LT"),
              icon: "tabler:calendar"
            } : null,
            props.exifData?.ColorSpace ? {
              label: $t("exif.colorSpace.title"),
              value: localizeExif("colorSpace", props.exifData.ColorSpace),
              icon: "tabler:palette"
            } : null,
            props.exifData?.Artist ? {
              label: $t("exif.artist"),
              value: props.exifData.Artist,
              icon: "tabler:user"
            } : null,
            props.exifData?.Software ? {
              label: $t("exif.software"),
              value: props.exifData.Software,
              icon: "tabler:app-window"
            } : null,
            props.exifData?.tz ? {
              label: $t("exif.tz"),
              value: props.exifData.tz,
              icon: "tabler:world"
            } : null,
            props.currentPhoto.country ? {
              label: $t("exif.country"),
              value: props.currentPhoto.country,
              icon: "tabler:map-pin"
            } : null,
            props.currentPhoto.city ? {
              label: $t("exif.city"),
              value: props.currentPhoto.city,
              icon: "tabler:building"
            } : null,
            props.currentPhoto.latitude && props.currentPhoto.longitude ? {
              label: $t("exif.gps.title"),
              value: formatGPSCoordinatesMultiLine(
                props.currentPhoto.latitude,
                props.currentPhoto.longitude
              ),
              icon: "tabler:gps"
            } : null
          ]
        }
      ];
      sections.captureParams = [
        {
          title: $t("exif.sections.shooting.parameters"),
          items: [
            props.exifData?.FocalLengthIn35mmFormat ? {
              label: $t("exif.focal.length.actual"),
              value: `${props.exifData.FocalLengthIn35mmFormat}`,
              icon: "tabler:telescope"
            } : null,
            props.exifData?.FNumber ? {
              label: $t("exif.aperture"),
              value: `f/${props.exifData.FNumber}`,
              icon: "tabler:aperture"
            } : null,
            props.exifData?.ExposureTime ? {
              label: $t("exif.exposure.time"),
              value: formatExposureTime(props.exifData.ExposureTime),
              icon: "tabler:clock"
            } : null,
            props.exifData?.ISO ? {
              label: "ISO",
              value: props.exifData.ISO.toString(),
              icon: "tabler:sun-electricity"
            } : null
          ]
        }
      ];
      sections.deviceInfo = [
        {
          title: $t("exif.sections.deviceInfomation"),
          items: [
            props.exifData?.Make && props.exifData?.Model ? {
              label: $t("exif.camera"),
              value: formatCameraInfo(
                props.exifData.Make,
                props.exifData.Model
              ),
              icon: "tabler:camera"
            } : null,
            props.exifData?.LensModel ? {
              label: $t("exif.lens"),
              value: formatLensInfo(
                props.exifData.LensMake,
                props.exifData.LensModel
              ),
              icon: "tabler:focus"
            } : null,
            props.exifData?.MaxApertureValue ? {
              label: $t("exif.maxAperture"),
              value: `f/${props.exifData.MaxApertureValue}`,
              icon: "tabler:aperture"
            } : null,
            props.exifData?.FocalLength ? {
              label: $t("exif.focal.length.actual"),
              value: props.exifData.FocalLength,
              icon: "tabler:telescope"
            } : null,
            props.exifData?.FocalLengthIn35mmFormat ? {
              label: $t("exif.focal.length.equivalent"),
              value: props.exifData.FocalLengthIn35mmFormat,
              icon: "tabler:zoom-in-area"
            } : null
          ]
        }
      ];
      sections.captureMode = [
        {
          title: $t("exif.sections.shooting.mode"),
          items: [
            props.exifData?.WhiteBalance ? {
              label: $t("exif.wb.title"),
              value: localizeExif("whiteBalance", props.exifData.WhiteBalance),
              icon: "mdi:white-balance-auto"
            } : null,
            props.exifData?.WBShiftAB ? {
              label: $t("exif.wb.shiftAB"),
              value: `${props.exifData.WBShiftAB}`,
              icon: "mdi:white-balance-auto"
            } : null,
            props.exifData?.WBShiftGM ? {
              label: $t("exif.wb.shiftGM"),
              value: `${props.exifData.WBShiftGM}`,
              icon: "mdi:white-balance-auto"
            } : null,
            props.exifData?.WhiteBalanceBias ? {
              label: $t("exif.wb.bias"),
              value: `${props.exifData.WhiteBalanceBias}`,
              icon: "mdi:white-balance-auto"
            } : null,
            props.exifData?.WhiteBalanceFineTune ? {
              label: $t("exif.wb.fineTune"),
              value: `${props.exifData.WhiteBalanceFineTune}`,
              icon: "mdi:white-balance-auto"
            } : null,
            props.exifData?.ExposureProgram ? {
              label: $t("exif.exposure.program"),
              value: localizeExif(
                "exposureProgram",
                props.exifData.ExposureProgram
              ),
              icon: "tabler:exposure"
            } : null,
            props.exifData?.ExposureMode ? {
              label: $t("exif.exposure.mode"),
              value: localizeExif("exposureMode", props.exifData.ExposureMode),
              icon: "tabler:exposure-filled"
            } : null,
            props.exifData?.MeteringMode ? {
              label: $t("exif.metering.title"),
              value: localizeExif("meteringMode", props.exifData.MeteringMode),
              icon: "tabler:focus-auto"
            } : null,
            props.exifData?.Flash ? {
              label: $t("exif.flash.title"),
              value: localizeExif("flash", props.exifData.Flash),
              icon: "material-symbols:flash-on-rounded"
            } : null,
            props.exifData?.FlashMeteringMode ? {
              label: $t("exif.flash.meteringMode"),
              value: localizeExif(
                "meteringMode",
                props.exifData.FlashMeteringMode
              ),
              icon: "material-symbols:flash-on-rounded"
            } : null,
            props.exifData?.SceneCaptureType ? {
              label: $t("exif.scene.captureType"),
              value: localizeExif(
                "sceneCaptureType",
                props.exifData.SceneCaptureType
              ),
              icon: "material-symbols:scene"
            } : null
          ]
        }
      ];
      sections.technicalParams = [
        {
          title: $t("exif.sections.specification"),
          items: [
            props.exifData?.BrightnessValue ? {
              label: $t("exif.brightness.value"),
              value: `${props.exifData.BrightnessValue.toFixed(1)} EV`,
              icon: "tabler:sun"
            } : null,
            props.exifData?.SensingMethod ? {
              label: $t("exif.sensing.method"),
              value: localizeExif(
                "sensingMethod",
                props.exifData.SensingMethod
              ),
              icon: "tabler:photo-sensor"
            } : null,
            props.exifData?.FocalPlaneXResolution && props.exifData?.FocalPlaneYResolution ? {
              label: $t("exif.focal.plane.resolution"),
              value: `${props.exifData.FocalPlaneXResolution.toFixed(2)} x ${props.exifData.FocalPlaneYResolution.toFixed(2)}`,
              icon: "tabler:photo-sensor"
            } : null
          ]
        }
      ];
      return sections;
    });
    const isMobile = useMediaQuery("(max-width: 768px)");
    const onMinimapClick = (photoId) => {
      (void 0).open(`/globe?photoId=${photoId}`);
    };
    const onTagClick = (tag) => {
      router.push({
        path: "/",
        query: { tag }
      });
    };
    const onAlbumClick = (albumId) => {
      (void 0).open(`/albums/${albumId}`);
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UButton = _sfc_main$v;
      const _component_PhotoMiniMap = __nuxt_component_1$1;
      const _component_PhotoKVRenderer = __nuxt_component_2;
      const _component_Rating = __nuxt_component_1;
      const _component_UBadge = _sfc_main$8;
      const _component_Histogram = __nuxt_component_5;
      _push(ssrRenderComponent(unref(motion).div, mergeProps({
        initial: {
          opacity: 0,
          x: unref(isMobile) ? 0 : 80,
          y: unref(isMobile) ? 20 : 0
        },
        animate: {
          opacity: 1,
          x: 0,
          y: 0
        },
        exit: {
          opacity: 0,
          x: unref(isMobile) ? 0 : 80,
          y: unref(isMobile) ? 20 : 0
        },
        transition: { type: "spring", duration: 0.4, bounce: 0, delay: 0.1 },
        class: ["bg-black/20 dark:bg-black/30 backdrop-blur-xl border-white/10", {
          "fixed inset-x-2 bottom-2 max-h-[70vh] border rounded-xl z-50 flex flex-col": unref(isMobile),
          "w-80 border-l": !unref(isMobile)
        }]
      }, _attrs), {
        default: withCtx((_2, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(`<div class="flex items-center justify-between px-4 py-3 border-b border-white/10 flex-shrink-0" data-v-f609c203${_scopeId}><h3 class="font-black text-white text-ellipsis line-clamp-1" data-v-f609c203${_scopeId}>${ssrInterpolate(__props.currentPhoto.title)}</h3>`);
            if (unref(isMobile) && __props.onClose) {
              _push2(ssrRenderComponent(_component_UButton, {
                icon: "tabler:x",
                variant: "ghost",
                color: "neutral",
                class: "text-white",
                size: "sm",
                onClick: __props.onClose
              }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div><div class="${ssrRenderClass([{
              "overflow-y-auto": unref(isMobile),
              "overflow-y-auto max-h-full pb-16": !unref(isMobile)
            }, "p-4 space-y-4 flex-1 min-h-0"])}" data-v-f609c203${_scopeId}>`);
            if (__props.currentPhoto.description) {
              _push2(`<div class="text-sm text-white text-justify" data-v-f609c203${_scopeId}>${ssrInterpolate(__props.currentPhoto.description)}</div>`);
            } else {
              _push2(`<!---->`);
            }
            if (gpsCoordinates.value) {
              _push2(ssrRenderComponent(_component_PhotoMiniMap, {
                photo: __props.currentPhoto,
                latitude: gpsCoordinates.value?.latitude,
                longitude: gpsCoordinates.value?.longitude,
                class: "cursor-pointer",
                onClick: ($event) => onMinimapClick(__props.currentPhoto.id)
              }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            if (formatedExifData.value.basicInfo) {
              _push2(ssrRenderComponent(_component_PhotoKVRenderer, {
                data: formatedExifData.value.basicInfo
              }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            if (__props.currentPhoto.exif?.Rating) {
              _push2(`<div class="flex items-center gap-2 justify-between" data-v-f609c203${_scopeId}><h4 class="text-sm font-medium text-white uppercase tracking-wide" data-v-f609c203${_scopeId}>${ssrInterpolate(unref($t)("exif.sections.rating"))}</h4>`);
              _push2(ssrRenderComponent(_component_Rating, {
                "model-value": __props.currentPhoto.exif.Rating,
                readonly: "",
                size: "sm"
              }, null, _parent2, _scopeId));
              _push2(`</div>`);
            } else {
              _push2(`<!---->`);
            }
            if (albums.value && albums.value.length > 0) {
              _push2(`<div class="mt-4" data-v-f609c203${_scopeId}><h4 class="text-sm font-medium text-white/90 uppercase tracking-wide mb-2" data-v-f609c203${_scopeId}>${ssrInterpolate(unref($t)("exif.sections.albums"))}</h4><div class="space-y-2" data-v-f609c203${_scopeId}><!--[-->`);
              ssrRenderList(albums.value, (album) => {
                _push2(`<div class="p-3 bg-white/5 border border-white/10 rounded-lg cursor-pointer hover:bg-white/10 transition-colors" data-v-f609c203${_scopeId}><p class="text-sm text-white font-medium line-clamp-1" data-v-f609c203${_scopeId}>${ssrInterpolate(album.title)}</p>`);
                if (album.description) {
                  _push2(`<p class="text-xs text-white/60 line-clamp-1" data-v-f609c203${_scopeId}>${ssrInterpolate(album.description)}</p>`);
                } else {
                  _push2(`<!---->`);
                }
                _push2(`</div>`);
              });
              _push2(`<!--]--></div></div>`);
            } else {
              _push2(`<!---->`);
            }
            if (__props.currentPhoto.tags && __props.currentPhoto.tags.length > 0) {
              _push2(`<div class="mt-4" data-v-f609c203${_scopeId}><h4 class="text-sm font-medium text-white/90 uppercase tracking-wide mb-2" data-v-f609c203${_scopeId}>${ssrInterpolate(unref($t)("exif.sections.tags"))}</h4><div class="flex flex-wrap gap-1" data-v-f609c203${_scopeId}><!--[-->`);
              ssrRenderList(__props.currentPhoto.tags, (tag) => {
                _push2(ssrRenderComponent(_component_UBadge, {
                  key: tag,
                  label: tag,
                  variant: "soft",
                  size: "sm",
                  color: "neutral",
                  class: "bg-white/10 text-white cursor-pointer select-none hover:bg-white/20 transition-colors",
                  onClick: ($event) => onTagClick(tag)
                }, null, _parent2, _scopeId));
              });
              _push2(`<!--]--></div></div>`);
            } else {
              _push2(`<!---->`);
            }
            if (formatedExifData.value.captureParams) {
              _push2(ssrRenderComponent(_component_PhotoKVRenderer, {
                data: formatedExifData.value.captureParams
              }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            _push2(`<div class="space-y-2" data-v-f609c203${_scopeId}><h4 class="text-sm font-medium text-white uppercase tracking-wide" data-v-f609c203${_scopeId}>${ssrInterpolate(unref($t)("exif.sections.histogram"))}</h4>`);
            if (__props.currentPhoto.thumbnailUrl) {
              _push2(ssrRenderComponent(_component_Histogram, {
                "thumbnail-url": __props.currentPhoto.thumbnailUrl
              }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div>`);
            if (formatedExifData.value.deviceInfo) {
              _push2(ssrRenderComponent(_component_PhotoKVRenderer, {
                data: formatedExifData.value.deviceInfo
              }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            if (formatedExifData.value.captureMode) {
              _push2(ssrRenderComponent(_component_PhotoKVRenderer, {
                data: formatedExifData.value.captureMode
              }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            if (formatedExifData.value.technicalParams) {
              _push2(ssrRenderComponent(_component_PhotoKVRenderer, {
                data: formatedExifData.value.technicalParams
              }, null, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
            _push2(`</div>`);
          } else {
            return [
              createVNode("div", { class: "flex items-center justify-between px-4 py-3 border-b border-white/10 flex-shrink-0" }, [
                createVNode("h3", { class: "font-black text-white text-ellipsis line-clamp-1" }, toDisplayString$1(__props.currentPhoto.title), 1),
                unref(isMobile) && __props.onClose ? (openBlock(), createBlock(_component_UButton, {
                  key: 0,
                  icon: "tabler:x",
                  variant: "ghost",
                  color: "neutral",
                  class: "text-white",
                  size: "sm",
                  onClick: __props.onClose
                }, null, 8, ["onClick"])) : createCommentVNode("", true)
              ]),
              createVNode("div", {
                class: ["p-4 space-y-4 flex-1 min-h-0", {
                  "overflow-y-auto": unref(isMobile),
                  "overflow-y-auto max-h-full pb-16": !unref(isMobile)
                }]
              }, [
                __props.currentPhoto.description ? (openBlock(), createBlock("div", {
                  key: 0,
                  class: "text-sm text-white text-justify"
                }, toDisplayString$1(__props.currentPhoto.description), 1)) : createCommentVNode("", true),
                gpsCoordinates.value ? (openBlock(), createBlock(_component_PhotoMiniMap, {
                  key: 1,
                  photo: __props.currentPhoto,
                  latitude: gpsCoordinates.value?.latitude,
                  longitude: gpsCoordinates.value?.longitude,
                  class: "cursor-pointer",
                  onClick: ($event) => onMinimapClick(__props.currentPhoto.id)
                }, null, 8, ["photo", "latitude", "longitude", "onClick"])) : createCommentVNode("", true),
                formatedExifData.value.basicInfo ? (openBlock(), createBlock(_component_PhotoKVRenderer, {
                  key: 2,
                  data: formatedExifData.value.basicInfo
                }, null, 8, ["data"])) : createCommentVNode("", true),
                __props.currentPhoto.exif?.Rating ? (openBlock(), createBlock("div", {
                  key: 3,
                  class: "flex items-center gap-2 justify-between"
                }, [
                  createVNode("h4", { class: "text-sm font-medium text-white uppercase tracking-wide" }, toDisplayString$1(unref($t)("exif.sections.rating")), 1),
                  createVNode(_component_Rating, {
                    "model-value": __props.currentPhoto.exif.Rating,
                    readonly: "",
                    size: "sm"
                  }, null, 8, ["model-value"])
                ])) : createCommentVNode("", true),
                albums.value && albums.value.length > 0 ? (openBlock(), createBlock("div", {
                  key: 4,
                  class: "mt-4"
                }, [
                  createVNode("h4", { class: "text-sm font-medium text-white/90 uppercase tracking-wide mb-2" }, toDisplayString$1(unref($t)("exif.sections.albums")), 1),
                  createVNode("div", { class: "space-y-2" }, [
                    (openBlock(true), createBlock(Fragment, null, renderList(albums.value, (album) => {
                      return openBlock(), createBlock("div", {
                        key: album.id,
                        class: "p-3 bg-white/5 border border-white/10 rounded-lg cursor-pointer hover:bg-white/10 transition-colors",
                        onClick: ($event) => onAlbumClick(album.id)
                      }, [
                        createVNode("p", { class: "text-sm text-white font-medium line-clamp-1" }, toDisplayString$1(album.title), 1),
                        album.description ? (openBlock(), createBlock("p", {
                          key: 0,
                          class: "text-xs text-white/60 line-clamp-1"
                        }, toDisplayString$1(album.description), 1)) : createCommentVNode("", true)
                      ], 8, ["onClick"]);
                    }), 128))
                  ])
                ])) : createCommentVNode("", true),
                __props.currentPhoto.tags && __props.currentPhoto.tags.length > 0 ? (openBlock(), createBlock("div", {
                  key: 5,
                  class: "mt-4"
                }, [
                  createVNode("h4", { class: "text-sm font-medium text-white/90 uppercase tracking-wide mb-2" }, toDisplayString$1(unref($t)("exif.sections.tags")), 1),
                  createVNode("div", { class: "flex flex-wrap gap-1" }, [
                    (openBlock(true), createBlock(Fragment, null, renderList(__props.currentPhoto.tags, (tag) => {
                      return openBlock(), createBlock(_component_UBadge, {
                        key: tag,
                        label: tag,
                        variant: "soft",
                        size: "sm",
                        color: "neutral",
                        class: "bg-white/10 text-white cursor-pointer select-none hover:bg-white/20 transition-colors",
                        onClick: ($event) => onTagClick(tag)
                      }, null, 8, ["label", "onClick"]);
                    }), 128))
                  ])
                ])) : createCommentVNode("", true),
                formatedExifData.value.captureParams ? (openBlock(), createBlock(_component_PhotoKVRenderer, {
                  key: 6,
                  data: formatedExifData.value.captureParams
                }, null, 8, ["data"])) : createCommentVNode("", true),
                createVNode("div", { class: "space-y-2" }, [
                  createVNode("h4", { class: "text-sm font-medium text-white uppercase tracking-wide" }, toDisplayString$1(unref($t)("exif.sections.histogram")), 1),
                  __props.currentPhoto.thumbnailUrl ? (openBlock(), createBlock(_component_Histogram, {
                    key: 0,
                    "thumbnail-url": __props.currentPhoto.thumbnailUrl
                  }, null, 8, ["thumbnail-url"])) : createCommentVNode("", true)
                ]),
                formatedExifData.value.deviceInfo ? (openBlock(), createBlock(_component_PhotoKVRenderer, {
                  key: 7,
                  data: formatedExifData.value.deviceInfo
                }, null, 8, ["data"])) : createCommentVNode("", true),
                formatedExifData.value.captureMode ? (openBlock(), createBlock(_component_PhotoKVRenderer, {
                  key: 8,
                  data: formatedExifData.value.captureMode
                }, null, 8, ["data"])) : createCommentVNode("", true),
                formatedExifData.value.technicalParams ? (openBlock(), createBlock(_component_PhotoKVRenderer, {
                  key: 9,
                  data: formatedExifData.value.technicalParams
                }, null, 8, ["data"])) : createCommentVNode("", true)
              ], 2)
            ];
          }
        }),
        _: 1
      }, _parent));
    };
  }
});
const _sfc_setup$6 = _sfc_main$6.setup;
_sfc_main$6.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/photo/InfoPanel.vue");
  return _sfc_setup$6 ? _sfc_setup$6(props, ctx) : void 0;
};
const InfoPanel = /* @__PURE__ */ Object.assign(_export_sfc(_sfc_main$6, [["__scopeId", "data-v-f609c203"]]), { __name: "PhotoInfoPanel" });
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "ReactionPicker",
  __ssrInlineRender: true,
  props: {
    isOpen: { type: Boolean },
    selectedReaction: {},
    reactionCounts: {}
  },
  emits: ["select", "close"],
  setup(__props, { emit: __emit }) {
    const { t: $t } = useI18n();
    const props = __props;
    const emit = __emit;
    const pickerRef = ref(null);
    onClickOutside(pickerRef, () => {
      if (props.isOpen) {
        emit("close");
      }
    });
    const reactions = computed(() => [
      { id: "like", iconName: "fluent-emoji-flat:thumbs-up", label: $t("viewer.reaction.like"), count: props.reactionCounts?.like || 0 },
      { id: "love", iconName: "fluent-emoji-flat:red-heart", label: $t("viewer.reaction.love"), count: props.reactionCounts?.love || 0 },
      { id: "amazing", iconName: "fluent-emoji-flat:smiling-face-with-heart-eyes", label: $t("viewer.reaction.amazing"), count: props.reactionCounts?.amazing || 0 },
      { id: "funny", iconName: "fluent-emoji-flat:face-with-tears-of-joy", label: $t("viewer.reaction.funny"), count: props.reactionCounts?.funny || 0 },
      { id: "wow", iconName: "fluent-emoji-flat:face-with-open-mouth", label: $t("viewer.reaction.wow"), count: props.reactionCounts?.wow || 0 },
      { id: "sad", iconName: "fluent-emoji-flat:crying-face", label: $t("viewer.reaction.sad"), count: props.reactionCounts?.sad || 0 },
      { id: "fire", iconName: "fluent-emoji-flat:fire", label: $t("viewer.reaction.fire"), count: props.reactionCounts?.fire || 0 },
      { id: "sparkle", iconName: "fluent-emoji-flat:sparkles", label: $t("viewer.reaction.sparkle"), count: props.reactionCounts?.sparkle || 0 }
    ]);
    const formatCount = (count) => {
      if (!count || count === 0) return "";
      if (count >= 1e3) {
        return `${(count / 1e3).toFixed(1)}k`;
      }
      return count.toString();
    };
    const handleSelect = (id2) => {
      const reaction = reactions.value.find((r) => r.id === id2);
      if (reaction) {
        emit("select", id2, reaction.iconName);
      }
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_Icon = __nuxt_component_0$4;
      _push(ssrRenderComponent(unref(_sfc_main$n), _attrs, {
        default: withCtx((_2, _push2, _parent2, _scopeId) => {
          if (_push2) {
            if (__props.isOpen) {
              _push2(ssrRenderComponent(unref(motion).div, {
                ref_key: "pickerRef",
                ref: pickerRef,
                initial: { opacity: 0, scale: 0.9, y: 10 },
                animate: { opacity: 1, scale: 1, y: 0 },
                exit: { opacity: 0, scale: 0.9, y: 10 },
                transition: {
                  type: "spring",
                  stiffness: 400,
                  damping: 25,
                  mass: 0.8
                },
                class: "absolute bottom-full right-0 mb-2 z-30",
                onClick: () => {
                }
              }, {
                default: withCtx((_22, _push3, _parent3, _scopeId2) => {
                  if (_push3) {
                    _push3(`<div class="bg-white/90 dark:bg-neutral-800/90 backdrop-blur-xl rounded-2xl border border-neutral-200/50 dark:border-white/10 shadow-2xl shadow-black/10 dark:shadow-black/30 p-3"${_scopeId2}><div class="grid grid-cols-4 gap-2 min-w-[220px]"${_scopeId2}><!--[-->`);
                    ssrRenderList(unref(reactions), (reaction) => {
                      _push3(ssrRenderComponent(unref(motion).button, {
                        key: reaction.id,
                        type: "button",
                        initial: { scale: 0, opacity: 0 },
                        animate: {
                          scale: 1,
                          opacity: 1,
                          transition: {
                            type: "spring",
                            stiffness: 500,
                            damping: 20,
                            delay: unref(reactions).indexOf(reaction) * 0.03
                          }
                        },
                        "while-hover": {
                          scale: 1.2,
                          transition: {
                            type: "spring",
                            stiffness: 500,
                            damping: 20
                          }
                        },
                        "while-tap": {
                          scale: 0.9,
                          transition: {
                            type: "spring",
                            stiffness: 500,
                            damping: 20
                          }
                        },
                        class: [
                          "relative aspect-square w-full min-w-[48px] rounded-xl flex items-center justify-center transition-colors cursor-pointer shrink-0 group",
                          "hover:bg-neutral-100/80 dark:hover:bg-white/10",
                          "active:bg-neutral-200/80 dark:active:bg-white/20",
                          __props.selectedReaction === reaction.id ? "bg-blue-100 dark:bg-blue-500/20 ring-2 ring-blue-500/50" : "bg-transparent"
                        ],
                        title: reaction.label,
                        onClick: ($event) => handleSelect(reaction.id)
                      }, {
                        default: withCtx((_3, _push4, _parent4, _scopeId3) => {
                          if (_push4) {
                            _push4(ssrRenderComponent(_component_Icon, {
                              name: reaction.iconName,
                              class: "text-[28px] select-none",
                              mode: "svg"
                            }, null, _parent4, _scopeId3));
                            if (reaction.count !== void 0 && reaction.count > 0) {
                              _push4(ssrRenderComponent(unref(motion).span, {
                                initial: { scale: 0, opacity: 0 },
                                animate: { scale: 1, opacity: 1 },
                                class: [
                                  "absolute -top-1 -right-1 min-w-[18px] h-[18px] px-1",
                                  "flex items-center justify-center",
                                  "text-[9px] font-bold leading-none",
                                  "rounded-full",
                                  "shadow-sm",
                                  __props.selectedReaction === reaction.id ? "bg-blue-500 text-white" : "bg-gradient-to-br from-neutral-100 to-neutral-200 dark:from-neutral-700 dark:to-neutral-600 text-neutral-700 dark:text-neutral-100",
                                  "border border-white/50 dark:border-neutral-800/50",
                                  "group-hover:scale-110 transition-transform duration-150"
                                ]
                              }, {
                                default: withCtx((_4, _push5, _parent5, _scopeId4) => {
                                  if (_push5) {
                                    _push5(`${ssrInterpolate(formatCount(reaction.count))}`);
                                  } else {
                                    return [
                                      createTextVNode(toDisplayString$1(formatCount(reaction.count)), 1)
                                    ];
                                  }
                                }),
                                _: 2
                              }, _parent4, _scopeId3));
                            } else {
                              _push4(`<!---->`);
                            }
                          } else {
                            return [
                              createVNode(_component_Icon, {
                                name: reaction.iconName,
                                class: "text-[28px] select-none",
                                mode: "svg"
                              }, null, 8, ["name"]),
                              reaction.count !== void 0 && reaction.count > 0 ? (openBlock(), createBlock(unref(motion).span, {
                                key: 0,
                                initial: { scale: 0, opacity: 0 },
                                animate: { scale: 1, opacity: 1 },
                                class: [
                                  "absolute -top-1 -right-1 min-w-[18px] h-[18px] px-1",
                                  "flex items-center justify-center",
                                  "text-[9px] font-bold leading-none",
                                  "rounded-full",
                                  "shadow-sm",
                                  __props.selectedReaction === reaction.id ? "bg-blue-500 text-white" : "bg-gradient-to-br from-neutral-100 to-neutral-200 dark:from-neutral-700 dark:to-neutral-600 text-neutral-700 dark:text-neutral-100",
                                  "border border-white/50 dark:border-neutral-800/50",
                                  "group-hover:scale-110 transition-transform duration-150"
                                ]
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString$1(formatCount(reaction.count)), 1)
                                ]),
                                _: 2
                              }, 1032, ["class"])) : createCommentVNode("", true)
                            ];
                          }
                        }),
                        _: 2
                      }, _parent3, _scopeId2));
                    });
                    _push3(`<!--]--></div></div>`);
                  } else {
                    return [
                      createVNode("div", { class: "bg-white/90 dark:bg-neutral-800/90 backdrop-blur-xl rounded-2xl border border-neutral-200/50 dark:border-white/10 shadow-2xl shadow-black/10 dark:shadow-black/30 p-3" }, [
                        createVNode("div", { class: "grid grid-cols-4 gap-2 min-w-[220px]" }, [
                          (openBlock(true), createBlock(Fragment, null, renderList(unref(reactions), (reaction) => {
                            return openBlock(), createBlock(unref(motion).button, {
                              key: reaction.id,
                              type: "button",
                              initial: { scale: 0, opacity: 0 },
                              animate: {
                                scale: 1,
                                opacity: 1,
                                transition: {
                                  type: "spring",
                                  stiffness: 500,
                                  damping: 20,
                                  delay: unref(reactions).indexOf(reaction) * 0.03
                                }
                              },
                              "while-hover": {
                                scale: 1.2,
                                transition: {
                                  type: "spring",
                                  stiffness: 500,
                                  damping: 20
                                }
                              },
                              "while-tap": {
                                scale: 0.9,
                                transition: {
                                  type: "spring",
                                  stiffness: 500,
                                  damping: 20
                                }
                              },
                              class: [
                                "relative aspect-square w-full min-w-[48px] rounded-xl flex items-center justify-center transition-colors cursor-pointer shrink-0 group",
                                "hover:bg-neutral-100/80 dark:hover:bg-white/10",
                                "active:bg-neutral-200/80 dark:active:bg-white/20",
                                __props.selectedReaction === reaction.id ? "bg-blue-100 dark:bg-blue-500/20 ring-2 ring-blue-500/50" : "bg-transparent"
                              ],
                              title: reaction.label,
                              onClick: ($event) => handleSelect(reaction.id)
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_Icon, {
                                  name: reaction.iconName,
                                  class: "text-[28px] select-none",
                                  mode: "svg"
                                }, null, 8, ["name"]),
                                reaction.count !== void 0 && reaction.count > 0 ? (openBlock(), createBlock(unref(motion).span, {
                                  key: 0,
                                  initial: { scale: 0, opacity: 0 },
                                  animate: { scale: 1, opacity: 1 },
                                  class: [
                                    "absolute -top-1 -right-1 min-w-[18px] h-[18px] px-1",
                                    "flex items-center justify-center",
                                    "text-[9px] font-bold leading-none",
                                    "rounded-full",
                                    "shadow-sm",
                                    __props.selectedReaction === reaction.id ? "bg-blue-500 text-white" : "bg-gradient-to-br from-neutral-100 to-neutral-200 dark:from-neutral-700 dark:to-neutral-600 text-neutral-700 dark:text-neutral-100",
                                    "border border-white/50 dark:border-neutral-800/50",
                                    "group-hover:scale-110 transition-transform duration-150"
                                  ]
                                }, {
                                  default: withCtx(() => [
                                    createTextVNode(toDisplayString$1(formatCount(reaction.count)), 1)
                                  ]),
                                  _: 2
                                }, 1032, ["class"])) : createCommentVNode("", true)
                              ]),
                              _: 2
                            }, 1032, ["animate", "class", "title", "onClick"]);
                          }), 128))
                        ])
                      ])
                    ];
                  }
                }),
                _: 1
              }, _parent2, _scopeId));
            } else {
              _push2(`<!---->`);
            }
          } else {
            return [
              __props.isOpen ? (openBlock(), createBlock(unref(motion).div, {
                key: 0,
                ref_key: "pickerRef",
                ref: pickerRef,
                initial: { opacity: 0, scale: 0.9, y: 10 },
                animate: { opacity: 1, scale: 1, y: 0 },
                exit: { opacity: 0, scale: 0.9, y: 10 },
                transition: {
                  type: "spring",
                  stiffness: 400,
                  damping: 25,
                  mass: 0.8
                },
                class: "absolute bottom-full right-0 mb-2 z-30",
                onClick: withModifiers(() => {
                }, ["stop"])
              }, {
                default: withCtx(() => [
                  createVNode("div", { class: "bg-white/90 dark:bg-neutral-800/90 backdrop-blur-xl rounded-2xl border border-neutral-200/50 dark:border-white/10 shadow-2xl shadow-black/10 dark:shadow-black/30 p-3" }, [
                    createVNode("div", { class: "grid grid-cols-4 gap-2 min-w-[220px]" }, [
                      (openBlock(true), createBlock(Fragment, null, renderList(unref(reactions), (reaction) => {
                        return openBlock(), createBlock(unref(motion).button, {
                          key: reaction.id,
                          type: "button",
                          initial: { scale: 0, opacity: 0 },
                          animate: {
                            scale: 1,
                            opacity: 1,
                            transition: {
                              type: "spring",
                              stiffness: 500,
                              damping: 20,
                              delay: unref(reactions).indexOf(reaction) * 0.03
                            }
                          },
                          "while-hover": {
                            scale: 1.2,
                            transition: {
                              type: "spring",
                              stiffness: 500,
                              damping: 20
                            }
                          },
                          "while-tap": {
                            scale: 0.9,
                            transition: {
                              type: "spring",
                              stiffness: 500,
                              damping: 20
                            }
                          },
                          class: [
                            "relative aspect-square w-full min-w-[48px] rounded-xl flex items-center justify-center transition-colors cursor-pointer shrink-0 group",
                            "hover:bg-neutral-100/80 dark:hover:bg-white/10",
                            "active:bg-neutral-200/80 dark:active:bg-white/20",
                            __props.selectedReaction === reaction.id ? "bg-blue-100 dark:bg-blue-500/20 ring-2 ring-blue-500/50" : "bg-transparent"
                          ],
                          title: reaction.label,
                          onClick: ($event) => handleSelect(reaction.id)
                        }, {
                          default: withCtx(() => [
                            createVNode(_component_Icon, {
                              name: reaction.iconName,
                              class: "text-[28px] select-none",
                              mode: "svg"
                            }, null, 8, ["name"]),
                            reaction.count !== void 0 && reaction.count > 0 ? (openBlock(), createBlock(unref(motion).span, {
                              key: 0,
                              initial: { scale: 0, opacity: 0 },
                              animate: { scale: 1, opacity: 1 },
                              class: [
                                "absolute -top-1 -right-1 min-w-[18px] h-[18px] px-1",
                                "flex items-center justify-center",
                                "text-[9px] font-bold leading-none",
                                "rounded-full",
                                "shadow-sm",
                                __props.selectedReaction === reaction.id ? "bg-blue-500 text-white" : "bg-gradient-to-br from-neutral-100 to-neutral-200 dark:from-neutral-700 dark:to-neutral-600 text-neutral-700 dark:text-neutral-100",
                                "border border-white/50 dark:border-neutral-800/50",
                                "group-hover:scale-110 transition-transform duration-150"
                              ]
                            }, {
                              default: withCtx(() => [
                                createTextVNode(toDisplayString$1(formatCount(reaction.count)), 1)
                              ]),
                              _: 2
                            }, 1032, ["class"])) : createCommentVNode("", true)
                          ]),
                          _: 2
                        }, 1032, ["animate", "class", "title", "onClick"]);
                      }), 128))
                    ])
                  ])
                ]),
                _: 1
              }, 8, ["onClick"])) : createCommentVNode("", true)
            ];
          }
        }),
        _: 1
      }, _parent));
    };
  }
});
const _sfc_setup$5 = _sfc_main$5.setup;
_sfc_main$5.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/photo/ReactionPicker.vue");
  return _sfc_setup$5 ? _sfc_setup$5(props, ctx) : void 0;
};
const ReactionPicker = Object.assign(_sfc_main$5, { __name: "PhotoReactionPicker" });
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "ReactionConfetti",
  __ssrInlineRender: true,
  props: {
    iconName: {},
    triggerCount: {}
  },
  setup(__props) {
    const props = __props;
    const particles = computed(() => {
      if (props.triggerCount === 0) return [];
      const count = 18;
      const result = [];
      for (let i = 0; i < count; i++) {
        const angle = 360 / count * i;
        const distance2 = 80 + Math.random() * 40;
        const delay2 = Math.random() * 0.15;
        const duration2 = 1.2 + Math.random() * 0.4;
        const rotation2 = Math.random() * 360 - 180;
        const scale2 = 0.7 + Math.random() * 0.3;
        result.push({
          id: props.triggerCount * 100 + i,
          angle,
          distance: distance2,
          delay: delay2,
          duration: duration2,
          rotation: rotation2,
          scale: scale2
        });
      }
      return result;
    });
    const getParticlePosition = (angle, distance2) => {
      const radian = angle * Math.PI / 180;
      return {
        x: Math.cos(radian) * distance2,
        y: Math.sin(radian) * distance2
      };
    };
    return (_ctx, _push, _parent, _attrs) => {
      const _component_Icon = __nuxt_component_0$4;
      _push(`<div${ssrRenderAttrs(mergeProps({ class: "absolute inset-0 pointer-events-none overflow-visible flex items-center justify-center z-[9999]" }, _attrs))}><!--[-->`);
      ssrRenderList(unref(particles), (particle) => {
        _push(ssrRenderComponent(unref(motion).div, {
          key: particle.id,
          initial: {
            x: 0,
            y: 0,
            scale: 0,
            opacity: 1,
            rotate: 0
          },
          animate: {
            x: getParticlePosition(particle.angle, particle.distance).x,
            y: getParticlePosition(particle.angle, particle.distance).y,
            scale: [0, particle.scale * 1.1, particle.scale, 0],
            opacity: [0, 1, 1, 0],
            rotate: particle.rotation,
            transition: {
              duration: particle.duration,
              delay: particle.delay,
              ease: [0.25, 0.46, 0.45, 0.94]
            }
          },
          class: "absolute z-[9999]",
          style: { "transform-origin": "center" }
        }, {
          default: withCtx((_2, _push2, _parent2, _scopeId) => {
            if (_push2) {
              _push2(ssrRenderComponent(_component_Icon, {
                name: __props.iconName,
                class: "text-[24px]",
                mode: "svg"
              }, null, _parent2, _scopeId));
            } else {
              return [
                createVNode(_component_Icon, {
                  name: __props.iconName,
                  class: "text-[24px]",
                  mode: "svg"
                }, null, 8, ["name"])
              ];
            }
          }),
          _: 2
        }, _parent));
      });
      _push(`<!--]--></div>`);
    };
  }
});
const _sfc_setup$4 = _sfc_main$4.setup;
_sfc_main$4.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/photo/ReactionConfetti.vue");
  return _sfc_setup$4 ? _sfc_setup$4(props, ctx) : void 0;
};
const ReactionConfetti = Object.assign(_sfc_main$4, { __name: "PhotoReactionConfetti" });
const intervalError = "[nuxt] `setInterval` should not be used on the server. Consider wrapping it with an `onNuxtReady`, `onBeforeMount` or `onMounted` lifecycle hook, or ensure you only call it in the browser by checking `false`.";
const setInterval = () => {
  console.error(intervalError);
};
const processedLivePhotos = ref(/* @__PURE__ */ new Map());
const useLivePhotoProcessor = () => {
  const convertMovToMp4 = async (movUrl, photoId) => {
    const existing = processedLivePhotos.value.get(photoId);
    if (existing) {
      const now2 = Date.now();
      const cacheExpiry = 24 * 60 * 60 * 1e3;
      if (existing.mp4Blob && existing.lastProcessed && now2 - existing.lastProcessed < cacheExpiry) {
        return existing.mp4Blob;
      }
      if (existing.isProcessing) {
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve(null);
          }, 3e4);
          setInterval();
        });
      }
    }
    const maxRetries = 3;
    const currentRetry = existing?.retryCount || 0;
    if (currentRetry >= maxRetries) {
      console.warn(`Max retries reached for LivePhoto ${photoId}`);
      return null;
    }
    const state2 = {
      isProcessing: true,
      progress: 0,
      mp4Blob: null,
      error: null,
      retryCount: currentRetry,
      lastProcessed: Date.now()
    };
    processedLivePhotos.value.set(photoId, state2);
    try {
      const updateProgress = (progress2) => {
        state2.progress = progress2;
        processedLivePhotos.value.set(photoId, { ...state2 });
      };
      updateProgress(10);
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 3e4);
      const response = await fetch(movUrl, {
        signal: controller.signal,
        headers: {
          "Cache-Control": "max-age=3600"
          // 缓存1小时
        }
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`Failed to fetch MOV file: ${response.status} ${response.statusText}`);
      }
      updateProgress(30);
      const reader = response.body?.getReader();
      if (!reader) throw new Error("Failed to get response reader");
      const chunks = [];
      const contentLength = parseInt(response.headers.get("content-length") || "0");
      let receivedLength = 0;
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        chunks.push(value);
        receivedLength += value.length;
        if (contentLength > 0) {
          const downloadProgress = 30 + receivedLength / contentLength * 40;
          updateProgress(Math.round(downloadProgress));
        }
      }
      const movBlob = new Blob(chunks);
      updateProgress(70);
      const mp4Blob = new Blob([movBlob], { type: "video/mp4" });
      updateProgress(85);
      const videoUrl = URL.createObjectURL(mp4Blob);
      const video = (void 0).createElement("video");
      await new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error("Video validation timeout"));
        }, 5e3);
        video.onloadedmetadata = () => {
          clearTimeout(timeout);
          resolve();
        };
        video.onerror = () => {
          clearTimeout(timeout);
          reject(new Error("Video format not supported"));
        };
        video.src = videoUrl;
        video.load();
      });
      URL.revokeObjectURL(videoUrl);
      updateProgress(95);
      state2.isProcessing = false;
      state2.progress = 100;
      state2.mp4Blob = mp4Blob;
      state2.lastProcessed = Date.now();
      state2.error = null;
      processedLivePhotos.value.set(photoId, { ...state2 });
      return mp4Blob;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      if (currentRetry < maxRetries - 1) {
        console.warn(`LivePhoto processing failed (attempt ${currentRetry + 1}/${maxRetries}), retrying...`, errorMessage);
        state2.retryCount = currentRetry + 1;
        state2.isProcessing = false;
        state2.error = `Retrying... (${currentRetry + 1}/${maxRetries})`;
        processedLivePhotos.value.set(photoId, { ...state2 });
        const retryDelay = Math.min(1e3 * Math.pow(2, currentRetry), 5e3);
        await new Promise((resolve) => setTimeout(resolve, retryDelay));
        return convertMovToMp4(movUrl, photoId);
      }
      state2.isProcessing = false;
      state2.error = errorMessage;
      state2.lastProcessed = Date.now();
      processedLivePhotos.value.set(photoId, { ...state2 });
      console.error(`Failed to convert MOV to MP4 after ${maxRetries} attempts:`, error);
      return null;
    }
  };
  const getProcessingState = (photoId) => {
    return computed(() => processedLivePhotos.value.get(photoId) || null);
  };
  const preloadLivePhotosInViewport = async (photos, options = {}) => {
    const { maxConcurrent = 2, prioritizeVisible = true, prefetchDistance = 3 } = options;
    const livePhotos = photos.filter((photo) => photo.livePhotoVideoUrl);
    if (prioritizeVisible) {
      const visiblePhotos = livePhotos.filter((photo) => photo.isVisible);
      const nearbyPhotos = livePhotos.filter((photo) => !photo.isVisible).slice(0, prefetchDistance);
      if (visiblePhotos.length > 0) {
        await processPhotoBatch(visiblePhotos, maxConcurrent);
      }
      if (nearbyPhotos.length > 0) {
        processPhotoBatch(nearbyPhotos, Math.min(maxConcurrent, 1));
      }
    } else {
      await processPhotoBatch(livePhotos, maxConcurrent);
    }
  };
  const processPhotoBatch = async (photos, maxConcurrent) => {
    for (let i = 0; i < photos.length; i += maxConcurrent) {
      const batch = photos.slice(i, i + maxConcurrent);
      await Promise.allSettled(
        batch.map((photo) => convertMovToMp4(photo.livePhotoVideoUrl, photo.id))
      );
      if (i + maxConcurrent < photos.length) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
    }
  };
  const batchProcessLivePhotos = async (photos) => {
    await preloadLivePhotosInViewport(photos, { maxConcurrent: 3 });
  };
  const cleanupExpiredCache = () => {
    const now2 = Date.now();
    const cacheExpiry = 24 * 60 * 60 * 1e3;
    const maxCacheSize = 50;
    const entries = Array.from(processedLivePhotos.value.entries());
    const expiredEntries = [];
    entries.forEach(([photoId, state2]) => {
      if (state2.lastProcessed && now2 - state2.lastProcessed > cacheExpiry) {
        expiredEntries.push(photoId);
      }
    });
    expiredEntries.forEach((photoId) => {
      const state2 = processedLivePhotos.value.get(photoId);
      if (state2?.mp4Blob) {
        state2.mp4Blob = null;
      }
      processedLivePhotos.value.delete(photoId);
    });
    if (processedLivePhotos.value.size > maxCacheSize) {
      const sortedEntries = entries.filter(([photoId]) => !expiredEntries.includes(photoId)).sort((a, b) => (a[1].lastProcessed || 0) - (b[1].lastProcessed || 0));
      const toRemove = sortedEntries.slice(0, processedLivePhotos.value.size - maxCacheSize);
      toRemove.forEach(([photoId, state2]) => {
        if (state2.mp4Blob) {
          state2.mp4Blob = null;
        }
        processedLivePhotos.value.delete(photoId);
      });
    }
    console.log(`Cleaned up ${expiredEntries.length} expired LivePhoto cache entries`);
  };
  const getCacheStats = () => {
    const total = processedLivePhotos.value.size;
    let processed = 0;
    let processing = 0;
    let failed = 0;
    let totalSize = 0;
    processedLivePhotos.value.forEach((state2) => {
      if (state2.mp4Blob) {
        processed++;
        totalSize += state2.mp4Blob.size;
      } else if (state2.isProcessing) {
        processing++;
      } else if (state2.error) {
        failed++;
      }
    });
    return {
      total,
      processed,
      processing,
      failed,
      totalSizeMB: Math.round(totalSize / (1024 * 1024) * 100) / 100
    };
  };
  const clearProcessedCache = () => {
    processedLivePhotos.value.forEach((state2) => {
      if (state2.mp4Blob) {
        state2.mp4Blob = null;
      }
    });
    processedLivePhotos.value.clear();
    console.log("All LivePhoto cache cleared");
  };
  return {
    convertMovToMp4,
    getProcessingState,
    batchProcessLivePhotos,
    preloadLivePhotosInViewport,
    cleanupExpiredCache,
    getCacheStats,
    clearProcessedCache,
    processedLivePhotos: readonly(processedLivePhotos)
  };
};
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "Viewer",
  __ssrInlineRender: true,
  props: {
    photos: {},
    currentIndex: {},
    isOpen: { type: Boolean }
  },
  emits: ["close", "indexChange"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const toast = useToast();
    const containerRef = ref();
    const swiperRef = ref();
    const loadingIndicatorRef = ref();
    const isImageZoomed = ref(false);
    const showExifPanel = ref(false);
    const showShareModal = ref(false);
    const currentBlobSrc = ref(null);
    const zoomLevel = ref(0);
    const showZoomLevel = ref(false);
    const zoomLevelTimer = ref(null);
    const showReactionPicker = ref(false);
    const selectedReaction = ref(null);
    const reactionCounts = ref({});
    const isLoadingReaction = ref(false);
    const confettiIcon = ref(null);
    const confettiTriggerCount = ref(0);
    const reactionIcons = {
      like: "fluent-emoji-flat:thumbs-up",
      love: "fluent-emoji-flat:red-heart",
      amazing: "fluent-emoji-flat:smiling-face-with-heart-eyes",
      funny: "fluent-emoji-flat:face-with-tears-of-joy",
      wow: "fluent-emoji-flat:face-with-open-mouth",
      sad: "fluent-emoji-flat:crying-face",
      fire: "fluent-emoji-flat:fire",
      sparkle: "fluent-emoji-flat:sparkles"
    };
    const currentReactionIcon = computed(() => {
      return selectedReaction.value ? reactionIcons[selectedReaction.value] : null;
    });
    const totalReactions = computed(() => {
      return Object.values(reactionCounts.value).reduce(
        (sum, count) => sum + count,
        0
      );
    });
    const loadPhotoReactions = async (photoId) => {
      try {
        const data = await $fetch(`/api/photos/${photoId}/reactions`);
        selectedReaction.value = data.userReaction || null;
        reactionCounts.value = data.reactions || {};
      } catch (error) {
        console.error("Failed to load reactions:", error);
      }
    };
    const isLivePhotoHovering = ref(false);
    const isLivePhotoPlaying = ref(false);
    const isLivePhotoTouching = ref(false);
    const isLivePhotoMuted = ref(true);
    const touchCount = ref(0);
    const livePhotoVideoBlob = ref(null);
    const livePhotoVideoBlobUrl = ref(null);
    const livePhotoVideoRef = useDomRef();
    const longPressTimer = ref(null);
    const { convertMovToMp4, getProcessingState } = useLivePhotoProcessor();
    const currentPhoto = computed(() => props.photos[props.currentIndex]);
    const isMobile = useMediaQuery("(max-width: 768px)");
    const livePhotoProcessingState = computed(() => {
      return currentPhoto.value ? getProcessingState(currentPhoto.value.id) : ref(null);
    });
    watch(
      () => props.isOpen,
      (isOpen) => {
        if (!isOpen) {
          isImageZoomed.value = false;
          showExifPanel.value = false;
          showShareModal.value = false;
          currentBlobSrc.value = null;
          zoomLevel.value = 0;
          showZoomLevel.value = false;
          showReactionPicker.value = false;
          selectedReaction.value = null;
          confettiIcon.value = null;
          confettiTriggerCount.value = 0;
          isLivePhotoHovering.value = false;
          isLivePhotoPlaying.value = false;
          isLivePhotoTouching.value = false;
          touchCount.value = 0;
          if (longPressTimer.value) {
            clearTimeout(longPressTimer.value);
            longPressTimer.value = null;
          }
          if (livePhotoVideoBlobUrl.value) {
            URL.revokeObjectURL(livePhotoVideoBlobUrl.value);
            livePhotoVideoBlobUrl.value = null;
          }
          livePhotoVideoBlob.value = null;
          if (zoomLevelTimer.value) {
            clearTimeout(zoomLevelTimer.value);
            zoomLevelTimer.value = null;
          }
          (void 0).body.style.overflow = "";
        } else {
          (void 0).body.style.overflow = "hidden";
          nextTick(() => {
            processCurrentLivePhoto();
          });
        }
      },
      { immediate: true }
    );
    watch(
      () => props.currentIndex,
      (newIndex) => {
        if (swiperRef.value && swiperRef.value.activeIndex !== newIndex) {
          swiperRef.value.slideTo(newIndex, 300);
        }
        isImageZoomed.value = false;
        zoomLevel.value = 0;
        showReactionPicker.value = false;
        selectedReaction.value = null;
        isLivePhotoPlaying.value = false;
        isLivePhotoHovering.value = false;
        isLivePhotoTouching.value = false;
        touchCount.value = 0;
        if (longPressTimer.value) {
          clearTimeout(longPressTimer.value);
          longPressTimer.value = null;
        }
        nextTick(() => {
          processCurrentLivePhoto();
        });
      }
    );
    watch(isImageZoomed, (isZoomed) => {
      if (swiperRef.value) {
        swiperRef.value.allowTouchMove = !isZoomed;
      }
    });
    const handlePrevious = () => {
      if (props.currentIndex > 0) {
        emit("indexChange", props.currentIndex - 1);
        swiperRef.value?.slidePrev();
      }
    };
    const handleNext = () => {
      if (props.currentIndex < props.photos.length - 1) {
        emit("indexChange", props.currentIndex + 1);
        swiperRef.value?.slideNext();
      }
    };
    const handleSwiperInit = (swiper) => {
      swiperRef.value = swiper;
      swiper.allowTouchMove = !isImageZoomed.value;
    };
    const handleSlideChange = (swiper) => {
      emit("indexChange", swiper.activeIndex);
    };
    const handleZoomChange = (isZoomed, level) => {
      isImageZoomed.value = isZoomed;
      if (level !== void 0) {
        zoomLevel.value = level;
        showZoomLevel.value = true;
        if (zoomLevelTimer.value) {
          clearTimeout(zoomLevelTimer.value);
        }
        zoomLevelTimer.value = setTimeout(() => {
          showZoomLevel.value = false;
          zoomLevelTimer.value = null;
        }, 2e3);
      }
    };
    const handleBlobSrcChange = (blobSrc) => {
      currentBlobSrc.value = blobSrc;
    };
    const handleImageLoaded = () => {
      showZoomLevel.value = true;
      if (zoomLevelTimer.value) {
        clearTimeout(zoomLevelTimer.value);
      }
      zoomLevelTimer.value = setTimeout(() => {
        showZoomLevel.value = false;
        zoomLevelTimer.value = null;
      }, 2e3);
    };
    const processCurrentLivePhoto = async () => {
      const photo = currentPhoto.value;
      if (!photo || !photo.isLivePhoto || !photo.livePhotoVideoUrl) return;
      try {
        const blob = await convertMovToMp4(photo.livePhotoVideoUrl, photo.id);
        if (blob) {
          livePhotoVideoBlob.value = blob;
          if (livePhotoVideoBlobUrl.value) {
            URL.revokeObjectURL(livePhotoVideoBlobUrl.value);
          }
          livePhotoVideoBlobUrl.value = URL.createObjectURL(blob);
        }
      } catch (error) {
        console.error("Failed to process LivePhoto in viewer:", error);
      }
    };
    const playLivePhotoVideo = () => {
      if (!livePhotoVideoRef.value || !livePhotoVideoBlobUrl.value) return;
      livePhotoVideoRef.value.currentTime = 0;
      isLivePhotoPlaying.value = true;
      if (isMobile.value && "vibrate" in void 0) {
        (void 0).vibrate(50);
      }
      livePhotoVideoRef.value?.play().catch((error) => {
        console.warn("Failed to play LivePhoto video in viewer:", error);
        isLivePhotoPlaying.value = false;
      });
    };
    const stopLivePhotoVideo = () => {
      const wasPlaying = isLivePhotoPlaying.value;
      if (livePhotoVideoRef.value && !livePhotoVideoRef.value.paused) {
        livePhotoVideoRef.value?.pause();
        livePhotoVideoRef.value.currentTime = 0;
        if (isMobile.value && wasPlaying && "vibrate" in void 0) {
          (void 0).vibrate(25);
        }
      }
      isLivePhotoPlaying.value = false;
    };
    const handleLivePhotoMouseEnter = () => {
      if (!isMobile.value && currentPhoto.value?.isLivePhoto && livePhotoVideoBlobUrl.value) {
        isLivePhotoHovering.value = true;
        playLivePhotoVideo();
      }
    };
    const handleLivePhotoMouseLeave = () => {
      if (!isMobile.value) {
        isLivePhotoHovering.value = false;
        stopLivePhotoVideo();
      }
    };
    const handleLivePhotoTouchStart = (event) => {
      if (isMobile.value && currentPhoto.value?.isLivePhoto && livePhotoVideoBlobUrl.value) {
        touchCount.value = event.touches.length;
        if (event.touches.length === 1) {
          const target = event.target;
          const isInteractiveElement = target.closest("button") || target.closest('[role="button"]') || target.classList.contains("pointer-events-auto");
          if (!isInteractiveElement) {
            event.preventDefault();
            isLivePhotoTouching.value = true;
            longPressTimer.value = setTimeout(() => {
              if (isLivePhotoTouching.value && touchCount.value === 1 && !isImageZoomed.value) {
                playLivePhotoVideo();
              }
            }, 350);
          }
        }
      }
    };
    const handleLivePhotoTouchEnd = () => {
      if (isMobile.value) {
        touchCount.value = 0;
        isLivePhotoTouching.value = false;
        if (longPressTimer.value) {
          clearTimeout(longPressTimer.value);
          longPressTimer.value = null;
        }
        stopLivePhotoVideo();
      }
    };
    const handleLivePhotoTouchMove = (event) => {
      if (isMobile.value && isLivePhotoTouching.value) {
        touchCount.value = event.touches.length;
        if (event.touches.length > 1) {
          isLivePhotoTouching.value = false;
          if (longPressTimer.value) {
            clearTimeout(longPressTimer.value);
            longPressTimer.value = null;
          }
          stopLivePhotoVideo();
        }
      }
    };
    const handleLivePhotoVideoEnded = () => {
      if (isMobile.value && "vibrate" in void 0) {
        (void 0).vibrate(30);
      }
      if (livePhotoVideoRef.value) {
        livePhotoVideoRef.value.currentTime = 0;
      }
    };
    const clearConfetti = /* @__PURE__ */ useDebounceFn(() => {
      confettiIcon.value = null;
    }, 1600);
    const handleReactionSelect = async (reactionId, iconName) => {
      if (!currentPhoto.value) return;
      isLoadingReaction.value = true;
      try {
        if (selectedReaction.value === reactionId) {
          await $fetch(`/api/photos/${currentPhoto.value.id}/reactions`, {
            method: "DELETE"
          });
          selectedReaction.value = null;
          if (reactionCounts.value[reactionId]) {
            reactionCounts.value[reactionId]--;
          }
        } else {
          const oldReaction = selectedReaction.value;
          if (oldReaction && reactionCounts.value[oldReaction] !== void 0) {
            reactionCounts.value[oldReaction]--;
          }
          await $fetch(`/api/photos/${currentPhoto.value.id}/reactions`, {
            method: "POST",
            body: { reactionType: reactionId }
          });
          selectedReaction.value = reactionId;
          reactionCounts.value[reactionId] = (reactionCounts.value[reactionId] || 0) + 1;
          confettiIcon.value = iconName;
          confettiTriggerCount.value++;
          clearConfetti();
        }
      } catch (error) {
        console.error("Failed to update reaction:", error);
        if (error?.statusCode === 429) {
          toast.add({
            icon: "tabler:alert-circle",
            title: "表态失败",
            description: "操作过于频繁，请稍后再试",
            color: "warning"
          });
        } else {
          toast.add({
            icon: "tabler:alert-circle",
            title: "表态失败",
            description: error instanceof Error ? error.message : "未知错误",
            color: "warning"
          });
        }
      } finally {
        isLoadingReaction.value = false;
      }
      showReactionPicker.value = false;
    };
    const toggleReactionPicker = () => {
      showReactionPicker.value = !showReactionPicker.value;
    };
    watch(
      () => currentPhoto.value?.id,
      (newPhotoId) => {
        if (newPhotoId) {
          loadPhotoReactions(newPhotoId);
        }
      },
      { immediate: true }
    );
    defineShortcuts({
      escape: () => {
        emit("close");
      }
    });
    const swiperModules = [Navigation, Keyboard, Virtual];
    return (_ctx, _push, _parent, _attrs) => {
      const _component_ThumbHash = __nuxt_component_0$2;
      const _component_PhotoLivePhotoIndicator = __nuxt_component_1$2;
      const _component_Icon = __nuxt_component_0$4;
      const _component_GlassButton = __nuxt_component_0$1;
      const _component_PhotoShareModal = __nuxt_component_4;
      ssrRenderTeleport(_push, (_push2) => {
        _push2(ssrRenderComponent(unref(_sfc_main$n), null, {
          default: withCtx((_2, _push3, _parent2, _scopeId) => {
            if (_push3) {
              if (__props.isOpen) {
                _push3(ssrRenderComponent(unref(motion).div, {
                  initial: { opacity: 0 },
                  animate: { opacity: 1 },
                  exit: { opacity: 0 },
                  transition: { duration: 0.3 },
                  class: "fixed inset-0 bg-white/50 dark:bg-black/50 backdrop-blur-2xl z-50",
                  onClick: ($event) => emit("close")
                }, null, _parent2, _scopeId));
              } else {
                _push3(`<!---->`);
              }
            } else {
              return [
                __props.isOpen ? (openBlock(), createBlock(unref(motion).div, {
                  key: 0,
                  initial: { opacity: 0 },
                  animate: { opacity: 1 },
                  exit: { opacity: 0 },
                  transition: { duration: 0.3 },
                  class: "fixed inset-0 bg-white/50 dark:bg-black/50 backdrop-blur-2xl z-50",
                  onClick: ($event) => emit("close")
                }, null, 8, ["onClick"])) : createCommentVNode("", true)
              ];
            }
          }),
          _: 1
        }, _parent));
        _push2(ssrRenderComponent(unref(_sfc_main$n), { mode: "sync" }, {
          default: withCtx((_2, _push3, _parent2, _scopeId) => {
            if (_push3) {
              if (__props.isOpen && unref(currentPhoto)?.thumbnailHash) {
                _push3(ssrRenderComponent(unref(motion).div, {
                  key: unref(currentPhoto).id,
                  initial: { opacity: 0 },
                  animate: { opacity: 1 },
                  exit: { opacity: 0 },
                  transition: { duration: 0.3 },
                  class: "fixed inset-0 z-40"
                }, {
                  default: withCtx((_22, _push4, _parent3, _scopeId2) => {
                    if (_push4) {
                      _push4(ssrRenderComponent(_component_ThumbHash, {
                        thumbhash: unref(currentPhoto).thumbnailHash,
                        class: "w-full h-full scale-110"
                      }, null, _parent3, _scopeId2));
                    } else {
                      return [
                        createVNode(_component_ThumbHash, {
                          thumbhash: unref(currentPhoto).thumbnailHash,
                          class: "w-full h-full scale-110"
                        }, null, 8, ["thumbhash"])
                      ];
                    }
                  }),
                  _: 1
                }, _parent2, _scopeId));
              } else {
                _push3(`<!---->`);
              }
            } else {
              return [
                __props.isOpen && unref(currentPhoto)?.thumbnailHash ? (openBlock(), createBlock(unref(motion).div, {
                  key: unref(currentPhoto).id,
                  initial: { opacity: 0 },
                  animate: { opacity: 1 },
                  exit: { opacity: 0 },
                  transition: { duration: 0.3 },
                  class: "fixed inset-0 z-40"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_ThumbHash, {
                      thumbhash: unref(currentPhoto).thumbnailHash,
                      class: "w-full h-full scale-110"
                    }, null, 8, ["thumbhash"])
                  ]),
                  _: 1
                })) : createCommentVNode("", true)
              ];
            }
          }),
          _: 1
        }, _parent));
        _push2(ssrRenderComponent(unref(_sfc_main$n), null, {
          default: withCtx((_2, _push3, _parent2, _scopeId) => {
            if (_push3) {
              if (__props.isOpen) {
                _push3(ssrRenderComponent(unref(motion).div, {
                  ref_key: "containerRef",
                  ref: containerRef,
                  initial: { opacity: 0 },
                  animate: { opacity: 1 },
                  exit: { opacity: 0 },
                  transition: { duration: 0.3 },
                  class: "fixed inset-0 z-50 flex items-center justify-center",
                  style: { touchAction: unref(isMobile) ? "manipulation" : "none" },
                  onClick: ($event) => emit("close")
                }, {
                  default: withCtx((_22, _push4, _parent3, _scopeId2) => {
                    if (_push4) {
                      _push4(`<div class="${ssrRenderClass([unref(isMobile) ? "flex-col" : "flex-row", "flex w-full h-full"])}" data-v-3a8c3532${_scopeId2}><div class="z-10 flex min-h-0 min-w-0 flex-1 flex-col" data-v-3a8c3532${_scopeId2}><div class="group relative flex min-h-0 min-w-0 flex-1" data-v-3a8c3532${_scopeId2}>`);
                      _push4(ssrRenderComponent(unref(motion).div, {
                        initial: { opacity: 0 },
                        animate: { opacity: 1 },
                        exit: { opacity: 0 },
                        transition: { duration: 0.3 },
                        class: [
                          "absolute z-30 flex items-center justify-between",
                          unref(isMobile) ? "top-2 right-2 left-2" : "top-4 right-4 left-4"
                        ]
                      }, {
                        default: withCtx((_3, _push5, _parent4, _scopeId3) => {
                          if (_push5) {
                            _push5(`<div class="flex items-center gap-1" data-v-3a8c3532${_scopeId3}>`);
                            if (unref(currentPhoto)?.isLivePhoto) {
                              _push5(ssrRenderComponent(_component_PhotoLivePhotoIndicator, {
                                class: unref(isMobile) ? "cursor-default" : "cursor-pointer",
                                photo: unref(currentPhoto),
                                "is-video-playing": unref(isLivePhotoPlaying),
                                "processing-state": unref(livePhotoProcessingState)?.value || null,
                                onMouseenter: handleLivePhotoMouseEnter,
                                onMouseleave: handleLivePhotoMouseLeave
                              }, null, _parent4, _scopeId3));
                            } else {
                              _push5(`<!---->`);
                            }
                            if (unref(currentPhoto)?.isLivePhoto) {
                              _push5(`<div class="${ssrRenderClass([unref(isMobile) ? "cursor-default" : "cursor-pointer", "pointer-events-auto backdrop-blur-md bg-black/40 text-white rounded-full p-1 text-[13px] font-bold flex items-center gap-0.5 leading-0 select-none"])}" data-v-3a8c3532${_scopeId3}>`);
                              _push5(ssrRenderComponent(_component_Icon, {
                                name: unref(isLivePhotoMuted) ? "tabler:volume-off" : "tabler:volume",
                                class: "size-[17px]"
                              }, null, _parent4, _scopeId3));
                              _push5(`</div>`);
                            } else {
                              _push5(`<!---->`);
                            }
                            _push5(`</div><div class="flex items-center gap-2" data-v-3a8c3532${_scopeId3}>`);
                            if (unref(isMobile)) {
                              _push5(ssrRenderComponent(_component_GlassButton, {
                                icon: "tabler:info-circle",
                                class: !unref(showExifPanel) ? "" : "bg-black/20 hover:bg-black/30 text-white",
                                size: "sm",
                                rounded: "",
                                onClick: ($event) => showExifPanel.value = !unref(showExifPanel)
                              }, null, _parent4, _scopeId3));
                            } else {
                              _push5(`<!---->`);
                            }
                            _push5(ssrRenderComponent(_component_GlassButton, {
                              icon: "tabler:share-3",
                              size: "sm",
                              rounded: "",
                              onClick: ($event) => showShareModal.value = true
                            }, null, _parent4, _scopeId3));
                            _push5(ssrRenderComponent(_component_GlassButton, {
                              icon: "tabler:x",
                              size: "sm",
                              rounded: "",
                              onClick: ($event) => emit("close")
                            }, null, _parent4, _scopeId3));
                            _push5(`</div>`);
                          } else {
                            return [
                              createVNode("div", { class: "flex items-center gap-1" }, [
                                unref(currentPhoto)?.isLivePhoto ? (openBlock(), createBlock(_component_PhotoLivePhotoIndicator, {
                                  key: 0,
                                  class: unref(isMobile) ? "cursor-default" : "cursor-pointer",
                                  photo: unref(currentPhoto),
                                  "is-video-playing": unref(isLivePhotoPlaying),
                                  "processing-state": unref(livePhotoProcessingState)?.value || null,
                                  onMouseenter: handleLivePhotoMouseEnter,
                                  onMouseleave: handleLivePhotoMouseLeave
                                }, null, 8, ["class", "photo", "is-video-playing", "processing-state"])) : createCommentVNode("", true),
                                unref(currentPhoto)?.isLivePhoto ? (openBlock(), createBlock("div", {
                                  key: 1,
                                  class: ["pointer-events-auto backdrop-blur-md bg-black/40 text-white rounded-full p-1 text-[13px] font-bold flex items-center gap-0.5 leading-0 select-none", unref(isMobile) ? "cursor-default" : "cursor-pointer"],
                                  onClick: ($event) => isLivePhotoMuted.value = !unref(isLivePhotoMuted)
                                }, [
                                  createVNode(_component_Icon, {
                                    name: unref(isLivePhotoMuted) ? "tabler:volume-off" : "tabler:volume",
                                    class: "size-[17px]"
                                  }, null, 8, ["name"])
                                ], 10, ["onClick"])) : createCommentVNode("", true)
                              ]),
                              createVNode("div", { class: "flex items-center gap-2" }, [
                                unref(isMobile) ? (openBlock(), createBlock(_component_GlassButton, {
                                  key: 0,
                                  icon: "tabler:info-circle",
                                  class: !unref(showExifPanel) ? "" : "bg-black/20 hover:bg-black/30 text-white",
                                  size: "sm",
                                  rounded: "",
                                  onClick: ($event) => showExifPanel.value = !unref(showExifPanel)
                                }, null, 8, ["class", "onClick"])) : createCommentVNode("", true),
                                createVNode(_component_GlassButton, {
                                  icon: "tabler:share-3",
                                  size: "sm",
                                  rounded: "",
                                  onClick: ($event) => showShareModal.value = true
                                }, null, 8, ["onClick"]),
                                createVNode(_component_GlassButton, {
                                  icon: "tabler:x",
                                  size: "sm",
                                  rounded: "",
                                  onClick: ($event) => emit("close")
                                }, null, 8, ["onClick"])
                              ])
                            ];
                          }
                        }),
                        _: 1
                      }, _parent3, _scopeId2));
                      _push4(ssrRenderComponent(LoadingIndicator, {
                        ref_key: "loadingIndicatorRef",
                        ref: loadingIndicatorRef
                      }, null, _parent3, _scopeId2));
                      _push4(ssrRenderComponent(unref(Swiper), {
                        modules: swiperModules,
                        "space-between": 0,
                        "slides-per-view": 1,
                        "initial-slide": __props.currentIndex,
                        virtual: true,
                        keyboard: {
                          enabled: true,
                          onlyInViewport: true
                        },
                        class: "h-full w-full",
                        style: { touchAction: unref(isMobile) ? "pan-x" : "pan-y" },
                        onSwiper: handleSwiperInit,
                        onSlideChange: handleSlideChange
                      }, {
                        default: withCtx((_3, _push5, _parent4, _scopeId3) => {
                          if (_push5) {
                            _push5(`<!--[-->`);
                            ssrRenderList(__props.photos, (photo, index2) => {
                              _push5(ssrRenderComponent(unref(SwiperSlide), {
                                key: photo.id,
                                "virtual-index": index2,
                                class: "flex items-center justify-center"
                              }, {
                                default: withCtx((_4, _push6, _parent5, _scopeId4) => {
                                  if (_push6) {
                                    _push6(ssrRenderComponent(unref(motion).div, {
                                      initial: { opacity: 0.5, scale: 0.95 },
                                      animate: { opacity: 1, scale: 1 },
                                      exit: { opacity: 0, scale: 0.95 },
                                      transition: { type: "spring", duration: 0.4, bounce: 0 },
                                      class: "relative flex h-full w-full items-center justify-center",
                                      style: { "user-select": "none", "-webkit-user-select": "none", "-webkit-touch-callout": "none", "-webkit-tap-highlight-color": "transparent" },
                                      onTouchstart: handleLivePhotoTouchStart,
                                      onTouchmove: handleLivePhotoTouchMove,
                                      onTouchend: handleLivePhotoTouchEnd,
                                      onTouchcancel: handleLivePhotoTouchEnd,
                                      onContextmenu: () => {
                                      }
                                    }, {
                                      default: withCtx((_5, _push7, _parent6, _scopeId5) => {
                                        if (_push7) {
                                          _push7(ssrRenderComponent(ProgressiveImage, {
                                            class: ["h-full w-full object-contain transition-opacity duration-400", {
                                              "opacity-0": unref(isLivePhotoPlaying) && unref(currentPhoto)?.isLivePhoto
                                            }],
                                            "loading-indicator-ref": unref(loadingIndicatorRef) || null,
                                            "is-current-image": index2 === __props.currentIndex,
                                            src: photo.originalUrl,
                                            "thumbnail-src": photo.thumbnailUrl,
                                            thumbhash: photo.thumbnailHash,
                                            alt: photo.title || "",
                                            width: index2 === __props.currentIndex ? unref(currentPhoto)?.width ?? void 0 : void 0,
                                            height: index2 === __props.currentIndex ? unref(currentPhoto)?.height ?? void 0 : void 0,
                                            "enable-pan": index2 === __props.currentIndex ? !unref(isMobile) || unref(isImageZoomed) : true,
                                            "enable-zoom": true,
                                            "on-zoom-change": index2 === __props.currentIndex ? handleZoomChange : void 0,
                                            "on-blob-src-change": index2 === __props.currentIndex ? handleBlobSrcChange : void 0,
                                            "on-image-loaded": index2 === __props.currentIndex ? handleImageLoaded : void 0,
                                            "is-live-photo": photo.isLivePhoto === 1,
                                            "live-photo-video-url": photo.livePhotoVideoUrl || void 0
                                          }, null, _parent6, _scopeId5));
                                          if (photo.isLivePhoto && index2 === __props.currentIndex && unref(livePhotoVideoBlobUrl)) {
                                            _push7(ssrRenderComponent(unref(motion).video, {
                                              ref_for: true,
                                              ref: (el) => {
                                                if (index2 === __props.currentIndex) livePhotoVideoRef.value = el;
                                              },
                                              src: unref(livePhotoVideoBlobUrl),
                                              class: "absolute inset-0 w-full h-full object-contain pointer-events-none select-none touch-none",
                                              muted: unref(isLivePhotoMuted),
                                              playsinline: "",
                                              preload: "metadata",
                                              initial: { opacity: 0 },
                                              animate: {
                                                opacity: unref(isLivePhotoPlaying) ? 1 : 0
                                              },
                                              transition: {
                                                duration: 0.4,
                                                ease: [0.25, 0.1, 0.25, 1],
                                                delay: unref(isLivePhotoPlaying) ? 0.1 : 0
                                              },
                                              onEnded: handleLivePhotoVideoEnded,
                                              onContextmenu: () => {
                                              }
                                            }, null, _parent6, _scopeId5));
                                          } else {
                                            _push7(`<!---->`);
                                          }
                                          _push7(ssrRenderComponent(unref(_sfc_main$n), null, {
                                            default: withCtx((_6, _push8, _parent7, _scopeId6) => {
                                              if (_push8) {
                                                if (unref(showZoomLevel) && unref(zoomLevel) > 0) {
                                                  _push8(ssrRenderComponent(unref(motion).div, {
                                                    initial: { opacity: 0, y: 10 },
                                                    animate: { opacity: 1, y: 0 },
                                                    exit: { opacity: 0, y: 10 },
                                                    transition: { duration: 0.2 },
                                                    class: "absolute bottom-4 left-4 z-20 bg-black/40 backdrop-blur-3xl rounded-xl border border-white/10 px-4 py-2 shadow-2xl"
                                                  }, {
                                                    default: withCtx((_7, _push9, _parent8, _scopeId7) => {
                                                      if (_push9) {
                                                        _push9(`<span class="text-white font-medium" data-v-3a8c3532${_scopeId7}>${ssrInterpolate(unref(zoomLevel))}x</span>`);
                                                      } else {
                                                        return [
                                                          createVNode("span", { class: "text-white font-medium" }, toDisplayString$1(unref(zoomLevel)) + "x", 1)
                                                        ];
                                                      }
                                                    }),
                                                    _: 2
                                                  }, _parent7, _scopeId6));
                                                } else {
                                                  _push8(`<!---->`);
                                                }
                                              } else {
                                                return [
                                                  unref(showZoomLevel) && unref(zoomLevel) > 0 ? (openBlock(), createBlock(unref(motion).div, {
                                                    key: 0,
                                                    initial: { opacity: 0, y: 10 },
                                                    animate: { opacity: 1, y: 0 },
                                                    exit: { opacity: 0, y: 10 },
                                                    transition: { duration: 0.2 },
                                                    class: "absolute bottom-4 left-4 z-20 bg-black/40 backdrop-blur-3xl rounded-xl border border-white/10 px-4 py-2 shadow-2xl"
                                                  }, {
                                                    default: withCtx(() => [
                                                      createVNode("span", { class: "text-white font-medium" }, toDisplayString$1(unref(zoomLevel)) + "x", 1)
                                                    ]),
                                                    _: 1
                                                  })) : createCommentVNode("", true)
                                                ];
                                              }
                                            }),
                                            _: 2
                                          }, _parent6, _scopeId5));
                                          _push7(ssrRenderComponent(unref(_sfc_main$n), null, {
                                            default: withCtx((_6, _push8, _parent7, _scopeId6) => {
                                              if (_push8) {
                                                if (!unref(isImageZoomed) && !unref(isLivePhotoPlaying)) {
                                                  _push8(ssrRenderComponent(unref(motion).div, {
                                                    initial: { opacity: 0, scale: 0.95 },
                                                    animate: { opacity: 0.6, scale: 1 },
                                                    exit: { opacity: 0, scale: 0.95 },
                                                    transition: { duration: 0.2 },
                                                    class: "absolute bottom-6 left-1/2 z-20 -translate-x-1/2 bg-black/50 rounded-lg border border-white/10 px-2 py-1 shadow-2xl text-white text-xs font-bold"
                                                  }, {
                                                    default: withCtx((_7, _push9, _parent8, _scopeId7) => {
                                                      if (_push9) {
                                                        if (unref(currentPhoto)?.isLivePhoto && unref(isMobile)) {
                                                          _push9(`<span data-v-3a8c3532${_scopeId7}>${ssrInterpolate(_ctx.$t("viewer.hint.livePhoto.mobile"))}</span>`);
                                                        } else if (unref(currentPhoto)?.isLivePhoto && !unref(isMobile)) {
                                                          _push9(`<span data-v-3a8c3532${_scopeId7}>${ssrInterpolate(_ctx.$t("viewer.hint.livePhoto.desktop"))}</span>`);
                                                        } else {
                                                          _push9(`<span data-v-3a8c3532${_scopeId7}>${ssrInterpolate(unref(isMobile) ? _ctx.$t("viewer.hint.mobile") : _ctx.$t("viewer.hint.desktop"))}</span>`);
                                                        }
                                                      } else {
                                                        return [
                                                          unref(currentPhoto)?.isLivePhoto && unref(isMobile) ? (openBlock(), createBlock("span", { key: 0 }, toDisplayString$1(_ctx.$t("viewer.hint.livePhoto.mobile")), 1)) : unref(currentPhoto)?.isLivePhoto && !unref(isMobile) ? (openBlock(), createBlock("span", { key: 1 }, toDisplayString$1(_ctx.$t("viewer.hint.livePhoto.desktop")), 1)) : (openBlock(), createBlock("span", { key: 2 }, toDisplayString$1(unref(isMobile) ? _ctx.$t("viewer.hint.mobile") : _ctx.$t("viewer.hint.desktop")), 1))
                                                        ];
                                                      }
                                                    }),
                                                    _: 2
                                                  }, _parent7, _scopeId6));
                                                } else {
                                                  _push8(`<!---->`);
                                                }
                                              } else {
                                                return [
                                                  !unref(isImageZoomed) && !unref(isLivePhotoPlaying) ? (openBlock(), createBlock(unref(motion).div, {
                                                    key: 0,
                                                    initial: { opacity: 0, scale: 0.95 },
                                                    animate: { opacity: 0.6, scale: 1 },
                                                    exit: { opacity: 0, scale: 0.95 },
                                                    transition: { duration: 0.2 },
                                                    class: "absolute bottom-6 left-1/2 z-20 -translate-x-1/2 bg-black/50 rounded-lg border border-white/10 px-2 py-1 shadow-2xl text-white text-xs font-bold"
                                                  }, {
                                                    default: withCtx(() => [
                                                      unref(currentPhoto)?.isLivePhoto && unref(isMobile) ? (openBlock(), createBlock("span", { key: 0 }, toDisplayString$1(_ctx.$t("viewer.hint.livePhoto.mobile")), 1)) : unref(currentPhoto)?.isLivePhoto && !unref(isMobile) ? (openBlock(), createBlock("span", { key: 1 }, toDisplayString$1(_ctx.$t("viewer.hint.livePhoto.desktop")), 1)) : (openBlock(), createBlock("span", { key: 2 }, toDisplayString$1(unref(isMobile) ? _ctx.$t("viewer.hint.mobile") : _ctx.$t("viewer.hint.desktop")), 1))
                                                    ]),
                                                    _: 1
                                                  })) : createCommentVNode("", true)
                                                ];
                                              }
                                            }),
                                            _: 2
                                          }, _parent6, _scopeId5));
                                          _push7(ssrRenderComponent(unref(_sfc_main$n), null, {
                                            default: withCtx((_6, _push8, _parent7, _scopeId6) => {
                                              if (_push8) {
                                                if (!unref(isImageZoomed) && !unref(isLivePhotoPlaying)) {
                                                  _push8(ssrRenderComponent(unref(motion).div, {
                                                    initial: { opacity: 0, scale: 0.8, y: 20 },
                                                    animate: { opacity: 1, scale: 1, y: 0 },
                                                    exit: { opacity: 0, scale: 0.8, y: 20 },
                                                    transition: {
                                                      type: "spring",
                                                      stiffness: 300,
                                                      damping: 20,
                                                      delay: 0.1
                                                    },
                                                    class: "absolute bottom-4 right-4 z-20"
                                                  }, {
                                                    default: withCtx((_7, _push9, _parent8, _scopeId7) => {
                                                      if (_push9) {
                                                        _push9(`<div class="relative" data-v-3a8c3532${_scopeId7}>`);
                                                        _push9(ssrRenderComponent(ReactionPicker, {
                                                          "is-open": unref(showReactionPicker),
                                                          "selected-reaction": unref(selectedReaction),
                                                          "reaction-counts": unref(reactionCounts),
                                                          onSelect: handleReactionSelect,
                                                          onClose: ($event) => showReactionPicker.value = false
                                                        }, null, _parent8, _scopeId7));
                                                        if (unref(confettiIcon)) {
                                                          _push9(ssrRenderComponent(ReactionConfetti, {
                                                            "icon-name": unref(confettiIcon),
                                                            "trigger-count": unref(confettiTriggerCount)
                                                          }, null, _parent8, _scopeId7));
                                                        } else {
                                                          _push9(`<!---->`);
                                                        }
                                                        _push9(ssrRenderComponent(unref(motion).button, {
                                                          type: "button",
                                                          initial: { scale: 0.8, opacity: 0 },
                                                          animate: {
                                                            scale: unref(showReactionPicker) ? 0.92 : 1,
                                                            opacity: 1,
                                                            transition: unref(showReactionPicker) ? { duration: 0.2, ease: [0.25, 0.1, 0.25, 1] } : {
                                                              type: "spring",
                                                              stiffness: 300,
                                                              damping: 25,
                                                              mass: 0.8
                                                            }
                                                          },
                                                          "while-hover": {
                                                            scale: unref(showReactionPicker) ? 0.95 : 1.05
                                                          },
                                                          "while-tap": { scale: 0.88 },
                                                          class: [
                                                            "pointer-events-auto flex items-center justify-center gap-2 cursor-pointer",
                                                            "px-4 h-11 rounded-full",
                                                            "backdrop-blur-xl border shadow-lg",
                                                            "transition-all duration-200",
                                                            unref(selectedReaction) ? "bg-blue-500/90 border-blue-400/50 text-white shadow-blue-500/30" : "bg-white/90 dark:bg-neutral-800/90 border-neutral-200/50 dark:border-white/10 text-neutral-700 dark:text-white/80 shadow-black/10 dark:shadow-black/30",
                                                            "hover:shadow-xl"
                                                          ],
                                                          onClick: toggleReactionPicker
                                                        }, {
                                                          default: withCtx((_8, _push10, _parent9, _scopeId8) => {
                                                            if (_push10) {
                                                              if (unref(selectedReaction) && unref(currentReactionIcon)) {
                                                                _push10(ssrRenderComponent(_component_Icon, {
                                                                  name: unref(currentReactionIcon),
                                                                  class: "text-xl leading-none select-none"
                                                                }, null, _parent9, _scopeId8));
                                                              } else {
                                                                _push10(ssrRenderComponent(_component_Icon, {
                                                                  name: "tabler:mood-smile",
                                                                  class: "text-xl"
                                                                }, null, _parent9, _scopeId8));
                                                              }
                                                              _push10(`<div class="flex flex-col items-start gap-0.5" data-v-3a8c3532${_scopeId8}><span class="text-sm font-medium leading-none" data-v-3a8c3532${_scopeId8}>${ssrInterpolate(unref(selectedReaction) ? _ctx.$t("viewer.reaction.change") : _ctx.$t("viewer.reaction.add"))}</span>`);
                                                              if (unref(totalReactions) > 0) {
                                                                _push10(`<span class="text-[10px] leading-none opacity-70" data-v-3a8c3532${_scopeId8}>${ssrInterpolate(_ctx.$t(
                                                                  "viewer.reaction.count",
                                                                  { count: unref(totalReactions) },
                                                                  unref(totalReactions)
                                                                ))}</span>`);
                                                              } else {
                                                                _push10(`<!---->`);
                                                              }
                                                              _push10(`</div>`);
                                                            } else {
                                                              return [
                                                                unref(selectedReaction) && unref(currentReactionIcon) ? (openBlock(), createBlock(_component_Icon, {
                                                                  key: 0,
                                                                  name: unref(currentReactionIcon),
                                                                  class: "text-xl leading-none select-none"
                                                                }, null, 8, ["name"])) : (openBlock(), createBlock(_component_Icon, {
                                                                  key: 1,
                                                                  name: "tabler:mood-smile",
                                                                  class: "text-xl"
                                                                })),
                                                                createVNode("div", { class: "flex flex-col items-start gap-0.5" }, [
                                                                  createVNode("span", { class: "text-sm font-medium leading-none" }, toDisplayString$1(unref(selectedReaction) ? _ctx.$t("viewer.reaction.change") : _ctx.$t("viewer.reaction.add")), 1),
                                                                  unref(totalReactions) > 0 ? (openBlock(), createBlock("span", {
                                                                    key: 0,
                                                                    class: "text-[10px] leading-none opacity-70"
                                                                  }, toDisplayString$1(_ctx.$t(
                                                                    "viewer.reaction.count",
                                                                    { count: unref(totalReactions) },
                                                                    unref(totalReactions)
                                                                  )), 1)) : createCommentVNode("", true)
                                                                ])
                                                              ];
                                                            }
                                                          }),
                                                          _: 2
                                                        }, _parent8, _scopeId7));
                                                        _push9(`</div>`);
                                                      } else {
                                                        return [
                                                          createVNode("div", { class: "relative" }, [
                                                            createVNode(ReactionPicker, {
                                                              "is-open": unref(showReactionPicker),
                                                              "selected-reaction": unref(selectedReaction),
                                                              "reaction-counts": unref(reactionCounts),
                                                              onSelect: handleReactionSelect,
                                                              onClose: ($event) => showReactionPicker.value = false
                                                            }, null, 8, ["is-open", "selected-reaction", "reaction-counts", "onClose"]),
                                                            unref(confettiIcon) ? (openBlock(), createBlock(ReactionConfetti, {
                                                              key: 0,
                                                              "icon-name": unref(confettiIcon),
                                                              "trigger-count": unref(confettiTriggerCount)
                                                            }, null, 8, ["icon-name", "trigger-count"])) : createCommentVNode("", true),
                                                            createVNode(unref(motion).button, {
                                                              type: "button",
                                                              initial: { scale: 0.8, opacity: 0 },
                                                              animate: {
                                                                scale: unref(showReactionPicker) ? 0.92 : 1,
                                                                opacity: 1,
                                                                transition: unref(showReactionPicker) ? { duration: 0.2, ease: [0.25, 0.1, 0.25, 1] } : {
                                                                  type: "spring",
                                                                  stiffness: 300,
                                                                  damping: 25,
                                                                  mass: 0.8
                                                                }
                                                              },
                                                              "while-hover": {
                                                                scale: unref(showReactionPicker) ? 0.95 : 1.05
                                                              },
                                                              "while-tap": { scale: 0.88 },
                                                              class: [
                                                                "pointer-events-auto flex items-center justify-center gap-2 cursor-pointer",
                                                                "px-4 h-11 rounded-full",
                                                                "backdrop-blur-xl border shadow-lg",
                                                                "transition-all duration-200",
                                                                unref(selectedReaction) ? "bg-blue-500/90 border-blue-400/50 text-white shadow-blue-500/30" : "bg-white/90 dark:bg-neutral-800/90 border-neutral-200/50 dark:border-white/10 text-neutral-700 dark:text-white/80 shadow-black/10 dark:shadow-black/30",
                                                                "hover:shadow-xl"
                                                              ],
                                                              onClick: toggleReactionPicker
                                                            }, {
                                                              default: withCtx(() => [
                                                                unref(selectedReaction) && unref(currentReactionIcon) ? (openBlock(), createBlock(_component_Icon, {
                                                                  key: 0,
                                                                  name: unref(currentReactionIcon),
                                                                  class: "text-xl leading-none select-none"
                                                                }, null, 8, ["name"])) : (openBlock(), createBlock(_component_Icon, {
                                                                  key: 1,
                                                                  name: "tabler:mood-smile",
                                                                  class: "text-xl"
                                                                })),
                                                                createVNode("div", { class: "flex flex-col items-start gap-0.5" }, [
                                                                  createVNode("span", { class: "text-sm font-medium leading-none" }, toDisplayString$1(unref(selectedReaction) ? _ctx.$t("viewer.reaction.change") : _ctx.$t("viewer.reaction.add")), 1),
                                                                  unref(totalReactions) > 0 ? (openBlock(), createBlock("span", {
                                                                    key: 0,
                                                                    class: "text-[10px] leading-none opacity-70"
                                                                  }, toDisplayString$1(_ctx.$t(
                                                                    "viewer.reaction.count",
                                                                    { count: unref(totalReactions) },
                                                                    unref(totalReactions)
                                                                  )), 1)) : createCommentVNode("", true)
                                                                ])
                                                              ]),
                                                              _: 1
                                                            }, 8, ["animate", "while-hover", "class"])
                                                          ])
                                                        ];
                                                      }
                                                    }),
                                                    _: 2
                                                  }, _parent7, _scopeId6));
                                                } else {
                                                  _push8(`<!---->`);
                                                }
                                              } else {
                                                return [
                                                  !unref(isImageZoomed) && !unref(isLivePhotoPlaying) ? (openBlock(), createBlock(unref(motion).div, {
                                                    key: 0,
                                                    initial: { opacity: 0, scale: 0.8, y: 20 },
                                                    animate: { opacity: 1, scale: 1, y: 0 },
                                                    exit: { opacity: 0, scale: 0.8, y: 20 },
                                                    transition: {
                                                      type: "spring",
                                                      stiffness: 300,
                                                      damping: 20,
                                                      delay: 0.1
                                                    },
                                                    class: "absolute bottom-4 right-4 z-20"
                                                  }, {
                                                    default: withCtx(() => [
                                                      createVNode("div", { class: "relative" }, [
                                                        createVNode(ReactionPicker, {
                                                          "is-open": unref(showReactionPicker),
                                                          "selected-reaction": unref(selectedReaction),
                                                          "reaction-counts": unref(reactionCounts),
                                                          onSelect: handleReactionSelect,
                                                          onClose: ($event) => showReactionPicker.value = false
                                                        }, null, 8, ["is-open", "selected-reaction", "reaction-counts", "onClose"]),
                                                        unref(confettiIcon) ? (openBlock(), createBlock(ReactionConfetti, {
                                                          key: 0,
                                                          "icon-name": unref(confettiIcon),
                                                          "trigger-count": unref(confettiTriggerCount)
                                                        }, null, 8, ["icon-name", "trigger-count"])) : createCommentVNode("", true),
                                                        createVNode(unref(motion).button, {
                                                          type: "button",
                                                          initial: { scale: 0.8, opacity: 0 },
                                                          animate: {
                                                            scale: unref(showReactionPicker) ? 0.92 : 1,
                                                            opacity: 1,
                                                            transition: unref(showReactionPicker) ? { duration: 0.2, ease: [0.25, 0.1, 0.25, 1] } : {
                                                              type: "spring",
                                                              stiffness: 300,
                                                              damping: 25,
                                                              mass: 0.8
                                                            }
                                                          },
                                                          "while-hover": {
                                                            scale: unref(showReactionPicker) ? 0.95 : 1.05
                                                          },
                                                          "while-tap": { scale: 0.88 },
                                                          class: [
                                                            "pointer-events-auto flex items-center justify-center gap-2 cursor-pointer",
                                                            "px-4 h-11 rounded-full",
                                                            "backdrop-blur-xl border shadow-lg",
                                                            "transition-all duration-200",
                                                            unref(selectedReaction) ? "bg-blue-500/90 border-blue-400/50 text-white shadow-blue-500/30" : "bg-white/90 dark:bg-neutral-800/90 border-neutral-200/50 dark:border-white/10 text-neutral-700 dark:text-white/80 shadow-black/10 dark:shadow-black/30",
                                                            "hover:shadow-xl"
                                                          ],
                                                          onClick: toggleReactionPicker
                                                        }, {
                                                          default: withCtx(() => [
                                                            unref(selectedReaction) && unref(currentReactionIcon) ? (openBlock(), createBlock(_component_Icon, {
                                                              key: 0,
                                                              name: unref(currentReactionIcon),
                                                              class: "text-xl leading-none select-none"
                                                            }, null, 8, ["name"])) : (openBlock(), createBlock(_component_Icon, {
                                                              key: 1,
                                                              name: "tabler:mood-smile",
                                                              class: "text-xl"
                                                            })),
                                                            createVNode("div", { class: "flex flex-col items-start gap-0.5" }, [
                                                              createVNode("span", { class: "text-sm font-medium leading-none" }, toDisplayString$1(unref(selectedReaction) ? _ctx.$t("viewer.reaction.change") : _ctx.$t("viewer.reaction.add")), 1),
                                                              unref(totalReactions) > 0 ? (openBlock(), createBlock("span", {
                                                                key: 0,
                                                                class: "text-[10px] leading-none opacity-70"
                                                              }, toDisplayString$1(_ctx.$t(
                                                                "viewer.reaction.count",
                                                                { count: unref(totalReactions) },
                                                                unref(totalReactions)
                                                              )), 1)) : createCommentVNode("", true)
                                                            ])
                                                          ]),
                                                          _: 1
                                                        }, 8, ["animate", "while-hover", "class"])
                                                      ])
                                                    ]),
                                                    _: 1
                                                  })) : createCommentVNode("", true)
                                                ];
                                              }
                                            }),
                                            _: 2
                                          }, _parent6, _scopeId5));
                                        } else {
                                          return [
                                            createVNode(ProgressiveImage, {
                                              class: ["h-full w-full object-contain transition-opacity duration-400", {
                                                "opacity-0": unref(isLivePhotoPlaying) && unref(currentPhoto)?.isLivePhoto
                                              }],
                                              "loading-indicator-ref": unref(loadingIndicatorRef) || null,
                                              "is-current-image": index2 === __props.currentIndex,
                                              src: photo.originalUrl,
                                              "thumbnail-src": photo.thumbnailUrl,
                                              thumbhash: photo.thumbnailHash,
                                              alt: photo.title || "",
                                              width: index2 === __props.currentIndex ? unref(currentPhoto)?.width ?? void 0 : void 0,
                                              height: index2 === __props.currentIndex ? unref(currentPhoto)?.height ?? void 0 : void 0,
                                              "enable-pan": index2 === __props.currentIndex ? !unref(isMobile) || unref(isImageZoomed) : true,
                                              "enable-zoom": true,
                                              "on-zoom-change": index2 === __props.currentIndex ? handleZoomChange : void 0,
                                              "on-blob-src-change": index2 === __props.currentIndex ? handleBlobSrcChange : void 0,
                                              "on-image-loaded": index2 === __props.currentIndex ? handleImageLoaded : void 0,
                                              "is-live-photo": photo.isLivePhoto === 1,
                                              "live-photo-video-url": photo.livePhotoVideoUrl || void 0
                                            }, null, 8, ["class", "loading-indicator-ref", "is-current-image", "src", "thumbnail-src", "thumbhash", "alt", "width", "height", "enable-pan", "on-zoom-change", "on-blob-src-change", "on-image-loaded", "is-live-photo", "live-photo-video-url"]),
                                            photo.isLivePhoto && index2 === __props.currentIndex && unref(livePhotoVideoBlobUrl) ? (openBlock(), createBlock(unref(motion).video, {
                                              key: 0,
                                              ref_for: true,
                                              ref: (el) => {
                                                if (index2 === __props.currentIndex) livePhotoVideoRef.value = el;
                                              },
                                              src: unref(livePhotoVideoBlobUrl),
                                              class: "absolute inset-0 w-full h-full object-contain pointer-events-none select-none touch-none",
                                              muted: unref(isLivePhotoMuted),
                                              playsinline: "",
                                              preload: "metadata",
                                              initial: { opacity: 0 },
                                              animate: {
                                                opacity: unref(isLivePhotoPlaying) ? 1 : 0
                                              },
                                              transition: {
                                                duration: 0.4,
                                                ease: [0.25, 0.1, 0.25, 1],
                                                delay: unref(isLivePhotoPlaying) ? 0.1 : 0
                                              },
                                              onEnded: handleLivePhotoVideoEnded,
                                              onContextmenu: withModifiers(() => {
                                              }, ["prevent"])
                                            }, null, 8, ["src", "muted", "animate", "transition", "onContextmenu"])) : createCommentVNode("", true),
                                            createVNode(unref(_sfc_main$n), null, {
                                              default: withCtx(() => [
                                                unref(showZoomLevel) && unref(zoomLevel) > 0 ? (openBlock(), createBlock(unref(motion).div, {
                                                  key: 0,
                                                  initial: { opacity: 0, y: 10 },
                                                  animate: { opacity: 1, y: 0 },
                                                  exit: { opacity: 0, y: 10 },
                                                  transition: { duration: 0.2 },
                                                  class: "absolute bottom-4 left-4 z-20 bg-black/40 backdrop-blur-3xl rounded-xl border border-white/10 px-4 py-2 shadow-2xl"
                                                }, {
                                                  default: withCtx(() => [
                                                    createVNode("span", { class: "text-white font-medium" }, toDisplayString$1(unref(zoomLevel)) + "x", 1)
                                                  ]),
                                                  _: 1
                                                })) : createCommentVNode("", true)
                                              ]),
                                              _: 1
                                            }),
                                            createVNode(unref(_sfc_main$n), null, {
                                              default: withCtx(() => [
                                                !unref(isImageZoomed) && !unref(isLivePhotoPlaying) ? (openBlock(), createBlock(unref(motion).div, {
                                                  key: 0,
                                                  initial: { opacity: 0, scale: 0.95 },
                                                  animate: { opacity: 0.6, scale: 1 },
                                                  exit: { opacity: 0, scale: 0.95 },
                                                  transition: { duration: 0.2 },
                                                  class: "absolute bottom-6 left-1/2 z-20 -translate-x-1/2 bg-black/50 rounded-lg border border-white/10 px-2 py-1 shadow-2xl text-white text-xs font-bold"
                                                }, {
                                                  default: withCtx(() => [
                                                    unref(currentPhoto)?.isLivePhoto && unref(isMobile) ? (openBlock(), createBlock("span", { key: 0 }, toDisplayString$1(_ctx.$t("viewer.hint.livePhoto.mobile")), 1)) : unref(currentPhoto)?.isLivePhoto && !unref(isMobile) ? (openBlock(), createBlock("span", { key: 1 }, toDisplayString$1(_ctx.$t("viewer.hint.livePhoto.desktop")), 1)) : (openBlock(), createBlock("span", { key: 2 }, toDisplayString$1(unref(isMobile) ? _ctx.$t("viewer.hint.mobile") : _ctx.$t("viewer.hint.desktop")), 1))
                                                  ]),
                                                  _: 1
                                                })) : createCommentVNode("", true)
                                              ]),
                                              _: 1
                                            }),
                                            createVNode(unref(_sfc_main$n), null, {
                                              default: withCtx(() => [
                                                !unref(isImageZoomed) && !unref(isLivePhotoPlaying) ? (openBlock(), createBlock(unref(motion).div, {
                                                  key: 0,
                                                  initial: { opacity: 0, scale: 0.8, y: 20 },
                                                  animate: { opacity: 1, scale: 1, y: 0 },
                                                  exit: { opacity: 0, scale: 0.8, y: 20 },
                                                  transition: {
                                                    type: "spring",
                                                    stiffness: 300,
                                                    damping: 20,
                                                    delay: 0.1
                                                  },
                                                  class: "absolute bottom-4 right-4 z-20"
                                                }, {
                                                  default: withCtx(() => [
                                                    createVNode("div", { class: "relative" }, [
                                                      createVNode(ReactionPicker, {
                                                        "is-open": unref(showReactionPicker),
                                                        "selected-reaction": unref(selectedReaction),
                                                        "reaction-counts": unref(reactionCounts),
                                                        onSelect: handleReactionSelect,
                                                        onClose: ($event) => showReactionPicker.value = false
                                                      }, null, 8, ["is-open", "selected-reaction", "reaction-counts", "onClose"]),
                                                      unref(confettiIcon) ? (openBlock(), createBlock(ReactionConfetti, {
                                                        key: 0,
                                                        "icon-name": unref(confettiIcon),
                                                        "trigger-count": unref(confettiTriggerCount)
                                                      }, null, 8, ["icon-name", "trigger-count"])) : createCommentVNode("", true),
                                                      createVNode(unref(motion).button, {
                                                        type: "button",
                                                        initial: { scale: 0.8, opacity: 0 },
                                                        animate: {
                                                          scale: unref(showReactionPicker) ? 0.92 : 1,
                                                          opacity: 1,
                                                          transition: unref(showReactionPicker) ? { duration: 0.2, ease: [0.25, 0.1, 0.25, 1] } : {
                                                            type: "spring",
                                                            stiffness: 300,
                                                            damping: 25,
                                                            mass: 0.8
                                                          }
                                                        },
                                                        "while-hover": {
                                                          scale: unref(showReactionPicker) ? 0.95 : 1.05
                                                        },
                                                        "while-tap": { scale: 0.88 },
                                                        class: [
                                                          "pointer-events-auto flex items-center justify-center gap-2 cursor-pointer",
                                                          "px-4 h-11 rounded-full",
                                                          "backdrop-blur-xl border shadow-lg",
                                                          "transition-all duration-200",
                                                          unref(selectedReaction) ? "bg-blue-500/90 border-blue-400/50 text-white shadow-blue-500/30" : "bg-white/90 dark:bg-neutral-800/90 border-neutral-200/50 dark:border-white/10 text-neutral-700 dark:text-white/80 shadow-black/10 dark:shadow-black/30",
                                                          "hover:shadow-xl"
                                                        ],
                                                        onClick: toggleReactionPicker
                                                      }, {
                                                        default: withCtx(() => [
                                                          unref(selectedReaction) && unref(currentReactionIcon) ? (openBlock(), createBlock(_component_Icon, {
                                                            key: 0,
                                                            name: unref(currentReactionIcon),
                                                            class: "text-xl leading-none select-none"
                                                          }, null, 8, ["name"])) : (openBlock(), createBlock(_component_Icon, {
                                                            key: 1,
                                                            name: "tabler:mood-smile",
                                                            class: "text-xl"
                                                          })),
                                                          createVNode("div", { class: "flex flex-col items-start gap-0.5" }, [
                                                            createVNode("span", { class: "text-sm font-medium leading-none" }, toDisplayString$1(unref(selectedReaction) ? _ctx.$t("viewer.reaction.change") : _ctx.$t("viewer.reaction.add")), 1),
                                                            unref(totalReactions) > 0 ? (openBlock(), createBlock("span", {
                                                              key: 0,
                                                              class: "text-[10px] leading-none opacity-70"
                                                            }, toDisplayString$1(_ctx.$t(
                                                              "viewer.reaction.count",
                                                              { count: unref(totalReactions) },
                                                              unref(totalReactions)
                                                            )), 1)) : createCommentVNode("", true)
                                                          ])
                                                        ]),
                                                        _: 1
                                                      }, 8, ["animate", "while-hover", "class"])
                                                    ])
                                                  ]),
                                                  _: 1
                                                })) : createCommentVNode("", true)
                                              ]),
                                              _: 1
                                            })
                                          ];
                                        }
                                      }),
                                      _: 2
                                    }, _parent5, _scopeId4));
                                  } else {
                                    return [
                                      createVNode(unref(motion).div, {
                                        initial: { opacity: 0.5, scale: 0.95 },
                                        animate: { opacity: 1, scale: 1 },
                                        exit: { opacity: 0, scale: 0.95 },
                                        transition: { type: "spring", duration: 0.4, bounce: 0 },
                                        class: "relative flex h-full w-full items-center justify-center",
                                        style: { "user-select": "none", "-webkit-user-select": "none", "-webkit-touch-callout": "none", "-webkit-tap-highlight-color": "transparent" },
                                        onTouchstart: handleLivePhotoTouchStart,
                                        onTouchmove: handleLivePhotoTouchMove,
                                        onTouchend: handleLivePhotoTouchEnd,
                                        onTouchcancel: handleLivePhotoTouchEnd,
                                        onContextmenu: withModifiers(() => {
                                        }, ["prevent"])
                                      }, {
                                        default: withCtx(() => [
                                          createVNode(ProgressiveImage, {
                                            class: ["h-full w-full object-contain transition-opacity duration-400", {
                                              "opacity-0": unref(isLivePhotoPlaying) && unref(currentPhoto)?.isLivePhoto
                                            }],
                                            "loading-indicator-ref": unref(loadingIndicatorRef) || null,
                                            "is-current-image": index2 === __props.currentIndex,
                                            src: photo.originalUrl,
                                            "thumbnail-src": photo.thumbnailUrl,
                                            thumbhash: photo.thumbnailHash,
                                            alt: photo.title || "",
                                            width: index2 === __props.currentIndex ? unref(currentPhoto)?.width ?? void 0 : void 0,
                                            height: index2 === __props.currentIndex ? unref(currentPhoto)?.height ?? void 0 : void 0,
                                            "enable-pan": index2 === __props.currentIndex ? !unref(isMobile) || unref(isImageZoomed) : true,
                                            "enable-zoom": true,
                                            "on-zoom-change": index2 === __props.currentIndex ? handleZoomChange : void 0,
                                            "on-blob-src-change": index2 === __props.currentIndex ? handleBlobSrcChange : void 0,
                                            "on-image-loaded": index2 === __props.currentIndex ? handleImageLoaded : void 0,
                                            "is-live-photo": photo.isLivePhoto === 1,
                                            "live-photo-video-url": photo.livePhotoVideoUrl || void 0
                                          }, null, 8, ["class", "loading-indicator-ref", "is-current-image", "src", "thumbnail-src", "thumbhash", "alt", "width", "height", "enable-pan", "on-zoom-change", "on-blob-src-change", "on-image-loaded", "is-live-photo", "live-photo-video-url"]),
                                          photo.isLivePhoto && index2 === __props.currentIndex && unref(livePhotoVideoBlobUrl) ? (openBlock(), createBlock(unref(motion).video, {
                                            key: 0,
                                            ref_for: true,
                                            ref: (el) => {
                                              if (index2 === __props.currentIndex) livePhotoVideoRef.value = el;
                                            },
                                            src: unref(livePhotoVideoBlobUrl),
                                            class: "absolute inset-0 w-full h-full object-contain pointer-events-none select-none touch-none",
                                            muted: unref(isLivePhotoMuted),
                                            playsinline: "",
                                            preload: "metadata",
                                            initial: { opacity: 0 },
                                            animate: {
                                              opacity: unref(isLivePhotoPlaying) ? 1 : 0
                                            },
                                            transition: {
                                              duration: 0.4,
                                              ease: [0.25, 0.1, 0.25, 1],
                                              delay: unref(isLivePhotoPlaying) ? 0.1 : 0
                                            },
                                            onEnded: handleLivePhotoVideoEnded,
                                            onContextmenu: withModifiers(() => {
                                            }, ["prevent"])
                                          }, null, 8, ["src", "muted", "animate", "transition", "onContextmenu"])) : createCommentVNode("", true),
                                          createVNode(unref(_sfc_main$n), null, {
                                            default: withCtx(() => [
                                              unref(showZoomLevel) && unref(zoomLevel) > 0 ? (openBlock(), createBlock(unref(motion).div, {
                                                key: 0,
                                                initial: { opacity: 0, y: 10 },
                                                animate: { opacity: 1, y: 0 },
                                                exit: { opacity: 0, y: 10 },
                                                transition: { duration: 0.2 },
                                                class: "absolute bottom-4 left-4 z-20 bg-black/40 backdrop-blur-3xl rounded-xl border border-white/10 px-4 py-2 shadow-2xl"
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode("span", { class: "text-white font-medium" }, toDisplayString$1(unref(zoomLevel)) + "x", 1)
                                                ]),
                                                _: 1
                                              })) : createCommentVNode("", true)
                                            ]),
                                            _: 1
                                          }),
                                          createVNode(unref(_sfc_main$n), null, {
                                            default: withCtx(() => [
                                              !unref(isImageZoomed) && !unref(isLivePhotoPlaying) ? (openBlock(), createBlock(unref(motion).div, {
                                                key: 0,
                                                initial: { opacity: 0, scale: 0.95 },
                                                animate: { opacity: 0.6, scale: 1 },
                                                exit: { opacity: 0, scale: 0.95 },
                                                transition: { duration: 0.2 },
                                                class: "absolute bottom-6 left-1/2 z-20 -translate-x-1/2 bg-black/50 rounded-lg border border-white/10 px-2 py-1 shadow-2xl text-white text-xs font-bold"
                                              }, {
                                                default: withCtx(() => [
                                                  unref(currentPhoto)?.isLivePhoto && unref(isMobile) ? (openBlock(), createBlock("span", { key: 0 }, toDisplayString$1(_ctx.$t("viewer.hint.livePhoto.mobile")), 1)) : unref(currentPhoto)?.isLivePhoto && !unref(isMobile) ? (openBlock(), createBlock("span", { key: 1 }, toDisplayString$1(_ctx.$t("viewer.hint.livePhoto.desktop")), 1)) : (openBlock(), createBlock("span", { key: 2 }, toDisplayString$1(unref(isMobile) ? _ctx.$t("viewer.hint.mobile") : _ctx.$t("viewer.hint.desktop")), 1))
                                                ]),
                                                _: 1
                                              })) : createCommentVNode("", true)
                                            ]),
                                            _: 1
                                          }),
                                          createVNode(unref(_sfc_main$n), null, {
                                            default: withCtx(() => [
                                              !unref(isImageZoomed) && !unref(isLivePhotoPlaying) ? (openBlock(), createBlock(unref(motion).div, {
                                                key: 0,
                                                initial: { opacity: 0, scale: 0.8, y: 20 },
                                                animate: { opacity: 1, scale: 1, y: 0 },
                                                exit: { opacity: 0, scale: 0.8, y: 20 },
                                                transition: {
                                                  type: "spring",
                                                  stiffness: 300,
                                                  damping: 20,
                                                  delay: 0.1
                                                },
                                                class: "absolute bottom-4 right-4 z-20"
                                              }, {
                                                default: withCtx(() => [
                                                  createVNode("div", { class: "relative" }, [
                                                    createVNode(ReactionPicker, {
                                                      "is-open": unref(showReactionPicker),
                                                      "selected-reaction": unref(selectedReaction),
                                                      "reaction-counts": unref(reactionCounts),
                                                      onSelect: handleReactionSelect,
                                                      onClose: ($event) => showReactionPicker.value = false
                                                    }, null, 8, ["is-open", "selected-reaction", "reaction-counts", "onClose"]),
                                                    unref(confettiIcon) ? (openBlock(), createBlock(ReactionConfetti, {
                                                      key: 0,
                                                      "icon-name": unref(confettiIcon),
                                                      "trigger-count": unref(confettiTriggerCount)
                                                    }, null, 8, ["icon-name", "trigger-count"])) : createCommentVNode("", true),
                                                    createVNode(unref(motion).button, {
                                                      type: "button",
                                                      initial: { scale: 0.8, opacity: 0 },
                                                      animate: {
                                                        scale: unref(showReactionPicker) ? 0.92 : 1,
                                                        opacity: 1,
                                                        transition: unref(showReactionPicker) ? { duration: 0.2, ease: [0.25, 0.1, 0.25, 1] } : {
                                                          type: "spring",
                                                          stiffness: 300,
                                                          damping: 25,
                                                          mass: 0.8
                                                        }
                                                      },
                                                      "while-hover": {
                                                        scale: unref(showReactionPicker) ? 0.95 : 1.05
                                                      },
                                                      "while-tap": { scale: 0.88 },
                                                      class: [
                                                        "pointer-events-auto flex items-center justify-center gap-2 cursor-pointer",
                                                        "px-4 h-11 rounded-full",
                                                        "backdrop-blur-xl border shadow-lg",
                                                        "transition-all duration-200",
                                                        unref(selectedReaction) ? "bg-blue-500/90 border-blue-400/50 text-white shadow-blue-500/30" : "bg-white/90 dark:bg-neutral-800/90 border-neutral-200/50 dark:border-white/10 text-neutral-700 dark:text-white/80 shadow-black/10 dark:shadow-black/30",
                                                        "hover:shadow-xl"
                                                      ],
                                                      onClick: toggleReactionPicker
                                                    }, {
                                                      default: withCtx(() => [
                                                        unref(selectedReaction) && unref(currentReactionIcon) ? (openBlock(), createBlock(_component_Icon, {
                                                          key: 0,
                                                          name: unref(currentReactionIcon),
                                                          class: "text-xl leading-none select-none"
                                                        }, null, 8, ["name"])) : (openBlock(), createBlock(_component_Icon, {
                                                          key: 1,
                                                          name: "tabler:mood-smile",
                                                          class: "text-xl"
                                                        })),
                                                        createVNode("div", { class: "flex flex-col items-start gap-0.5" }, [
                                                          createVNode("span", { class: "text-sm font-medium leading-none" }, toDisplayString$1(unref(selectedReaction) ? _ctx.$t("viewer.reaction.change") : _ctx.$t("viewer.reaction.add")), 1),
                                                          unref(totalReactions) > 0 ? (openBlock(), createBlock("span", {
                                                            key: 0,
                                                            class: "text-[10px] leading-none opacity-70"
                                                          }, toDisplayString$1(_ctx.$t(
                                                            "viewer.reaction.count",
                                                            { count: unref(totalReactions) },
                                                            unref(totalReactions)
                                                          )), 1)) : createCommentVNode("", true)
                                                        ])
                                                      ]),
                                                      _: 1
                                                    }, 8, ["animate", "while-hover", "class"])
                                                  ])
                                                ]),
                                                _: 1
                                              })) : createCommentVNode("", true)
                                            ]),
                                            _: 1
                                          })
                                        ]),
                                        _: 2
                                      }, 1032, ["onContextmenu"])
                                    ];
                                  }
                                }),
                                _: 2
                              }, _parent4, _scopeId3));
                            });
                            _push5(`<!--]-->`);
                          } else {
                            return [
                              (openBlock(true), createBlock(Fragment, null, renderList(__props.photos, (photo, index2) => {
                                return openBlock(), createBlock(unref(SwiperSlide), {
                                  key: photo.id,
                                  "virtual-index": index2,
                                  class: "flex items-center justify-center"
                                }, {
                                  default: withCtx(() => [
                                    createVNode(unref(motion).div, {
                                      initial: { opacity: 0.5, scale: 0.95 },
                                      animate: { opacity: 1, scale: 1 },
                                      exit: { opacity: 0, scale: 0.95 },
                                      transition: { type: "spring", duration: 0.4, bounce: 0 },
                                      class: "relative flex h-full w-full items-center justify-center",
                                      style: { "user-select": "none", "-webkit-user-select": "none", "-webkit-touch-callout": "none", "-webkit-tap-highlight-color": "transparent" },
                                      onTouchstart: handleLivePhotoTouchStart,
                                      onTouchmove: handleLivePhotoTouchMove,
                                      onTouchend: handleLivePhotoTouchEnd,
                                      onTouchcancel: handleLivePhotoTouchEnd,
                                      onContextmenu: withModifiers(() => {
                                      }, ["prevent"])
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(ProgressiveImage, {
                                          class: ["h-full w-full object-contain transition-opacity duration-400", {
                                            "opacity-0": unref(isLivePhotoPlaying) && unref(currentPhoto)?.isLivePhoto
                                          }],
                                          "loading-indicator-ref": unref(loadingIndicatorRef) || null,
                                          "is-current-image": index2 === __props.currentIndex,
                                          src: photo.originalUrl,
                                          "thumbnail-src": photo.thumbnailUrl,
                                          thumbhash: photo.thumbnailHash,
                                          alt: photo.title || "",
                                          width: index2 === __props.currentIndex ? unref(currentPhoto)?.width ?? void 0 : void 0,
                                          height: index2 === __props.currentIndex ? unref(currentPhoto)?.height ?? void 0 : void 0,
                                          "enable-pan": index2 === __props.currentIndex ? !unref(isMobile) || unref(isImageZoomed) : true,
                                          "enable-zoom": true,
                                          "on-zoom-change": index2 === __props.currentIndex ? handleZoomChange : void 0,
                                          "on-blob-src-change": index2 === __props.currentIndex ? handleBlobSrcChange : void 0,
                                          "on-image-loaded": index2 === __props.currentIndex ? handleImageLoaded : void 0,
                                          "is-live-photo": photo.isLivePhoto === 1,
                                          "live-photo-video-url": photo.livePhotoVideoUrl || void 0
                                        }, null, 8, ["class", "loading-indicator-ref", "is-current-image", "src", "thumbnail-src", "thumbhash", "alt", "width", "height", "enable-pan", "on-zoom-change", "on-blob-src-change", "on-image-loaded", "is-live-photo", "live-photo-video-url"]),
                                        photo.isLivePhoto && index2 === __props.currentIndex && unref(livePhotoVideoBlobUrl) ? (openBlock(), createBlock(unref(motion).video, {
                                          key: 0,
                                          ref_for: true,
                                          ref: (el) => {
                                            if (index2 === __props.currentIndex) livePhotoVideoRef.value = el;
                                          },
                                          src: unref(livePhotoVideoBlobUrl),
                                          class: "absolute inset-0 w-full h-full object-contain pointer-events-none select-none touch-none",
                                          muted: unref(isLivePhotoMuted),
                                          playsinline: "",
                                          preload: "metadata",
                                          initial: { opacity: 0 },
                                          animate: {
                                            opacity: unref(isLivePhotoPlaying) ? 1 : 0
                                          },
                                          transition: {
                                            duration: 0.4,
                                            ease: [0.25, 0.1, 0.25, 1],
                                            delay: unref(isLivePhotoPlaying) ? 0.1 : 0
                                          },
                                          onEnded: handleLivePhotoVideoEnded,
                                          onContextmenu: withModifiers(() => {
                                          }, ["prevent"])
                                        }, null, 8, ["src", "muted", "animate", "transition", "onContextmenu"])) : createCommentVNode("", true),
                                        createVNode(unref(_sfc_main$n), null, {
                                          default: withCtx(() => [
                                            unref(showZoomLevel) && unref(zoomLevel) > 0 ? (openBlock(), createBlock(unref(motion).div, {
                                              key: 0,
                                              initial: { opacity: 0, y: 10 },
                                              animate: { opacity: 1, y: 0 },
                                              exit: { opacity: 0, y: 10 },
                                              transition: { duration: 0.2 },
                                              class: "absolute bottom-4 left-4 z-20 bg-black/40 backdrop-blur-3xl rounded-xl border border-white/10 px-4 py-2 shadow-2xl"
                                            }, {
                                              default: withCtx(() => [
                                                createVNode("span", { class: "text-white font-medium" }, toDisplayString$1(unref(zoomLevel)) + "x", 1)
                                              ]),
                                              _: 1
                                            })) : createCommentVNode("", true)
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(unref(_sfc_main$n), null, {
                                          default: withCtx(() => [
                                            !unref(isImageZoomed) && !unref(isLivePhotoPlaying) ? (openBlock(), createBlock(unref(motion).div, {
                                              key: 0,
                                              initial: { opacity: 0, scale: 0.95 },
                                              animate: { opacity: 0.6, scale: 1 },
                                              exit: { opacity: 0, scale: 0.95 },
                                              transition: { duration: 0.2 },
                                              class: "absolute bottom-6 left-1/2 z-20 -translate-x-1/2 bg-black/50 rounded-lg border border-white/10 px-2 py-1 shadow-2xl text-white text-xs font-bold"
                                            }, {
                                              default: withCtx(() => [
                                                unref(currentPhoto)?.isLivePhoto && unref(isMobile) ? (openBlock(), createBlock("span", { key: 0 }, toDisplayString$1(_ctx.$t("viewer.hint.livePhoto.mobile")), 1)) : unref(currentPhoto)?.isLivePhoto && !unref(isMobile) ? (openBlock(), createBlock("span", { key: 1 }, toDisplayString$1(_ctx.$t("viewer.hint.livePhoto.desktop")), 1)) : (openBlock(), createBlock("span", { key: 2 }, toDisplayString$1(unref(isMobile) ? _ctx.$t("viewer.hint.mobile") : _ctx.$t("viewer.hint.desktop")), 1))
                                              ]),
                                              _: 1
                                            })) : createCommentVNode("", true)
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(unref(_sfc_main$n), null, {
                                          default: withCtx(() => [
                                            !unref(isImageZoomed) && !unref(isLivePhotoPlaying) ? (openBlock(), createBlock(unref(motion).div, {
                                              key: 0,
                                              initial: { opacity: 0, scale: 0.8, y: 20 },
                                              animate: { opacity: 1, scale: 1, y: 0 },
                                              exit: { opacity: 0, scale: 0.8, y: 20 },
                                              transition: {
                                                type: "spring",
                                                stiffness: 300,
                                                damping: 20,
                                                delay: 0.1
                                              },
                                              class: "absolute bottom-4 right-4 z-20"
                                            }, {
                                              default: withCtx(() => [
                                                createVNode("div", { class: "relative" }, [
                                                  createVNode(ReactionPicker, {
                                                    "is-open": unref(showReactionPicker),
                                                    "selected-reaction": unref(selectedReaction),
                                                    "reaction-counts": unref(reactionCounts),
                                                    onSelect: handleReactionSelect,
                                                    onClose: ($event) => showReactionPicker.value = false
                                                  }, null, 8, ["is-open", "selected-reaction", "reaction-counts", "onClose"]),
                                                  unref(confettiIcon) ? (openBlock(), createBlock(ReactionConfetti, {
                                                    key: 0,
                                                    "icon-name": unref(confettiIcon),
                                                    "trigger-count": unref(confettiTriggerCount)
                                                  }, null, 8, ["icon-name", "trigger-count"])) : createCommentVNode("", true),
                                                  createVNode(unref(motion).button, {
                                                    type: "button",
                                                    initial: { scale: 0.8, opacity: 0 },
                                                    animate: {
                                                      scale: unref(showReactionPicker) ? 0.92 : 1,
                                                      opacity: 1,
                                                      transition: unref(showReactionPicker) ? { duration: 0.2, ease: [0.25, 0.1, 0.25, 1] } : {
                                                        type: "spring",
                                                        stiffness: 300,
                                                        damping: 25,
                                                        mass: 0.8
                                                      }
                                                    },
                                                    "while-hover": {
                                                      scale: unref(showReactionPicker) ? 0.95 : 1.05
                                                    },
                                                    "while-tap": { scale: 0.88 },
                                                    class: [
                                                      "pointer-events-auto flex items-center justify-center gap-2 cursor-pointer",
                                                      "px-4 h-11 rounded-full",
                                                      "backdrop-blur-xl border shadow-lg",
                                                      "transition-all duration-200",
                                                      unref(selectedReaction) ? "bg-blue-500/90 border-blue-400/50 text-white shadow-blue-500/30" : "bg-white/90 dark:bg-neutral-800/90 border-neutral-200/50 dark:border-white/10 text-neutral-700 dark:text-white/80 shadow-black/10 dark:shadow-black/30",
                                                      "hover:shadow-xl"
                                                    ],
                                                    onClick: toggleReactionPicker
                                                  }, {
                                                    default: withCtx(() => [
                                                      unref(selectedReaction) && unref(currentReactionIcon) ? (openBlock(), createBlock(_component_Icon, {
                                                        key: 0,
                                                        name: unref(currentReactionIcon),
                                                        class: "text-xl leading-none select-none"
                                                      }, null, 8, ["name"])) : (openBlock(), createBlock(_component_Icon, {
                                                        key: 1,
                                                        name: "tabler:mood-smile",
                                                        class: "text-xl"
                                                      })),
                                                      createVNode("div", { class: "flex flex-col items-start gap-0.5" }, [
                                                        createVNode("span", { class: "text-sm font-medium leading-none" }, toDisplayString$1(unref(selectedReaction) ? _ctx.$t("viewer.reaction.change") : _ctx.$t("viewer.reaction.add")), 1),
                                                        unref(totalReactions) > 0 ? (openBlock(), createBlock("span", {
                                                          key: 0,
                                                          class: "text-[10px] leading-none opacity-70"
                                                        }, toDisplayString$1(_ctx.$t(
                                                          "viewer.reaction.count",
                                                          { count: unref(totalReactions) },
                                                          unref(totalReactions)
                                                        )), 1)) : createCommentVNode("", true)
                                                      ])
                                                    ]),
                                                    _: 1
                                                  }, 8, ["animate", "while-hover", "class"])
                                                ])
                                              ]),
                                              _: 1
                                            })) : createCommentVNode("", true)
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 2
                                    }, 1032, ["onContextmenu"])
                                  ]),
                                  _: 2
                                }, 1032, ["virtual-index"]);
                              }), 128))
                            ];
                          }
                        }),
                        _: 1
                      }, _parent3, _scopeId2));
                      if (!unref(isMobile)) {
                        _push4(`<!--[-->`);
                        if (__props.currentIndex > 0) {
                          _push4(`<button type="button" class="absolute top-1/2 left-4 z-20 flex size-8 -translate-y-1/2 items-center justify-center rounded-full text-white opacity-0 backdrop-blur-sm duration-200 group-hover:opacity-100 bg-black/30 hover:bg-black/40" data-v-3a8c3532${_scopeId2}>`);
                          _push4(ssrRenderComponent(_component_Icon, {
                            name: "tabler:chevron-left",
                            class: "text-xl cursor-pointer"
                          }, null, _parent3, _scopeId2));
                          _push4(`</button>`);
                        } else {
                          _push4(`<!---->`);
                        }
                        if (__props.currentIndex < __props.photos.length - 1) {
                          _push4(`<button type="button" class="absolute top-1/2 right-4 z-20 flex size-8 -translate-y-1/2 items-center justify-center rounded-full text-white opacity-0 backdrop-blur-sm duration-200 group-hover:opacity-100 bg-black/30 hover:bg-black/40" data-v-3a8c3532${_scopeId2}>`);
                          _push4(ssrRenderComponent(_component_Icon, {
                            name: "tabler:chevron-right",
                            class: "text-xl cursor-pointer"
                          }, null, _parent3, _scopeId2));
                          _push4(`</button>`);
                        } else {
                          _push4(`<!---->`);
                        }
                        _push4(`<!--]-->`);
                      } else {
                        _push4(`<!---->`);
                      }
                      _push4(`</div>`);
                      _push4(ssrRenderComponent(GalleryThumbnail, {
                        "current-index": __props.currentIndex,
                        photos: __props.photos,
                        onIndexChange: ($event) => emit("indexChange", $event)
                      }, null, _parent3, _scopeId2));
                      _push4(`</div>`);
                      if (unref(isMobile)) {
                        _push4(ssrRenderComponent(unref(_sfc_main$n), null, {
                          default: withCtx((_3, _push5, _parent4, _scopeId3) => {
                            if (_push5) {
                              if (unref(showExifPanel) && unref(currentPhoto)) {
                                _push5(ssrRenderComponent(InfoPanel, {
                                  "current-photo": unref(currentPhoto),
                                  "exif-data": unref(currentPhoto)?.exif,
                                  "on-close": () => showExifPanel.value = false
                                }, null, _parent4, _scopeId3));
                              } else {
                                _push5(`<!---->`);
                              }
                            } else {
                              return [
                                unref(showExifPanel) && unref(currentPhoto) ? (openBlock(), createBlock(InfoPanel, {
                                  key: 0,
                                  "current-photo": unref(currentPhoto),
                                  "exif-data": unref(currentPhoto)?.exif,
                                  "on-close": () => showExifPanel.value = false
                                }, null, 8, ["current-photo", "exif-data", "on-close"])) : createCommentVNode("", true)
                              ];
                            }
                          }),
                          _: 1
                        }, _parent3, _scopeId2));
                      } else if (unref(currentPhoto)) {
                        _push4(ssrRenderComponent(InfoPanel, {
                          "current-photo": unref(currentPhoto),
                          "exif-data": unref(currentPhoto)?.exif
                        }, null, _parent3, _scopeId2));
                      } else {
                        _push4(`<!---->`);
                      }
                      _push4(`</div>`);
                    } else {
                      return [
                        createVNode("div", {
                          class: ["flex w-full h-full", unref(isMobile) ? "flex-col" : "flex-row"]
                        }, [
                          createVNode("div", { class: "z-10 flex min-h-0 min-w-0 flex-1 flex-col" }, [
                            createVNode("div", { class: "group relative flex min-h-0 min-w-0 flex-1" }, [
                              createVNode(unref(motion).div, {
                                initial: { opacity: 0 },
                                animate: { opacity: 1 },
                                exit: { opacity: 0 },
                                transition: { duration: 0.3 },
                                class: [
                                  "absolute z-30 flex items-center justify-between",
                                  unref(isMobile) ? "top-2 right-2 left-2" : "top-4 right-4 left-4"
                                ]
                              }, {
                                default: withCtx(() => [
                                  createVNode("div", { class: "flex items-center gap-1" }, [
                                    unref(currentPhoto)?.isLivePhoto ? (openBlock(), createBlock(_component_PhotoLivePhotoIndicator, {
                                      key: 0,
                                      class: unref(isMobile) ? "cursor-default" : "cursor-pointer",
                                      photo: unref(currentPhoto),
                                      "is-video-playing": unref(isLivePhotoPlaying),
                                      "processing-state": unref(livePhotoProcessingState)?.value || null,
                                      onMouseenter: handleLivePhotoMouseEnter,
                                      onMouseleave: handleLivePhotoMouseLeave
                                    }, null, 8, ["class", "photo", "is-video-playing", "processing-state"])) : createCommentVNode("", true),
                                    unref(currentPhoto)?.isLivePhoto ? (openBlock(), createBlock("div", {
                                      key: 1,
                                      class: ["pointer-events-auto backdrop-blur-md bg-black/40 text-white rounded-full p-1 text-[13px] font-bold flex items-center gap-0.5 leading-0 select-none", unref(isMobile) ? "cursor-default" : "cursor-pointer"],
                                      onClick: ($event) => isLivePhotoMuted.value = !unref(isLivePhotoMuted)
                                    }, [
                                      createVNode(_component_Icon, {
                                        name: unref(isLivePhotoMuted) ? "tabler:volume-off" : "tabler:volume",
                                        class: "size-[17px]"
                                      }, null, 8, ["name"])
                                    ], 10, ["onClick"])) : createCommentVNode("", true)
                                  ]),
                                  createVNode("div", { class: "flex items-center gap-2" }, [
                                    unref(isMobile) ? (openBlock(), createBlock(_component_GlassButton, {
                                      key: 0,
                                      icon: "tabler:info-circle",
                                      class: !unref(showExifPanel) ? "" : "bg-black/20 hover:bg-black/30 text-white",
                                      size: "sm",
                                      rounded: "",
                                      onClick: ($event) => showExifPanel.value = !unref(showExifPanel)
                                    }, null, 8, ["class", "onClick"])) : createCommentVNode("", true),
                                    createVNode(_component_GlassButton, {
                                      icon: "tabler:share-3",
                                      size: "sm",
                                      rounded: "",
                                      onClick: ($event) => showShareModal.value = true
                                    }, null, 8, ["onClick"]),
                                    createVNode(_component_GlassButton, {
                                      icon: "tabler:x",
                                      size: "sm",
                                      rounded: "",
                                      onClick: ($event) => emit("close")
                                    }, null, 8, ["onClick"])
                                  ])
                                ]),
                                _: 1
                              }, 8, ["class"]),
                              createVNode(LoadingIndicator, {
                                ref_key: "loadingIndicatorRef",
                                ref: loadingIndicatorRef
                              }, null, 512),
                              createVNode(unref(Swiper), {
                                modules: swiperModules,
                                "space-between": 0,
                                "slides-per-view": 1,
                                "initial-slide": __props.currentIndex,
                                virtual: true,
                                keyboard: {
                                  enabled: true,
                                  onlyInViewport: true
                                },
                                class: "h-full w-full",
                                style: { touchAction: unref(isMobile) ? "pan-x" : "pan-y" },
                                onSwiper: handleSwiperInit,
                                onSlideChange: handleSlideChange
                              }, {
                                default: withCtx(() => [
                                  (openBlock(true), createBlock(Fragment, null, renderList(__props.photos, (photo, index2) => {
                                    return openBlock(), createBlock(unref(SwiperSlide), {
                                      key: photo.id,
                                      "virtual-index": index2,
                                      class: "flex items-center justify-center"
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(unref(motion).div, {
                                          initial: { opacity: 0.5, scale: 0.95 },
                                          animate: { opacity: 1, scale: 1 },
                                          exit: { opacity: 0, scale: 0.95 },
                                          transition: { type: "spring", duration: 0.4, bounce: 0 },
                                          class: "relative flex h-full w-full items-center justify-center",
                                          style: { "user-select": "none", "-webkit-user-select": "none", "-webkit-touch-callout": "none", "-webkit-tap-highlight-color": "transparent" },
                                          onTouchstart: handleLivePhotoTouchStart,
                                          onTouchmove: handleLivePhotoTouchMove,
                                          onTouchend: handleLivePhotoTouchEnd,
                                          onTouchcancel: handleLivePhotoTouchEnd,
                                          onContextmenu: withModifiers(() => {
                                          }, ["prevent"])
                                        }, {
                                          default: withCtx(() => [
                                            createVNode(ProgressiveImage, {
                                              class: ["h-full w-full object-contain transition-opacity duration-400", {
                                                "opacity-0": unref(isLivePhotoPlaying) && unref(currentPhoto)?.isLivePhoto
                                              }],
                                              "loading-indicator-ref": unref(loadingIndicatorRef) || null,
                                              "is-current-image": index2 === __props.currentIndex,
                                              src: photo.originalUrl,
                                              "thumbnail-src": photo.thumbnailUrl,
                                              thumbhash: photo.thumbnailHash,
                                              alt: photo.title || "",
                                              width: index2 === __props.currentIndex ? unref(currentPhoto)?.width ?? void 0 : void 0,
                                              height: index2 === __props.currentIndex ? unref(currentPhoto)?.height ?? void 0 : void 0,
                                              "enable-pan": index2 === __props.currentIndex ? !unref(isMobile) || unref(isImageZoomed) : true,
                                              "enable-zoom": true,
                                              "on-zoom-change": index2 === __props.currentIndex ? handleZoomChange : void 0,
                                              "on-blob-src-change": index2 === __props.currentIndex ? handleBlobSrcChange : void 0,
                                              "on-image-loaded": index2 === __props.currentIndex ? handleImageLoaded : void 0,
                                              "is-live-photo": photo.isLivePhoto === 1,
                                              "live-photo-video-url": photo.livePhotoVideoUrl || void 0
                                            }, null, 8, ["class", "loading-indicator-ref", "is-current-image", "src", "thumbnail-src", "thumbhash", "alt", "width", "height", "enable-pan", "on-zoom-change", "on-blob-src-change", "on-image-loaded", "is-live-photo", "live-photo-video-url"]),
                                            photo.isLivePhoto && index2 === __props.currentIndex && unref(livePhotoVideoBlobUrl) ? (openBlock(), createBlock(unref(motion).video, {
                                              key: 0,
                                              ref_for: true,
                                              ref: (el) => {
                                                if (index2 === __props.currentIndex) livePhotoVideoRef.value = el;
                                              },
                                              src: unref(livePhotoVideoBlobUrl),
                                              class: "absolute inset-0 w-full h-full object-contain pointer-events-none select-none touch-none",
                                              muted: unref(isLivePhotoMuted),
                                              playsinline: "",
                                              preload: "metadata",
                                              initial: { opacity: 0 },
                                              animate: {
                                                opacity: unref(isLivePhotoPlaying) ? 1 : 0
                                              },
                                              transition: {
                                                duration: 0.4,
                                                ease: [0.25, 0.1, 0.25, 1],
                                                delay: unref(isLivePhotoPlaying) ? 0.1 : 0
                                              },
                                              onEnded: handleLivePhotoVideoEnded,
                                              onContextmenu: withModifiers(() => {
                                              }, ["prevent"])
                                            }, null, 8, ["src", "muted", "animate", "transition", "onContextmenu"])) : createCommentVNode("", true),
                                            createVNode(unref(_sfc_main$n), null, {
                                              default: withCtx(() => [
                                                unref(showZoomLevel) && unref(zoomLevel) > 0 ? (openBlock(), createBlock(unref(motion).div, {
                                                  key: 0,
                                                  initial: { opacity: 0, y: 10 },
                                                  animate: { opacity: 1, y: 0 },
                                                  exit: { opacity: 0, y: 10 },
                                                  transition: { duration: 0.2 },
                                                  class: "absolute bottom-4 left-4 z-20 bg-black/40 backdrop-blur-3xl rounded-xl border border-white/10 px-4 py-2 shadow-2xl"
                                                }, {
                                                  default: withCtx(() => [
                                                    createVNode("span", { class: "text-white font-medium" }, toDisplayString$1(unref(zoomLevel)) + "x", 1)
                                                  ]),
                                                  _: 1
                                                })) : createCommentVNode("", true)
                                              ]),
                                              _: 1
                                            }),
                                            createVNode(unref(_sfc_main$n), null, {
                                              default: withCtx(() => [
                                                !unref(isImageZoomed) && !unref(isLivePhotoPlaying) ? (openBlock(), createBlock(unref(motion).div, {
                                                  key: 0,
                                                  initial: { opacity: 0, scale: 0.95 },
                                                  animate: { opacity: 0.6, scale: 1 },
                                                  exit: { opacity: 0, scale: 0.95 },
                                                  transition: { duration: 0.2 },
                                                  class: "absolute bottom-6 left-1/2 z-20 -translate-x-1/2 bg-black/50 rounded-lg border border-white/10 px-2 py-1 shadow-2xl text-white text-xs font-bold"
                                                }, {
                                                  default: withCtx(() => [
                                                    unref(currentPhoto)?.isLivePhoto && unref(isMobile) ? (openBlock(), createBlock("span", { key: 0 }, toDisplayString$1(_ctx.$t("viewer.hint.livePhoto.mobile")), 1)) : unref(currentPhoto)?.isLivePhoto && !unref(isMobile) ? (openBlock(), createBlock("span", { key: 1 }, toDisplayString$1(_ctx.$t("viewer.hint.livePhoto.desktop")), 1)) : (openBlock(), createBlock("span", { key: 2 }, toDisplayString$1(unref(isMobile) ? _ctx.$t("viewer.hint.mobile") : _ctx.$t("viewer.hint.desktop")), 1))
                                                  ]),
                                                  _: 1
                                                })) : createCommentVNode("", true)
                                              ]),
                                              _: 1
                                            }),
                                            createVNode(unref(_sfc_main$n), null, {
                                              default: withCtx(() => [
                                                !unref(isImageZoomed) && !unref(isLivePhotoPlaying) ? (openBlock(), createBlock(unref(motion).div, {
                                                  key: 0,
                                                  initial: { opacity: 0, scale: 0.8, y: 20 },
                                                  animate: { opacity: 1, scale: 1, y: 0 },
                                                  exit: { opacity: 0, scale: 0.8, y: 20 },
                                                  transition: {
                                                    type: "spring",
                                                    stiffness: 300,
                                                    damping: 20,
                                                    delay: 0.1
                                                  },
                                                  class: "absolute bottom-4 right-4 z-20"
                                                }, {
                                                  default: withCtx(() => [
                                                    createVNode("div", { class: "relative" }, [
                                                      createVNode(ReactionPicker, {
                                                        "is-open": unref(showReactionPicker),
                                                        "selected-reaction": unref(selectedReaction),
                                                        "reaction-counts": unref(reactionCounts),
                                                        onSelect: handleReactionSelect,
                                                        onClose: ($event) => showReactionPicker.value = false
                                                      }, null, 8, ["is-open", "selected-reaction", "reaction-counts", "onClose"]),
                                                      unref(confettiIcon) ? (openBlock(), createBlock(ReactionConfetti, {
                                                        key: 0,
                                                        "icon-name": unref(confettiIcon),
                                                        "trigger-count": unref(confettiTriggerCount)
                                                      }, null, 8, ["icon-name", "trigger-count"])) : createCommentVNode("", true),
                                                      createVNode(unref(motion).button, {
                                                        type: "button",
                                                        initial: { scale: 0.8, opacity: 0 },
                                                        animate: {
                                                          scale: unref(showReactionPicker) ? 0.92 : 1,
                                                          opacity: 1,
                                                          transition: unref(showReactionPicker) ? { duration: 0.2, ease: [0.25, 0.1, 0.25, 1] } : {
                                                            type: "spring",
                                                            stiffness: 300,
                                                            damping: 25,
                                                            mass: 0.8
                                                          }
                                                        },
                                                        "while-hover": {
                                                          scale: unref(showReactionPicker) ? 0.95 : 1.05
                                                        },
                                                        "while-tap": { scale: 0.88 },
                                                        class: [
                                                          "pointer-events-auto flex items-center justify-center gap-2 cursor-pointer",
                                                          "px-4 h-11 rounded-full",
                                                          "backdrop-blur-xl border shadow-lg",
                                                          "transition-all duration-200",
                                                          unref(selectedReaction) ? "bg-blue-500/90 border-blue-400/50 text-white shadow-blue-500/30" : "bg-white/90 dark:bg-neutral-800/90 border-neutral-200/50 dark:border-white/10 text-neutral-700 dark:text-white/80 shadow-black/10 dark:shadow-black/30",
                                                          "hover:shadow-xl"
                                                        ],
                                                        onClick: toggleReactionPicker
                                                      }, {
                                                        default: withCtx(() => [
                                                          unref(selectedReaction) && unref(currentReactionIcon) ? (openBlock(), createBlock(_component_Icon, {
                                                            key: 0,
                                                            name: unref(currentReactionIcon),
                                                            class: "text-xl leading-none select-none"
                                                          }, null, 8, ["name"])) : (openBlock(), createBlock(_component_Icon, {
                                                            key: 1,
                                                            name: "tabler:mood-smile",
                                                            class: "text-xl"
                                                          })),
                                                          createVNode("div", { class: "flex flex-col items-start gap-0.5" }, [
                                                            createVNode("span", { class: "text-sm font-medium leading-none" }, toDisplayString$1(unref(selectedReaction) ? _ctx.$t("viewer.reaction.change") : _ctx.$t("viewer.reaction.add")), 1),
                                                            unref(totalReactions) > 0 ? (openBlock(), createBlock("span", {
                                                              key: 0,
                                                              class: "text-[10px] leading-none opacity-70"
                                                            }, toDisplayString$1(_ctx.$t(
                                                              "viewer.reaction.count",
                                                              { count: unref(totalReactions) },
                                                              unref(totalReactions)
                                                            )), 1)) : createCommentVNode("", true)
                                                          ])
                                                        ]),
                                                        _: 1
                                                      }, 8, ["animate", "while-hover", "class"])
                                                    ])
                                                  ]),
                                                  _: 1
                                                })) : createCommentVNode("", true)
                                              ]),
                                              _: 1
                                            })
                                          ]),
                                          _: 2
                                        }, 1032, ["onContextmenu"])
                                      ]),
                                      _: 2
                                    }, 1032, ["virtual-index"]);
                                  }), 128))
                                ]),
                                _: 1
                              }, 8, ["initial-slide", "style"]),
                              !unref(isMobile) ? (openBlock(), createBlock(Fragment, { key: 0 }, [
                                __props.currentIndex > 0 ? (openBlock(), createBlock("button", {
                                  key: 0,
                                  type: "button",
                                  class: "absolute top-1/2 left-4 z-20 flex size-8 -translate-y-1/2 items-center justify-center rounded-full text-white opacity-0 backdrop-blur-sm duration-200 group-hover:opacity-100 bg-black/30 hover:bg-black/40",
                                  onClick: handlePrevious
                                }, [
                                  createVNode(_component_Icon, {
                                    name: "tabler:chevron-left",
                                    class: "text-xl cursor-pointer"
                                  })
                                ])) : createCommentVNode("", true),
                                __props.currentIndex < __props.photos.length - 1 ? (openBlock(), createBlock("button", {
                                  key: 1,
                                  type: "button",
                                  class: "absolute top-1/2 right-4 z-20 flex size-8 -translate-y-1/2 items-center justify-center rounded-full text-white opacity-0 backdrop-blur-sm duration-200 group-hover:opacity-100 bg-black/30 hover:bg-black/40",
                                  onClick: handleNext
                                }, [
                                  createVNode(_component_Icon, {
                                    name: "tabler:chevron-right",
                                    class: "text-xl cursor-pointer"
                                  })
                                ])) : createCommentVNode("", true)
                              ], 64)) : createCommentVNode("", true)
                            ]),
                            createVNode(GalleryThumbnail, {
                              "current-index": __props.currentIndex,
                              photos: __props.photos,
                              onIndexChange: ($event) => emit("indexChange", $event)
                            }, null, 8, ["current-index", "photos", "onIndexChange"])
                          ]),
                          unref(isMobile) ? (openBlock(), createBlock(unref(_sfc_main$n), { key: 0 }, {
                            default: withCtx(() => [
                              unref(showExifPanel) && unref(currentPhoto) ? (openBlock(), createBlock(InfoPanel, {
                                key: 0,
                                "current-photo": unref(currentPhoto),
                                "exif-data": unref(currentPhoto)?.exif,
                                "on-close": () => showExifPanel.value = false
                              }, null, 8, ["current-photo", "exif-data", "on-close"])) : createCommentVNode("", true)
                            ]),
                            _: 1
                          })) : unref(currentPhoto) ? (openBlock(), createBlock(InfoPanel, {
                            key: 1,
                            "current-photo": unref(currentPhoto),
                            "exif-data": unref(currentPhoto)?.exif
                          }, null, 8, ["current-photo", "exif-data"])) : createCommentVNode("", true)
                        ], 2)
                      ];
                    }
                  }),
                  _: 1
                }, _parent2, _scopeId));
              } else {
                _push3(`<!---->`);
              }
            } else {
              return [
                __props.isOpen ? (openBlock(), createBlock(unref(motion).div, {
                  key: 0,
                  ref_key: "containerRef",
                  ref: containerRef,
                  initial: { opacity: 0 },
                  animate: { opacity: 1 },
                  exit: { opacity: 0 },
                  transition: { duration: 0.3 },
                  class: "fixed inset-0 z-50 flex items-center justify-center",
                  style: { touchAction: unref(isMobile) ? "manipulation" : "none" },
                  onClick: withModifiers(($event) => emit("close"), ["self"])
                }, {
                  default: withCtx(() => [
                    createVNode("div", {
                      class: ["flex w-full h-full", unref(isMobile) ? "flex-col" : "flex-row"]
                    }, [
                      createVNode("div", { class: "z-10 flex min-h-0 min-w-0 flex-1 flex-col" }, [
                        createVNode("div", { class: "group relative flex min-h-0 min-w-0 flex-1" }, [
                          createVNode(unref(motion).div, {
                            initial: { opacity: 0 },
                            animate: { opacity: 1 },
                            exit: { opacity: 0 },
                            transition: { duration: 0.3 },
                            class: [
                              "absolute z-30 flex items-center justify-between",
                              unref(isMobile) ? "top-2 right-2 left-2" : "top-4 right-4 left-4"
                            ]
                          }, {
                            default: withCtx(() => [
                              createVNode("div", { class: "flex items-center gap-1" }, [
                                unref(currentPhoto)?.isLivePhoto ? (openBlock(), createBlock(_component_PhotoLivePhotoIndicator, {
                                  key: 0,
                                  class: unref(isMobile) ? "cursor-default" : "cursor-pointer",
                                  photo: unref(currentPhoto),
                                  "is-video-playing": unref(isLivePhotoPlaying),
                                  "processing-state": unref(livePhotoProcessingState)?.value || null,
                                  onMouseenter: handleLivePhotoMouseEnter,
                                  onMouseleave: handleLivePhotoMouseLeave
                                }, null, 8, ["class", "photo", "is-video-playing", "processing-state"])) : createCommentVNode("", true),
                                unref(currentPhoto)?.isLivePhoto ? (openBlock(), createBlock("div", {
                                  key: 1,
                                  class: ["pointer-events-auto backdrop-blur-md bg-black/40 text-white rounded-full p-1 text-[13px] font-bold flex items-center gap-0.5 leading-0 select-none", unref(isMobile) ? "cursor-default" : "cursor-pointer"],
                                  onClick: ($event) => isLivePhotoMuted.value = !unref(isLivePhotoMuted)
                                }, [
                                  createVNode(_component_Icon, {
                                    name: unref(isLivePhotoMuted) ? "tabler:volume-off" : "tabler:volume",
                                    class: "size-[17px]"
                                  }, null, 8, ["name"])
                                ], 10, ["onClick"])) : createCommentVNode("", true)
                              ]),
                              createVNode("div", { class: "flex items-center gap-2" }, [
                                unref(isMobile) ? (openBlock(), createBlock(_component_GlassButton, {
                                  key: 0,
                                  icon: "tabler:info-circle",
                                  class: !unref(showExifPanel) ? "" : "bg-black/20 hover:bg-black/30 text-white",
                                  size: "sm",
                                  rounded: "",
                                  onClick: ($event) => showExifPanel.value = !unref(showExifPanel)
                                }, null, 8, ["class", "onClick"])) : createCommentVNode("", true),
                                createVNode(_component_GlassButton, {
                                  icon: "tabler:share-3",
                                  size: "sm",
                                  rounded: "",
                                  onClick: ($event) => showShareModal.value = true
                                }, null, 8, ["onClick"]),
                                createVNode(_component_GlassButton, {
                                  icon: "tabler:x",
                                  size: "sm",
                                  rounded: "",
                                  onClick: ($event) => emit("close")
                                }, null, 8, ["onClick"])
                              ])
                            ]),
                            _: 1
                          }, 8, ["class"]),
                          createVNode(LoadingIndicator, {
                            ref_key: "loadingIndicatorRef",
                            ref: loadingIndicatorRef
                          }, null, 512),
                          createVNode(unref(Swiper), {
                            modules: swiperModules,
                            "space-between": 0,
                            "slides-per-view": 1,
                            "initial-slide": __props.currentIndex,
                            virtual: true,
                            keyboard: {
                              enabled: true,
                              onlyInViewport: true
                            },
                            class: "h-full w-full",
                            style: { touchAction: unref(isMobile) ? "pan-x" : "pan-y" },
                            onSwiper: handleSwiperInit,
                            onSlideChange: handleSlideChange
                          }, {
                            default: withCtx(() => [
                              (openBlock(true), createBlock(Fragment, null, renderList(__props.photos, (photo, index2) => {
                                return openBlock(), createBlock(unref(SwiperSlide), {
                                  key: photo.id,
                                  "virtual-index": index2,
                                  class: "flex items-center justify-center"
                                }, {
                                  default: withCtx(() => [
                                    createVNode(unref(motion).div, {
                                      initial: { opacity: 0.5, scale: 0.95 },
                                      animate: { opacity: 1, scale: 1 },
                                      exit: { opacity: 0, scale: 0.95 },
                                      transition: { type: "spring", duration: 0.4, bounce: 0 },
                                      class: "relative flex h-full w-full items-center justify-center",
                                      style: { "user-select": "none", "-webkit-user-select": "none", "-webkit-touch-callout": "none", "-webkit-tap-highlight-color": "transparent" },
                                      onTouchstart: handleLivePhotoTouchStart,
                                      onTouchmove: handleLivePhotoTouchMove,
                                      onTouchend: handleLivePhotoTouchEnd,
                                      onTouchcancel: handleLivePhotoTouchEnd,
                                      onContextmenu: withModifiers(() => {
                                      }, ["prevent"])
                                    }, {
                                      default: withCtx(() => [
                                        createVNode(ProgressiveImage, {
                                          class: ["h-full w-full object-contain transition-opacity duration-400", {
                                            "opacity-0": unref(isLivePhotoPlaying) && unref(currentPhoto)?.isLivePhoto
                                          }],
                                          "loading-indicator-ref": unref(loadingIndicatorRef) || null,
                                          "is-current-image": index2 === __props.currentIndex,
                                          src: photo.originalUrl,
                                          "thumbnail-src": photo.thumbnailUrl,
                                          thumbhash: photo.thumbnailHash,
                                          alt: photo.title || "",
                                          width: index2 === __props.currentIndex ? unref(currentPhoto)?.width ?? void 0 : void 0,
                                          height: index2 === __props.currentIndex ? unref(currentPhoto)?.height ?? void 0 : void 0,
                                          "enable-pan": index2 === __props.currentIndex ? !unref(isMobile) || unref(isImageZoomed) : true,
                                          "enable-zoom": true,
                                          "on-zoom-change": index2 === __props.currentIndex ? handleZoomChange : void 0,
                                          "on-blob-src-change": index2 === __props.currentIndex ? handleBlobSrcChange : void 0,
                                          "on-image-loaded": index2 === __props.currentIndex ? handleImageLoaded : void 0,
                                          "is-live-photo": photo.isLivePhoto === 1,
                                          "live-photo-video-url": photo.livePhotoVideoUrl || void 0
                                        }, null, 8, ["class", "loading-indicator-ref", "is-current-image", "src", "thumbnail-src", "thumbhash", "alt", "width", "height", "enable-pan", "on-zoom-change", "on-blob-src-change", "on-image-loaded", "is-live-photo", "live-photo-video-url"]),
                                        photo.isLivePhoto && index2 === __props.currentIndex && unref(livePhotoVideoBlobUrl) ? (openBlock(), createBlock(unref(motion).video, {
                                          key: 0,
                                          ref_for: true,
                                          ref: (el) => {
                                            if (index2 === __props.currentIndex) livePhotoVideoRef.value = el;
                                          },
                                          src: unref(livePhotoVideoBlobUrl),
                                          class: "absolute inset-0 w-full h-full object-contain pointer-events-none select-none touch-none",
                                          muted: unref(isLivePhotoMuted),
                                          playsinline: "",
                                          preload: "metadata",
                                          initial: { opacity: 0 },
                                          animate: {
                                            opacity: unref(isLivePhotoPlaying) ? 1 : 0
                                          },
                                          transition: {
                                            duration: 0.4,
                                            ease: [0.25, 0.1, 0.25, 1],
                                            delay: unref(isLivePhotoPlaying) ? 0.1 : 0
                                          },
                                          onEnded: handleLivePhotoVideoEnded,
                                          onContextmenu: withModifiers(() => {
                                          }, ["prevent"])
                                        }, null, 8, ["src", "muted", "animate", "transition", "onContextmenu"])) : createCommentVNode("", true),
                                        createVNode(unref(_sfc_main$n), null, {
                                          default: withCtx(() => [
                                            unref(showZoomLevel) && unref(zoomLevel) > 0 ? (openBlock(), createBlock(unref(motion).div, {
                                              key: 0,
                                              initial: { opacity: 0, y: 10 },
                                              animate: { opacity: 1, y: 0 },
                                              exit: { opacity: 0, y: 10 },
                                              transition: { duration: 0.2 },
                                              class: "absolute bottom-4 left-4 z-20 bg-black/40 backdrop-blur-3xl rounded-xl border border-white/10 px-4 py-2 shadow-2xl"
                                            }, {
                                              default: withCtx(() => [
                                                createVNode("span", { class: "text-white font-medium" }, toDisplayString$1(unref(zoomLevel)) + "x", 1)
                                              ]),
                                              _: 1
                                            })) : createCommentVNode("", true)
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(unref(_sfc_main$n), null, {
                                          default: withCtx(() => [
                                            !unref(isImageZoomed) && !unref(isLivePhotoPlaying) ? (openBlock(), createBlock(unref(motion).div, {
                                              key: 0,
                                              initial: { opacity: 0, scale: 0.95 },
                                              animate: { opacity: 0.6, scale: 1 },
                                              exit: { opacity: 0, scale: 0.95 },
                                              transition: { duration: 0.2 },
                                              class: "absolute bottom-6 left-1/2 z-20 -translate-x-1/2 bg-black/50 rounded-lg border border-white/10 px-2 py-1 shadow-2xl text-white text-xs font-bold"
                                            }, {
                                              default: withCtx(() => [
                                                unref(currentPhoto)?.isLivePhoto && unref(isMobile) ? (openBlock(), createBlock("span", { key: 0 }, toDisplayString$1(_ctx.$t("viewer.hint.livePhoto.mobile")), 1)) : unref(currentPhoto)?.isLivePhoto && !unref(isMobile) ? (openBlock(), createBlock("span", { key: 1 }, toDisplayString$1(_ctx.$t("viewer.hint.livePhoto.desktop")), 1)) : (openBlock(), createBlock("span", { key: 2 }, toDisplayString$1(unref(isMobile) ? _ctx.$t("viewer.hint.mobile") : _ctx.$t("viewer.hint.desktop")), 1))
                                              ]),
                                              _: 1
                                            })) : createCommentVNode("", true)
                                          ]),
                                          _: 1
                                        }),
                                        createVNode(unref(_sfc_main$n), null, {
                                          default: withCtx(() => [
                                            !unref(isImageZoomed) && !unref(isLivePhotoPlaying) ? (openBlock(), createBlock(unref(motion).div, {
                                              key: 0,
                                              initial: { opacity: 0, scale: 0.8, y: 20 },
                                              animate: { opacity: 1, scale: 1, y: 0 },
                                              exit: { opacity: 0, scale: 0.8, y: 20 },
                                              transition: {
                                                type: "spring",
                                                stiffness: 300,
                                                damping: 20,
                                                delay: 0.1
                                              },
                                              class: "absolute bottom-4 right-4 z-20"
                                            }, {
                                              default: withCtx(() => [
                                                createVNode("div", { class: "relative" }, [
                                                  createVNode(ReactionPicker, {
                                                    "is-open": unref(showReactionPicker),
                                                    "selected-reaction": unref(selectedReaction),
                                                    "reaction-counts": unref(reactionCounts),
                                                    onSelect: handleReactionSelect,
                                                    onClose: ($event) => showReactionPicker.value = false
                                                  }, null, 8, ["is-open", "selected-reaction", "reaction-counts", "onClose"]),
                                                  unref(confettiIcon) ? (openBlock(), createBlock(ReactionConfetti, {
                                                    key: 0,
                                                    "icon-name": unref(confettiIcon),
                                                    "trigger-count": unref(confettiTriggerCount)
                                                  }, null, 8, ["icon-name", "trigger-count"])) : createCommentVNode("", true),
                                                  createVNode(unref(motion).button, {
                                                    type: "button",
                                                    initial: { scale: 0.8, opacity: 0 },
                                                    animate: {
                                                      scale: unref(showReactionPicker) ? 0.92 : 1,
                                                      opacity: 1,
                                                      transition: unref(showReactionPicker) ? { duration: 0.2, ease: [0.25, 0.1, 0.25, 1] } : {
                                                        type: "spring",
                                                        stiffness: 300,
                                                        damping: 25,
                                                        mass: 0.8
                                                      }
                                                    },
                                                    "while-hover": {
                                                      scale: unref(showReactionPicker) ? 0.95 : 1.05
                                                    },
                                                    "while-tap": { scale: 0.88 },
                                                    class: [
                                                      "pointer-events-auto flex items-center justify-center gap-2 cursor-pointer",
                                                      "px-4 h-11 rounded-full",
                                                      "backdrop-blur-xl border shadow-lg",
                                                      "transition-all duration-200",
                                                      unref(selectedReaction) ? "bg-blue-500/90 border-blue-400/50 text-white shadow-blue-500/30" : "bg-white/90 dark:bg-neutral-800/90 border-neutral-200/50 dark:border-white/10 text-neutral-700 dark:text-white/80 shadow-black/10 dark:shadow-black/30",
                                                      "hover:shadow-xl"
                                                    ],
                                                    onClick: toggleReactionPicker
                                                  }, {
                                                    default: withCtx(() => [
                                                      unref(selectedReaction) && unref(currentReactionIcon) ? (openBlock(), createBlock(_component_Icon, {
                                                        key: 0,
                                                        name: unref(currentReactionIcon),
                                                        class: "text-xl leading-none select-none"
                                                      }, null, 8, ["name"])) : (openBlock(), createBlock(_component_Icon, {
                                                        key: 1,
                                                        name: "tabler:mood-smile",
                                                        class: "text-xl"
                                                      })),
                                                      createVNode("div", { class: "flex flex-col items-start gap-0.5" }, [
                                                        createVNode("span", { class: "text-sm font-medium leading-none" }, toDisplayString$1(unref(selectedReaction) ? _ctx.$t("viewer.reaction.change") : _ctx.$t("viewer.reaction.add")), 1),
                                                        unref(totalReactions) > 0 ? (openBlock(), createBlock("span", {
                                                          key: 0,
                                                          class: "text-[10px] leading-none opacity-70"
                                                        }, toDisplayString$1(_ctx.$t(
                                                          "viewer.reaction.count",
                                                          { count: unref(totalReactions) },
                                                          unref(totalReactions)
                                                        )), 1)) : createCommentVNode("", true)
                                                      ])
                                                    ]),
                                                    _: 1
                                                  }, 8, ["animate", "while-hover", "class"])
                                                ])
                                              ]),
                                              _: 1
                                            })) : createCommentVNode("", true)
                                          ]),
                                          _: 1
                                        })
                                      ]),
                                      _: 2
                                    }, 1032, ["onContextmenu"])
                                  ]),
                                  _: 2
                                }, 1032, ["virtual-index"]);
                              }), 128))
                            ]),
                            _: 1
                          }, 8, ["initial-slide", "style"]),
                          !unref(isMobile) ? (openBlock(), createBlock(Fragment, { key: 0 }, [
                            __props.currentIndex > 0 ? (openBlock(), createBlock("button", {
                              key: 0,
                              type: "button",
                              class: "absolute top-1/2 left-4 z-20 flex size-8 -translate-y-1/2 items-center justify-center rounded-full text-white opacity-0 backdrop-blur-sm duration-200 group-hover:opacity-100 bg-black/30 hover:bg-black/40",
                              onClick: handlePrevious
                            }, [
                              createVNode(_component_Icon, {
                                name: "tabler:chevron-left",
                                class: "text-xl cursor-pointer"
                              })
                            ])) : createCommentVNode("", true),
                            __props.currentIndex < __props.photos.length - 1 ? (openBlock(), createBlock("button", {
                              key: 1,
                              type: "button",
                              class: "absolute top-1/2 right-4 z-20 flex size-8 -translate-y-1/2 items-center justify-center rounded-full text-white opacity-0 backdrop-blur-sm duration-200 group-hover:opacity-100 bg-black/30 hover:bg-black/40",
                              onClick: handleNext
                            }, [
                              createVNode(_component_Icon, {
                                name: "tabler:chevron-right",
                                class: "text-xl cursor-pointer"
                              })
                            ])) : createCommentVNode("", true)
                          ], 64)) : createCommentVNode("", true)
                        ]),
                        createVNode(GalleryThumbnail, {
                          "current-index": __props.currentIndex,
                          photos: __props.photos,
                          onIndexChange: ($event) => emit("indexChange", $event)
                        }, null, 8, ["current-index", "photos", "onIndexChange"])
                      ]),
                      unref(isMobile) ? (openBlock(), createBlock(unref(_sfc_main$n), { key: 0 }, {
                        default: withCtx(() => [
                          unref(showExifPanel) && unref(currentPhoto) ? (openBlock(), createBlock(InfoPanel, {
                            key: 0,
                            "current-photo": unref(currentPhoto),
                            "exif-data": unref(currentPhoto)?.exif,
                            "on-close": () => showExifPanel.value = false
                          }, null, 8, ["current-photo", "exif-data", "on-close"])) : createCommentVNode("", true)
                        ]),
                        _: 1
                      })) : unref(currentPhoto) ? (openBlock(), createBlock(InfoPanel, {
                        key: 1,
                        "current-photo": unref(currentPhoto),
                        "exif-data": unref(currentPhoto)?.exif
                      }, null, 8, ["current-photo", "exif-data"])) : createCommentVNode("", true)
                    ], 2)
                  ]),
                  _: 1
                }, 8, ["style", "onClick"])) : createCommentVNode("", true)
              ];
            }
          }),
          _: 1
        }, _parent));
        if (unref(currentPhoto)) {
          _push2(ssrRenderComponent(_component_PhotoShareModal, {
            "is-open": unref(showShareModal),
            photo: unref(currentPhoto),
            onClose: ($event) => showShareModal.value = false
          }, null, _parent));
        } else {
          _push2(`<!---->`);
        }
      }, "body", false, _parent);
    };
  }
});
const _sfc_setup$3 = _sfc_main$3.setup;
_sfc_main$3.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/photo/Viewer.vue");
  return _sfc_setup$3 ? _sfc_setup$3(props, ctx) : void 0;
};
const __nuxt_component_6 = /* @__PURE__ */ Object.assign(_export_sfc(_sfc_main$3, [["__scopeId", "data-v-3a8c3532"]]), { __name: "PhotoViewer" });
const useViewerState = defineStore("photo-viewer-state", () => {
  const currentPhotoIndex = ref(0);
  const isViewerOpen = ref(false);
  const returnRoute = ref(null);
  const isDirectAccess = ref(false);
  const openViewer = (index2, route) => {
    currentPhotoIndex.value = index2;
    isViewerOpen.value = true;
    if (route) {
      returnRoute.value = route;
      isDirectAccess.value = false;
    } else {
      isDirectAccess.value = true;
    }
  };
  const switchToIndex = (index2) => {
    currentPhotoIndex.value = index2;
  };
  const closeViewer = () => {
    isViewerOpen.value = false;
  };
  const clearReturnRoute = () => {
    returnRoute.value = null;
  };
  return {
    currentPhotoIndex,
    isViewerOpen,
    returnRoute,
    isDirectAccess,
    openViewer,
    switchToIndex,
    closeViewer,
    clearReturnRoute
  };
});
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "app",
  __ssrInlineRender: true,
  async setup(__props) {
    let __temp, __restore;
    const router = useRouter();
    const dayjs2 = useDayjs();
    const colorMode = useColorMode();
    const { locale } = useI18n();
    const settingsStore = useSettingsStore();
    [__temp, __restore] = withAsyncContext(() => settingsStore.initSettings()), await __temp, __restore();
    const appTitle = useSettingRef("app:title");
    colorMode.preference = useSettingRef("app:appearance.theme").value;
    useHead({
      titleTemplate: (title) => `${title ? title + " | " : ""}${appTitle.value || "ChronoFrame"}`
    });
    const { data, refresh, status } = useFetch("/api/photos", "$3oRWNoOsuN");
    const photos = computed(() => data.value || []);
    const { switchToIndex, closeViewer, clearReturnRoute } = useViewerState();
    const { currentPhotoIndex, isViewerOpen, returnRoute, isDirectAccess } = storeToRefs(useViewerState());
    const handleIndexChange = (newIndex) => {
      switchToIndex(newIndex);
      router.replace(`/${photos.value[newIndex]?.id}`);
    };
    const handleClose = () => {
      closeViewer();
      if (isDirectAccess.value) {
        isDirectAccess.value = false;
        router.replace("/");
      } else if (returnRoute.value) {
        const destination = returnRoute.value;
        clearReturnRoute();
        router.replace(destination);
      } else {
        if ((void 0).history.length > 1) {
          router.back();
        } else {
          router.replace("/");
        }
      }
    };
    watchEffect(() => {
      dayjs2.locale("zh-Hans", dayjsLocale_zhCN);
      dayjs2.locale("zh-Hant-TW", dayjsLocale_zhTW);
      dayjs2.locale("zh-Hant-HK", dayjsLocale_zhHK);
      dayjs2.locale(locale.value);
    });
    provide(
      "photosFiltering",
      reactive({
        activeFilters: {
          tags: [],
          cameras: [],
          lenses: [],
          cities: [],
          ratings: []
        }
      })
    );
    return (_ctx, _push, _parent, _attrs) => {
      const _component_UApp = __nuxt_component_0$3;
      const _component_NuxtLoadingIndicator = __nuxt_component_1$3;
      const _component_PhotosProvider = __nuxt_component_2$2;
      const _component_NuxtLayout = __nuxt_component_3;
      const _component_NuxtPage = __nuxt_component_7;
      const _component_ClientOnly = __nuxt_component_0$6;
      const _component_PhotoViewer = __nuxt_component_6;
      _push(ssrRenderComponent(_component_UApp, _attrs, {
        default: withCtx((_2, _push2, _parent2, _scopeId) => {
          if (_push2) {
            _push2(ssrRenderComponent(_component_NuxtLoadingIndicator, null, null, _parent2, _scopeId));
            _push2(ssrRenderComponent(_component_PhotosProvider, {
              photos: unref(photos),
              refresh: unref(refresh),
              status: unref(status)
            }, {
              default: withCtx((_22, _push3, _parent3, _scopeId2) => {
                if (_push3) {
                  _push3(ssrRenderComponent(_component_NuxtLayout, null, {
                    default: withCtx((_3, _push4, _parent4, _scopeId3) => {
                      if (_push4) {
                        _push4(ssrRenderComponent(_component_NuxtPage, null, null, _parent4, _scopeId3));
                      } else {
                        return [
                          createVNode(_component_NuxtPage)
                        ];
                      }
                    }),
                    _: 1
                  }, _parent3, _scopeId2));
                  _push3(ssrRenderComponent(_component_ClientOnly, null, {}, _parent3, _scopeId2));
                } else {
                  return [
                    createVNode(_component_NuxtLayout, null, {
                      default: withCtx(() => [
                        createVNode(_component_NuxtPage)
                      ]),
                      _: 1
                    }),
                    createVNode(_component_ClientOnly, null, {
                      default: withCtx(() => [
                        createVNode(_component_PhotoViewer, {
                          photos: unref(photos),
                          "current-index": unref(currentPhotoIndex),
                          "is-open": unref(isViewerOpen),
                          onClose: handleClose,
                          onIndexChange: handleIndexChange
                        }, null, 8, ["photos", "current-index", "is-open"])
                      ]),
                      _: 1
                    })
                  ];
                }
              }),
              _: 1
            }, _parent2, _scopeId));
          } else {
            return [
              createVNode(_component_NuxtLoadingIndicator),
              createVNode(_component_PhotosProvider, {
                photos: unref(photos),
                refresh: unref(refresh),
                status: unref(status)
              }, {
                default: withCtx(() => [
                  createVNode(_component_NuxtLayout, null, {
                    default: withCtx(() => [
                      createVNode(_component_NuxtPage)
                    ]),
                    _: 1
                  }),
                  createVNode(_component_ClientOnly, null, {
                    default: withCtx(() => [
                      createVNode(_component_PhotoViewer, {
                        photos: unref(photos),
                        "current-index": unref(currentPhotoIndex),
                        "is-open": unref(isViewerOpen),
                        onClose: handleClose,
                        onIndexChange: handleIndexChange
                      }, null, 8, ["photos", "current-index", "is-open"])
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["photos", "refresh", "status"])
            ];
          }
        }),
        _: 1
      }, _parent));
    };
  }
});
const _sfc_setup$2 = _sfc_main$2.setup;
_sfc_main$2.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("app.vue");
  return _sfc_setup$2 ? _sfc_setup$2(props, ctx) : void 0;
};
const _sfc_main$1 = {
  __name: "nuxt-error-page",
  __ssrInlineRender: true,
  props: {
    error: Object
  },
  setup(__props) {
    const props = __props;
    const _error = props.error;
    const statusCode = Number(_error.statusCode || 500);
    const is404 = statusCode === 404;
    const statusMessage = _error.statusMessage ?? (is404 ? "Page Not Found" : "Internal Server Error");
    const description = _error.message || _error.toString();
    const stack = void 0;
    const _Error404 = defineAsyncComponent(() => import('./error-404-BbB45sVv.mjs'));
    const _Error = defineAsyncComponent(() => import('./error-500-CiAgHVnV.mjs'));
    const ErrorTemplate = is404 ? _Error404 : _Error;
    return (_ctx, _push, _parent, _attrs) => {
      _push(ssrRenderComponent(unref(ErrorTemplate), mergeProps({ statusCode: unref(statusCode), statusMessage: unref(statusMessage), description: unref(description), stack: unref(stack) }, _attrs), null, _parent));
    };
  }
};
const _sfc_setup$1 = _sfc_main$1.setup;
_sfc_main$1.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/nuxt@4.2.2_@parcel+watcher@2.5.1_@types+node@22.19.3_@vue+compiler-sfc@3.5.26_better-sq_e5daeaa80ff686017e711928af1155fd/node_modules/nuxt/dist/app/components/nuxt-error-page.vue");
  return _sfc_setup$1 ? _sfc_setup$1(props, ctx) : void 0;
};
const _sfc_main = {
  __name: "nuxt-root",
  __ssrInlineRender: true,
  setup(__props) {
    const IslandRenderer = defineAsyncComponent(() => import('./island-renderer-KpJL92GW.mjs').then((r) => r.default || r));
    const nuxtApp = useNuxtApp();
    nuxtApp.deferHydration();
    nuxtApp.ssrContext.url;
    const SingleRenderer = false;
    provide(PageRouteSymbol, useRoute());
    nuxtApp.hooks.callHookWith((hooks) => hooks.map((hook) => hook()), "vue:setup");
    const error = /* @__PURE__ */ useError();
    const abortRender = error.value && !nuxtApp.ssrContext.error;
    onErrorCaptured((err, target, info) => {
      nuxtApp.hooks.callHook("vue:error", err, target, info).catch((hookError) => console.error("[nuxt] Error in `vue:error` hook", hookError));
      {
        const p = nuxtApp.runWithContext(() => showError(err));
        onServerPrefetch(() => p);
        return false;
      }
    });
    const islandContext = nuxtApp.ssrContext.islandContext;
    return (_ctx, _push, _parent, _attrs) => {
      ssrRenderSuspense(_push, {
        default: () => {
          if (unref(abortRender)) {
            _push(`<div></div>`);
          } else if (unref(error)) {
            _push(ssrRenderComponent(unref(_sfc_main$1), { error: unref(error) }, null, _parent));
          } else if (unref(islandContext)) {
            _push(ssrRenderComponent(unref(IslandRenderer), { context: unref(islandContext) }, null, _parent));
          } else if (unref(SingleRenderer)) {
            ssrRenderVNode(_push, createVNode(resolveDynamicComponent(unref(SingleRenderer)), null, null), _parent);
          } else {
            _push(ssrRenderComponent(unref(_sfc_main$2), null, null, _parent));
          }
        },
        _: 1
      });
    };
  }
};
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../node_modules/.pnpm/nuxt@4.2.2_@parcel+watcher@2.5.1_@types+node@22.19.3_@vue+compiler-sfc@3.5.26_better-sq_e5daeaa80ff686017e711928af1155fd/node_modules/nuxt/dist/app/components/nuxt-root.vue");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
let entry;
{
  entry = async function createNuxtAppServer(ssrContext) {
    const vueApp = createApp(_sfc_main);
    const nuxt = createNuxtApp({ vueApp, ssrContext });
    try {
      await applyPlugins(nuxt, plugins);
      await nuxt.hooks.callHook("app:created", vueApp);
    } catch (error) {
      await nuxt.hooks.callHook("app:error", error);
      nuxt.payload.error ||= createError(error);
    }
    if (ssrContext?._renderResponse) {
      throw new Error("skipping render");
    }
    return vueApp;
  };
}
const entry_default = (ssrContext) => entry(ssrContext);

export { formStateInjectionKey as $, useThrottleFn as A, _sfc_main$v as B, useUserSession as C, useToast as D, useRuntimeConfig as E, useNuxtApp as F, useOgImageRuntimeConfig as G, setHeadOgImagePrebuilt as H, getOgImagePath as I, useRequestEvent as J, createOgImageMeta as K, useViewerState as L, useState as M, getSetting as N, useAsyncData as O, useMediaQuery as P, _sfc_main$B as Q, _sfc_main$8 as R, Primitive as S, useAppConfig as T, useForwardProps as U, reactivePick as V, tv as W, _sfc_main$y as X, useForwardExpose as Y, formBusInjectionKey as Z, _export_sfc as _, __nuxt_component_0$5 as a, pickLinkProps as a$, useEventBus as a0, formErrorsInjectionKey as a1, formInputsInjectionKey as a2, formLoadingInjectionKey as a3, formOptionsInjectionKey as a4, inputIdInjectionKey as a5, formFieldInjectionKey as a6, useVModel as a7, useFormField as a8, useFieldGroup as a9, getTabbableCandidates as aA, focus as aB, AUTOFOCUS_ON_UNMOUNT as aC, EVENT_OPTIONS as aD, getTabbableEdges as aE, useLocale as aF, useCookie as aG, useStorage as aH, reactiveOmit as aI, useLocalStorage as aJ, useFetch as aK, setInterval as aL, formatBytes as aM, _sfc_main$u as aN, usePrimitiveElement as aO, useParentElement as aP, compare as aQ, useGtag as aR, useDomRef as aS, useLivePhotoProcessor as aT, __nuxt_component_1$2 as aU, formatCameraInfo as aV, useEmitAsProps as aW, useFocusWithin as aX, __nuxt_component_1 as aY, omit as aZ, _sfc_main$w as a_, useComponentIcons as aa, looseToNumber as ab, injectTooltipProviderContext as ac, useTimeoutFn as ad, createContext$1 as ae, VisuallyHidden_default as af, useForwardPropsEmits as ag, Presence_default as ah, Teleport_default as ai, useKbd as aj, usePortal as ak, injectConfigProviderContext as al, createReusableTemplate as am, isNullish$1 as an, useCollection as ao, useResizeObserver as ap, getActiveElement as aq, isArrayOfArray as ar, get as as, _sfc_main$z as at, getDisplayValue as au, createSharedComposable$1 as av, tryOnBeforeUnmount as aw, createGlobalState as ax, AUTOFOCUS_ON_MOUNT as ay, focusFirst as az, unrefElement$1 as b, _sfc_main$x as b0, reactiveOmit$1 as b1, useEventListener$1 as b2, useColorMode as b3, useDebounceFn$1 as b4, isClient as b5, __nuxt_component_7 as b6, useSiteConfig as b7, parseURL as b8, createError as c, createEventHook as d, entry_default as default, defaultWindow$1 as e, useMounted$1 as f, computedEager as g, useVModel$1 as h, injectHead as i, __nuxt_component_2$1 as j, _sfc_main$n as k, __nuxt_component_0$4 as l, motion as m, useDayjs as n, onKeyStroke as o, __nuxt_component_0$1 as p, useI18n as q, refAutoReset as r, syncRef as s, tryOnScopeDispose$1 as t, useHead as u, useRoute as v, useRouter as w, usePhotos as x, __nuxt_component_0$6 as y, __nuxt_component_0 as z };
//# sourceMappingURL=server.mjs.map
